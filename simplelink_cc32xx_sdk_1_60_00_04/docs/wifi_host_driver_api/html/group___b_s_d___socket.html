<!-- HTML header for doxygen 1.8.9.1-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.12"/>
<title>SimpleLink CC3120/CC3220 Host Driver: BSD_Socket</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="slgen.css" rel="stylesheet" type="text/css"/>
<link href="slnavtree.css" rel="stylesheet" type="text/css"/>
<link href="sltabs.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="4" cellpadding="4">
 <tbody>
 <tr>
  <td id="projectlogo"><img alt="Logo" src="ti_logo.png" height="50px" /></td>
  <td style="padding-left: 0.5em;">
   <div id="projectname">SimpleLink CC3120/CC3220 Host Driver
   &#160;<span id="projectnumber">Version&#160;2.0.1.26</span>
   </div>
   <div id="projectbrief">Simplifies the implementation of Internet connectivity</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.12 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('group___b_s_d___socket.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a> &#124;
<a href="#typedef-members">Typedefs</a>  </div>
  <div class="headertitle">
<div class="title">BSD_Socket</div>  </div>
</div><!--header-->
<div class="contents">

<p>Controls standard client/server sockets programming options and capabilities.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga636674bf9937205b85a797ee6077faa9"><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="group___b_s_d___socket.html#structhostent">hostent</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___b_s_d___socket.html#ga636674bf9937205b85a797ee6077faa9">gethostbyname</a> (const char *name)</td></tr>
<tr class="memdesc:ga636674bf9937205b85a797ee6077faa9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get host IP by name<br />
Obtain the IP Address of machine on network, by machine name.  <a href="#ga636674bf9937205b85a797ee6077faa9">More...</a><br /></td></tr>
<tr class="separator:ga636674bf9937205b85a797ee6077faa9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabe92cff4414f58438af2502fae12121a"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___b_s_d___socket.html#gabe92cff4414f58438af2502fae12121a">select</a> (int nfds, fd_set *readsds, fd_set *writesds, fd_set *exceptsds, struct timeval *timeout)</td></tr>
<tr class="memdesc:gabe92cff4414f58438af2502fae12121a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Monitor socket activity.  <a href="#gabe92cff4414f58438af2502fae12121a">More...</a><br /></td></tr>
<tr class="separator:gabe92cff4414f58438af2502fae12121a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3069f151a5fd4a29e3f0dafe7af43ea8"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___b_s_d___socket.html#ga3069f151a5fd4a29e3f0dafe7af43ea8">socket</a> (int Domain, int Type, int Protocol)</td></tr>
<tr class="memdesc:ga3069f151a5fd4a29e3f0dafe7af43ea8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create an endpoint for communication.  <a href="#ga3069f151a5fd4a29e3f0dafe7af43ea8">More...</a><br /></td></tr>
<tr class="separator:ga3069f151a5fd4a29e3f0dafe7af43ea8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad87d2a7392fe37239fe278ac4dad4da3"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___b_s_d___socket.html#gad87d2a7392fe37239fe278ac4dad4da3">close</a> (int sd)</td></tr>
<tr class="memdesc:gad87d2a7392fe37239fe278ac4dad4da3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gracefully close socket.  <a href="#gad87d2a7392fe37239fe278ac4dad4da3">More...</a><br /></td></tr>
<tr class="separator:gad87d2a7392fe37239fe278ac4dad4da3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9cd9fbec0dbb386f3ed5fce6c0bdb20a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___b_s_d___socket.html#ga9cd9fbec0dbb386f3ed5fce6c0bdb20a">accept</a> (int sd, sockaddr *addr, socklen_t *addrlen)</td></tr>
<tr class="memdesc:ga9cd9fbec0dbb386f3ed5fce6c0bdb20a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Accept a connection on a socket.  <a href="#ga9cd9fbec0dbb386f3ed5fce6c0bdb20a">More...</a><br /></td></tr>
<tr class="separator:ga9cd9fbec0dbb386f3ed5fce6c0bdb20a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga203a2eda9a8c5a71d6056c67cae6aff5"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___b_s_d___socket.html#ga203a2eda9a8c5a71d6056c67cae6aff5">bind</a> (int sd, const sockaddr *addr, socklen_t addrlen)</td></tr>
<tr class="memdesc:ga203a2eda9a8c5a71d6056c67cae6aff5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assign a name to a socket.  <a href="#ga203a2eda9a8c5a71d6056c67cae6aff5">More...</a><br /></td></tr>
<tr class="separator:ga203a2eda9a8c5a71d6056c67cae6aff5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac0e1e895317be91692b6b8cc7e12b252"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___b_s_d___socket.html#gac0e1e895317be91692b6b8cc7e12b252">listen</a> (int sd, int backlog)</td></tr>
<tr class="memdesc:gac0e1e895317be91692b6b8cc7e12b252"><td class="mdescLeft">&#160;</td><td class="mdescRight">Listen for connections on a socket.  <a href="#gac0e1e895317be91692b6b8cc7e12b252">More...</a><br /></td></tr>
<tr class="separator:gac0e1e895317be91692b6b8cc7e12b252"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8548b5734b7684ed0a0f4b684ed726c9"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___b_s_d___socket.html#ga8548b5734b7684ed0a0f4b684ed726c9">connect</a> (int sd, const sockaddr *addr, socklen_t addrlen)</td></tr>
<tr class="memdesc:ga8548b5734b7684ed0a0f4b684ed726c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initiate a connection on a socket.  <a href="#ga8548b5734b7684ed0a0f4b684ed726c9">More...</a><br /></td></tr>
<tr class="separator:ga8548b5734b7684ed0a0f4b684ed726c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaafa5721213ca1bfb2c1ab1ea0f39bf5c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___b_s_d___socket.html#gaafa5721213ca1bfb2c1ab1ea0f39bf5c">setsockopt</a> (int sd, int level, int optname, const void *optval, socklen_t optlen)</td></tr>
<tr class="memdesc:gaafa5721213ca1bfb2c1ab1ea0f39bf5c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set socket options-.  <a href="#gaafa5721213ca1bfb2c1ab1ea0f39bf5c">More...</a><br /></td></tr>
<tr class="separator:gaafa5721213ca1bfb2c1ab1ea0f39bf5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga37e0195dbaf69283dd8541c2ae631b82"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___b_s_d___socket.html#ga37e0195dbaf69283dd8541c2ae631b82">getsockopt</a> (int sd, int level, int optname, void *optval, socklen_t *optlen)</td></tr>
<tr class="memdesc:ga37e0195dbaf69283dd8541c2ae631b82"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get socket options.  <a href="#ga37e0195dbaf69283dd8541c2ae631b82">More...</a><br /></td></tr>
<tr class="separator:ga37e0195dbaf69283dd8541c2ae631b82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad78fc85141d8c310b14d399f055823a6"><td class="memItemLeft" align="right" valign="top">ssize_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___b_s_d___socket.html#gad78fc85141d8c310b14d399f055823a6">recv</a> (int sd, void *pBuf, size_t Len, int flags)</td></tr>
<tr class="memdesc:gad78fc85141d8c310b14d399f055823a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read data from TCP socket.  <a href="#gad78fc85141d8c310b14d399f055823a6">More...</a><br /></td></tr>
<tr class="separator:gad78fc85141d8c310b14d399f055823a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8d0c3ce56a97523b4c46e9e28b6d1434"><td class="memItemLeft" align="right" valign="top">ssize_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___b_s_d___socket.html#ga8d0c3ce56a97523b4c46e9e28b6d1434">recvfrom</a> (int sd, void *buf, _i16 Len, _i16 flags, sockaddr *from, socklen_t *fromlen)</td></tr>
<tr class="memdesc:ga8d0c3ce56a97523b4c46e9e28b6d1434"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read data from socket.  <a href="#ga8d0c3ce56a97523b4c46e9e28b6d1434">More...</a><br /></td></tr>
<tr class="separator:ga8d0c3ce56a97523b4c46e9e28b6d1434"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5292f928b7aca5f3c8b86e77a4a02b67"><td class="memItemLeft" align="right" valign="top">ssize_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___b_s_d___socket.html#ga5292f928b7aca5f3c8b86e77a4a02b67">send</a> (int sd, const void *pBuf, _i16 Len, _i16 flags)</td></tr>
<tr class="memdesc:ga5292f928b7aca5f3c8b86e77a4a02b67"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write data to TCP socket.  <a href="#ga5292f928b7aca5f3c8b86e77a4a02b67">More...</a><br /></td></tr>
<tr class="separator:ga5292f928b7aca5f3c8b86e77a4a02b67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7c398c633b0f21a8ed43730d17030ba4"><td class="memItemLeft" align="right" valign="top">ssize_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___b_s_d___socket.html#ga7c398c633b0f21a8ed43730d17030ba4">sendto</a> (int sd, const void *pBuf, size_t Len, int flags, const sockaddr *to, socklen_t tolen)</td></tr>
<tr class="memdesc:ga7c398c633b0f21a8ed43730d17030ba4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write data to socket.  <a href="#ga7c398c633b0f21a8ed43730d17030ba4">More...</a><br /></td></tr>
<tr class="separator:ga7c398c633b0f21a8ed43730d17030ba4"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:gac548eb02704bb58dad238e28e060c4d4"><td class="memItemLeft" align="right" valign="top"><a id="gac548eb02704bb58dad238e28e060c4d4"></a>
typedef struct <a class="el" href="group___b_s_d___socket.html#structhostent">hostent</a>&#160;</td><td class="memItemRight" valign="bottom"><b>hostent_t</b></td></tr>
<tr class="separator:gac548eb02704bb58dad238e28e060c4d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>Controls standard client/server sockets programming options and capabilities. </p>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga9cd9fbec0dbb386f3ed5fce6c0bdb20a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9cd9fbec0dbb386f3ed5fce6c0bdb20a">&sect;&nbsp;</a></span>accept()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int accept </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>sd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sockaddr *&#160;</td>
          <td class="paramname"><em>addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">socklen_t *&#160;</td>
          <td class="paramname"><em>addrlen</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Accept a connection on a socket. </p>
<p>This function is used with connection-based socket types (SOCK_STREAM).<br />
It extracts the first connection request on the queue of pending connections, creates a new connected socket, and returns a new file descriptor referring to that socket.<br />
The newly created socket is not in the listening state. The original socket sd is unaffected by this call. <br />
The argument sd is a socket that has been created with <a class="el" href="group___b_s_d___socket.html#ga3069f151a5fd4a29e3f0dafe7af43ea8" title="Create an endpoint for communication. ">socket()</a>, bound to a local address with <a class="el" href="group___b_s_d___socket.html#ga203a2eda9a8c5a71d6056c67cae6aff5" title="Assign a name to a socket. ">bind()</a>, and is listening for connections after a <a class="el" href="group___b_s_d___socket.html#gac0e1e895317be91692b6b8cc7e12b252" title="Listen for connections on a socket. ">listen()</a>. The argument <b><em>addr</em> is</b> a pointer to a sockaddr structure. This structure is filled in with the address of the peer socket, as known to the communications layer. The exact format of the address returned addr is determined by the socket's address family. <br />
The <b><em>addrlen</em> argument</b> is a value-result argument: it should initially contain the size of the structure pointed to by addr, on return it will contain the actual length (in bytes) of the address returned.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">sd</td><td>Socket descriptor (handle) </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">addr</td><td>The argument addr is a pointer to a sockaddr structure. This structure is filled in with the address of the peer socket, as known to the communications layer. The exact format of the address returned addr is determined by the socket's address<br />
 sockaddr:<br />
 - code for the address format. On this version only AF_INET is supported.<br />
 - socket address, the length depends on the code format </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">addrlen</td><td>The addrlen argument is a value-result argument: it should initially contain the size of the structure pointed to by addr</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>On success, a socket handle.<br />
 On a non-blocking accept a possible retrun is -1 and errno is set to EAGAIN.<br />
 On failure, errno is set and -1 is returned.<br />
 ENOMEM may be return in case there are no resources in the system In this case try again later or increase MAX_CONCURRENT_ACTIONS.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group___b_s_d___socket.html#ga3069f151a5fd4a29e3f0dafe7af43ea8" title="Create an endpoint for communication. ">socket</a> <a class="el" href="group___b_s_d___socket.html#ga203a2eda9a8c5a71d6056c67cae6aff5" title="Assign a name to a socket. ">bind</a> <a class="el" href="group___b_s_d___socket.html#gac0e1e895317be91692b6b8cc7e12b252" title="Listen for connections on a socket. ">listen</a> </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Belongs to server_side </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd></dd></dl>

<p>Definition at line <a class="el" href="socket_8c_source.html#l00130">130</a> of file <a class="el" href="socket_8c_source.html">socket.c</a>.</p>
<div class="fragment"><div class="line"><a name="l00131"></a><span class="lineno">  131</span>&#160;{</div><div class="line"><a name="l00132"></a><span class="lineno">  132</span>&#160;    <span class="keywordtype">int</span> RetVal = (int)<a class="code" href="group___socket.html#ga72085bf8fae027f8fe31a0eb99a6808b">sl_Accept</a>(sd, addr, addrlen);</div><div class="line"><a name="l00133"></a><span class="lineno">  133</span>&#160;    <span class="keywordflow">return</span> _SlDrvSetErrno(RetVal);</div><div class="line"><a name="l00134"></a><span class="lineno">  134</span>&#160;}</div><div class="ttc" id="group___socket_html_ga72085bf8fae027f8fe31a0eb99a6808b"><div class="ttname"><a href="group___socket.html#ga72085bf8fae027f8fe31a0eb99a6808b">sl_Accept</a></div><div class="ttdeci">_i16 sl_Accept(_i16 sd, SlSockAddr_t *addr, SlSocklen_t *addrlen)</div><div class="ttdoc">Accept a connection on a socket. </div><div class="ttdef"><b>Definition:</b> <a href="sl__socket_8c_source.html#l00692">sl_socket.c:692</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="ga203a2eda9a8c5a71d6056c67cae6aff5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga203a2eda9a8c5a71d6056c67cae6aff5">&sect;&nbsp;</a></span>bind()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int bind </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>sd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sockaddr *&#160;</td>
          <td class="paramname"><em>addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">socklen_t&#160;</td>
          <td class="paramname"><em>addrlen</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Assign a name to a socket. </p>
<p>This function gives the socket the local address addr. addr is addrlen bytes long. Traditionally, this is called When a socket is created with socket, it exists in a name space (address family) but has no name assigned. It is necessary to assign a local address before a SOCK_STREAM socket may receive connections.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">sd</td><td>Socket descriptor (handle) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">addr</td><td>Specifies the destination addrs<br />
 sockaddr:<br />
 - code for the address format. On this version only AF_INET is supported.<br />
 - socket address, the length depends on the code format. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">addrlen</td><td>Contains the size of the structure pointed to by addr</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Zero on success, or -1 on failure and sets errno to the corresponding BDS error code.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group___b_s_d___socket.html#ga3069f151a5fd4a29e3f0dafe7af43ea8" title="Create an endpoint for communication. ">socket</a> <a class="el" href="group___b_s_d___socket.html#ga9cd9fbec0dbb386f3ed5fce6c0bdb20a" title="Accept a connection on a socket. ">accept</a> <a class="el" href="group___b_s_d___socket.html#gac0e1e895317be91692b6b8cc7e12b252" title="Listen for connections on a socket. ">listen</a> </dd></dl>
<dl class="section note"><dt>Note</dt><dd>belongs to basic_api </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd></dd></dl>

<p>Definition at line <a class="el" href="socket_8c_source.html#l00063">63</a> of file <a class="el" href="socket_8c_source.html">socket.c</a>.</p>
<div class="fragment"><div class="line"><a name="l00064"></a><span class="lineno">   64</span>&#160;{</div><div class="line"><a name="l00065"></a><span class="lineno">   65</span>&#160;    <span class="keywordtype">int</span> RetVal = (int)<a class="code" href="group___socket.html#gadcb0c4792127dceb1feb3e9b87ab2094">sl_Bind</a>(sd, addr, addrlen);</div><div class="line"><a name="l00066"></a><span class="lineno">   66</span>&#160;    <span class="keywordflow">return</span> _SlDrvSetErrno(RetVal);</div><div class="line"><a name="l00067"></a><span class="lineno">   67</span>&#160;}</div><div class="ttc" id="group___socket_html_gadcb0c4792127dceb1feb3e9b87ab2094"><div class="ttname"><a href="group___socket.html#gadcb0c4792127dceb1feb3e9b87ab2094">sl_Bind</a></div><div class="ttdeci">_i16 sl_Bind(_i16 sd, const SlSockAddr_t *addr, _i16 addrlen)</div><div class="ttdoc">Assign a name to a socket. </div><div class="ttdef"><b>Definition:</b> <a href="sl__socket_8c_source.html#l00240">sl_socket.c:240</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="gad87d2a7392fe37239fe278ac4dad4da3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad87d2a7392fe37239fe278ac4dad4da3">&sect;&nbsp;</a></span>close()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int close </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>sd</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gracefully close socket. </p>
<p>This function causes the system to release resources allocated to a socket. <br />
In case of TCP, the connection is terminated.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">sd</td><td>Socket handle (received in socket)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Zero on success, or negative error code on failure</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group___b_s_d___socket.html#ga3069f151a5fd4a29e3f0dafe7af43ea8" title="Create an endpoint for communication. ">socket</a> </dd></dl>
<dl class="section note"><dt>Note</dt><dd>belongs to ext_api </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd></dd></dl>

<p>Definition at line <a class="el" href="socket_8h_source.html#l00162">162</a> of file <a class="el" href="socket_8h_source.html">socket.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00163"></a><span class="lineno">  163</span>&#160;{</div><div class="line"><a name="l00164"></a><span class="lineno">  164</span>&#160;    <span class="keywordtype">int</span> RetVal = (int)<a class="code" href="group___socket.html#gacc7971a6e41592c8ef90936b25495a8b">sl_Close</a>((_i16)sd);</div><div class="line"><a name="l00165"></a><span class="lineno">  165</span>&#160;    <span class="keywordflow">return</span> _SlDrvSetErrno(RetVal);</div><div class="line"><a name="l00166"></a><span class="lineno">  166</span>&#160;}</div><div class="ttc" id="group___socket_html_gacc7971a6e41592c8ef90936b25495a8b"><div class="ttname"><a href="group___socket.html#gacc7971a6e41592c8ef90936b25495a8b">sl_Close</a></div><div class="ttdeci">_i16 sl_Close(_i16 sd)</div><div class="ttdoc">Gracefully close socket. </div><div class="ttdef"><b>Definition:</b> <a href="sl__socket_8c_source.html#l00180">sl_socket.c:180</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="ga8548b5734b7684ed0a0f4b684ed726c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8548b5734b7684ed0a0f4b684ed726c9">&sect;&nbsp;</a></span>connect()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int connect </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>sd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sockaddr *&#160;</td>
          <td class="paramname"><em>addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">socklen_t&#160;</td>
          <td class="paramname"><em>addrlen</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initiate a connection on a socket. </p>
<p>Function connects the socket referred to by the socket descriptor sd, to the address specified by addr. The addrlen argument specifies the size of addr. The format of the address in addr is determined by the address space of the socket. If it is of type SOCK_DGRAM, this call specifies the peer with which the socket is to be associated; this address is that to which datagrams are to be sent, and the only address from which datagrams are to be received. If the socket is of type SOCK_STREAM, this call attempts to make a connection to another socket. The other socket is specified by address, which is an address in the communications space of the socket.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">sd</td><td>Socket descriptor (handle) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">addr</td><td>Specifies the destination addr<br />
 sockaddr:<br />
 - code for the address format. On this version only AF_INET is supported.<br />
 - socket address, the length depends on the code format</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">addrlen</td><td>Contains the size of the structure pointed to by addr</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>On success, a socket handle.<br />
 On a non-blocking connect a possible negative value is EALREADY. On failure, -1 is returned and sets errno to the corresponding BDS error code.<br />
 ENOMEM may be return in case there are no resources in the system In this case try again later or increase MAX_CONCURRENT_ACTIONS</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group___socket.html#gaa775fcb6d09bf35b9dac3e5eb8e8c997" title="Create an endpoint for communication. ">sl_Socket</a> </dd></dl>
<dl class="section note"><dt>Note</dt><dd>belongs to client_side </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd></dd></dl>

<p>Definition at line <a class="el" href="socket_8c_source.html#l00097">97</a> of file <a class="el" href="socket_8c_source.html">socket.c</a>.</p>
<div class="fragment"><div class="line"><a name="l00098"></a><span class="lineno">   98</span>&#160;{</div><div class="line"><a name="l00099"></a><span class="lineno">   99</span>&#160;    <span class="keywordtype">int</span> RetVal = (int)<a class="code" href="group___socket.html#gad8b9db85493e84b19994840f4cff0ca0">sl_Connect</a>(sd, addr, addrlen);</div><div class="line"><a name="l00100"></a><span class="lineno">  100</span>&#160;    <span class="keywordflow">return</span> _SlDrvSetErrno(RetVal);</div><div class="line"><a name="l00101"></a><span class="lineno">  101</span>&#160;}</div><div class="ttc" id="group___socket_html_gad8b9db85493e84b19994840f4cff0ca0"><div class="ttname"><a href="group___socket.html#gad8b9db85493e84b19994840f4cff0ca0">sl_Connect</a></div><div class="ttdeci">_i16 sl_Connect(_i16 sd, const SlSockAddr_t *addr, _i16 addrlen)</div><div class="ttdoc">Initiate a connection on a socket. </div><div class="ttdef"><b>Definition:</b> <a href="sl__socket_8c_source.html#l00456">sl_socket.c:456</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="ga636674bf9937205b85a797ee6077faa9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga636674bf9937205b85a797ee6077faa9">&sect;&nbsp;</a></span>gethostbyname()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="group___b_s_d___socket.html#structhostent">hostent</a>* gethostbyname </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get host IP by name<br />
Obtain the IP Address of machine on network, by machine name. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">const</td><td>char *name Host name</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Struct hostent containing the answer on success or NULL failure.<br />
 </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group___net_app.html#ga627fbeda3eea582e2f16de61d5d315f6" title="Get host IP by name Obtain the IP Address of machine on network, by machine name. ...">sl_NetAppDnsGetHostByName</a></dd></dl>
<dl class="section note"><dt>Note</dt><dd>Note: The function isn't reentrant! It utilize a static hostent struct which holds the answer for the DNS query. Calling this function form several threads may result in invalid answers. A user interested in a reentrant function which resolves IP address by name, can use the SimpleLink API: 'sl_NetAppDnsGetHostByName'. Another option is to protect this call with a lock and copy the returned hostent struct to a user buffer, before unlocking.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>The parameter 'name' is assumed to be allocated by the user, and it's the user's Responsibility to maintain it's validity. This field is copied (not deep copied) to the struct returned by this function.</dd></dl>
<dl class="section user"><dt>Example</dt><dd></dd></dl>
<ul>
<li>Getting host by name: <div class="fragment"><div class="line"><span class="keyword">struct </span>sockaddr_in sa;</div><div class="line"><span class="keyword">struct </span><a class="code" href="group___b_s_d___socket.html#structhostent">hostent</a> *host_addr;</div><div class="line"></div><div class="line">host_addr = <a class="code" href="group___b_s_d___socket.html#ga636674bf9937205b85a797ee6077faa9">gethostbyname</a>(<span class="stringliteral">&quot;www.cloudprovider.com&quot;</span>);</div><div class="line"></div><div class="line"><span class="keywordflow">if</span>(!host_addr)</div><div class="line">{</div><div class="line">    sa.sin_family = host_addr-&gt;h_addrtype;</div><div class="line">    memcpy(&amp;sa.sin_addr.s_addr, host_addr-&gt;h_addr_list, host_addr-&gt;h_length);</div><div class="line">    sa.sin_port = htons(80);</div><div class="line">}</div><div class="line"></div><div class="line"><a class="code" href="group___b_s_d___socket.html#ga8548b5734b7684ed0a0f4b684ed726c9">connect</a>(Socketfd, (<span class="keyword">struct</span> sockaddr *)&amp;sa, <span class="keyword">sizeof</span>(sa));</div></div><!-- fragment --> </li>
</ul>

<p>Definition at line <a class="el" href="netdb_8c_source.html#l00050">50</a> of file <a class="el" href="netdb_8c_source.html">netdb.c</a>.</p>
<div class="fragment"><div class="line"><a name="l00051"></a><span class="lineno">   51</span>&#160;{</div><div class="line"><a name="l00052"></a><span class="lineno">   52</span>&#160;    <span class="keyword">static</span> <span class="keyword">struct </span><a class="code" href="group___b_s_d___socket.html#structhostent">hostent</a> Hostent;</div><div class="line"><a name="l00053"></a><span class="lineno">   53</span>&#160;    <span class="keyword">static</span> <span class="keywordtype">char</span>*  AddrArray[2];</div><div class="line"><a name="l00054"></a><span class="lineno">   54</span>&#160;    <span class="keyword">static</span> <span class="keywordtype">char</span>   Addr[IPv6_ADDR_LEN];</div><div class="line"><a name="l00055"></a><span class="lineno">   55</span>&#160;</div><div class="line"><a name="l00056"></a><span class="lineno">   56</span>&#160;    <span class="keywordtype">int</span> RetVal = 0;</div><div class="line"><a name="l00057"></a><span class="lineno">   57</span>&#160;</div><div class="line"><a name="l00058"></a><span class="lineno">   58</span>&#160;    <span class="comment">/* Clear the reused buffer */</span></div><div class="line"><a name="l00059"></a><span class="lineno">   59</span>&#160;    _SlDrvMemZero(&amp;Hostent, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> <a class="code" href="group___b_s_d___socket.html#structhostent">hostent</a>));</div><div class="line"><a name="l00060"></a><span class="lineno">   60</span>&#160;    _SlDrvMemZero(&amp;AddrArray, <span class="keyword">sizeof</span>(AddrArray));</div><div class="line"><a name="l00061"></a><span class="lineno">   61</span>&#160;    _SlDrvMemZero(&amp;Addr, <span class="keyword">sizeof</span>(Addr));</div><div class="line"><a name="l00062"></a><span class="lineno">   62</span>&#160;</div><div class="line"><a name="l00063"></a><span class="lineno">   63</span>&#160;    <span class="comment">/* Set the host name */</span></div><div class="line"><a name="l00064"></a><span class="lineno">   64</span>&#160;    Hostent.h_name = (<span class="keywordtype">char</span>*)name;</div><div class="line"><a name="l00065"></a><span class="lineno">   65</span>&#160;    <span class="comment">/* Query DNS for IPv4 address. */</span></div><div class="line"><a name="l00066"></a><span class="lineno">   66</span>&#160;    RetVal = <a class="code" href="group___net_app.html#ga627fbeda3eea582e2f16de61d5d315f6">sl_NetAppDnsGetHostByName</a>((<span class="keywordtype">signed</span> <span class="keywordtype">char</span>*)name , (_u16)strlen(name), (<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span>*)(&amp;Addr), AF_INET);</div><div class="line"><a name="l00067"></a><span class="lineno">   67</span>&#160;</div><div class="line"><a name="l00068"></a><span class="lineno">   68</span>&#160;    <span class="keywordflow">if</span>(RetVal &lt; 0)</div><div class="line"><a name="l00069"></a><span class="lineno">   69</span>&#160;    {</div><div class="line"><a name="l00070"></a><span class="lineno">   70</span>&#160;        <span class="comment">/* If call fails, try again for IPv6. */</span></div><div class="line"><a name="l00071"></a><span class="lineno">   71</span>&#160;        RetVal = <a class="code" href="group___net_app.html#ga627fbeda3eea582e2f16de61d5d315f6">sl_NetAppDnsGetHostByName</a>((<span class="keywordtype">signed</span> <span class="keywordtype">char</span>*)name , (_u16)strlen(name), (<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span>*)(&amp;Addr), AF_INET6);</div><div class="line"><a name="l00072"></a><span class="lineno">   72</span>&#160;        <span class="keywordflow">if</span>(RetVal &lt; 0)</div><div class="line"><a name="l00073"></a><span class="lineno">   73</span>&#160;        {</div><div class="line"><a name="l00074"></a><span class="lineno">   74</span>&#160;            <span class="comment">/* if the request failed twice, there&#39;s an error - return NULL. */</span></div><div class="line"><a name="l00075"></a><span class="lineno">   75</span>&#160;            <span class="keywordflow">return</span> NULL;</div><div class="line"><a name="l00076"></a><span class="lineno">   76</span>&#160;        }</div><div class="line"><a name="l00077"></a><span class="lineno">   77</span>&#160;        <span class="keywordflow">else</span></div><div class="line"><a name="l00078"></a><span class="lineno">   78</span>&#160;        {</div><div class="line"><a name="l00079"></a><span class="lineno">   79</span>&#160;            <span class="comment">/* fill the answer fields */</span></div><div class="line"><a name="l00080"></a><span class="lineno">   80</span>&#160;            Hostent.h_addrtype = AF_INET6 ;</div><div class="line"><a name="l00081"></a><span class="lineno">   81</span>&#160;            Hostent.h_length = IPv6_ADDR_LEN;</div><div class="line"><a name="l00082"></a><span class="lineno">   82</span>&#160;        }</div><div class="line"><a name="l00083"></a><span class="lineno">   83</span>&#160;    }</div><div class="line"><a name="l00084"></a><span class="lineno">   84</span>&#160;    <span class="keywordflow">else</span></div><div class="line"><a name="l00085"></a><span class="lineno">   85</span>&#160;    {</div><div class="line"><a name="l00086"></a><span class="lineno">   86</span>&#160;        <span class="comment">/* fill the answer fields */</span></div><div class="line"><a name="l00087"></a><span class="lineno">   87</span>&#160;        Hostent.h_addrtype = AF_INET ;</div><div class="line"><a name="l00088"></a><span class="lineno">   88</span>&#160;        Hostent.h_length = IPv4_ADDR_LEN;</div><div class="line"><a name="l00089"></a><span class="lineno">   89</span>&#160;    }</div><div class="line"><a name="l00090"></a><span class="lineno">   90</span>&#160;</div><div class="line"><a name="l00091"></a><span class="lineno">   91</span>&#160;    AddrArray[0] = &amp;Addr[0];</div><div class="line"><a name="l00092"></a><span class="lineno">   92</span>&#160;    Hostent.h_addr_list = AddrArray;</div><div class="line"><a name="l00093"></a><span class="lineno">   93</span>&#160;</div><div class="line"><a name="l00094"></a><span class="lineno">   94</span>&#160;    <span class="comment">/* Return the address of the reused buffer */</span></div><div class="line"><a name="l00095"></a><span class="lineno">   95</span>&#160;    <span class="keywordflow">return</span> (&amp;Hostent);</div><div class="line"><a name="l00096"></a><span class="lineno">   96</span>&#160;}</div><div class="ttc" id="group___net_app_html_ga627fbeda3eea582e2f16de61d5d315f6"><div class="ttname"><a href="group___net_app.html#ga627fbeda3eea582e2f16de61d5d315f6">sl_NetAppDnsGetHostByName</a></div><div class="ttdeci">_i16 sl_NetAppDnsGetHostByName(_i8 *pHostName, const _u16 NameLen, _u32 *OutIpAddr, const _u8 Family)</div><div class="ttdoc">Get host IP by name Obtain the IP Address of machine on network, by machine name. ...</div><div class="ttdef"><b>Definition:</b> <a href="netapp_8c_source.html#l00810">netapp.c:810</a></div></div>
<div class="ttc" id="group___b_s_d___socket_html_structhostent"><div class="ttname"><a href="group___b_s_d___socket.html#structhostent">hostent</a></div><div class="ttdef"><b>Definition:</b> <a href="netdb_8h_source.html#l00062">netdb.h:62</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="ga37e0195dbaf69283dd8541c2ae631b82"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga37e0195dbaf69283dd8541c2ae631b82">&sect;&nbsp;</a></span>getsockopt()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int getsockopt </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>sd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>optname</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>optval</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">socklen_t *&#160;</td>
          <td class="paramname"><em>optlen</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get socket options. </p>
<p>This function manipulate the options associated with a socket. Options may exist at multiple protocol levels; they are always present at the uppermost socket level.<br />
 When manipulating socket options the level at which the option resides and the name of the option must be specified. To manipulate options at the socket level, level is specified as SOL_SOCKET. To manipulate options at any other level the protocol number of the appropriate proto- col controlling the option is supplied. For example, to indicate that an option is to be interpreted by the TCP protocol, level should be set to the protocol number of TCP; <br />
 The parameters optval and optlen are used to access optval - ues for <a class="el" href="group___b_s_d___socket.html#gaafa5721213ca1bfb2c1ab1ea0f39bf5c" title="Set socket options-. ">setsockopt()</a>. For <a class="el" href="group___b_s_d___socket.html#ga37e0195dbaf69283dd8541c2ae631b82" title="Get socket options. ">getsockopt()</a> they identify a buffer in which the value for the requested option(s) are to be returned. For <a class="el" href="group___b_s_d___socket.html#ga37e0195dbaf69283dd8541c2ae631b82" title="Get socket options. ">getsockopt()</a>, optlen is a value-result parameter, initially containing the size of the buffer pointed to by option_value, and modified on return to indicate the actual size of the value returned. If no option value is to be supplied or returned, option_value may be NULL.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">sd</td><td>Socket handle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">level</td><td>Defines the protocol level for this option </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">optname</td><td>defines the option name to interrogate </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">optval</td><td>Specifies a value for the option </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">optlen</td><td>Specifies the length of the option value</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Zero on success, or -1 on failure and sets errno to the corresponding BDS error code. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group___b_s_d___socket.html#gaafa5721213ca1bfb2c1ab1ea0f39bf5c" title="Set socket options-. ">setsockopt</a> Belongs to ext_api </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd></dd></dl>

<p>Definition at line <a class="el" href="socket_8c_source.html#l00184">184</a> of file <a class="el" href="socket_8c_source.html">socket.c</a>.</p>
<div class="fragment"><div class="line"><a name="l00185"></a><span class="lineno">  185</span>&#160;{</div><div class="line"><a name="l00186"></a><span class="lineno">  186</span>&#160;    <span class="keywordflow">switch</span>(optname)</div><div class="line"><a name="l00187"></a><span class="lineno">  187</span>&#160;    {</div><div class="line"><a name="l00188"></a><span class="lineno">  188</span>&#160;    <span class="comment">/* This option (TCP_NODELAY) is always set by the NWP, hence we always return true */</span>   </div><div class="line"><a name="l00189"></a><span class="lineno">  189</span>&#160;        <span class="keywordflow">case</span> TCP_NODELAY:</div><div class="line"><a name="l00190"></a><span class="lineno">  190</span>&#160;        <span class="keywordflow">if</span>(optval)</div><div class="line"><a name="l00191"></a><span class="lineno">  191</span>&#160;        {</div><div class="line"><a name="l00192"></a><span class="lineno">  192</span>&#160;            (*(_u32*)optval) = TRUE;</div><div class="line"><a name="l00193"></a><span class="lineno">  193</span>&#160;            <span class="keywordflow">return</span> 0;</div><div class="line"><a name="l00194"></a><span class="lineno">  194</span>&#160;        }</div><div class="line"><a name="l00195"></a><span class="lineno">  195</span>&#160;    <span class="comment">/* These sock opts Aren&#39;t supported by the cc31xx\cc32xx network stack, </span></div><div class="line"><a name="l00196"></a><span class="lineno">  196</span>&#160;<span class="comment">       hence, we silently ignore them and set errno to EINVAL (invalid argument).</span></div><div class="line"><a name="l00197"></a><span class="lineno">  197</span>&#160;<span class="comment">       This is made in order to not break of &quot;off-the-shelf&quot; BSD code. */</span></div><div class="line"><a name="l00198"></a><span class="lineno">  198</span>&#160;        <span class="keywordflow">case</span> SO_BROADCAST:</div><div class="line"><a name="l00199"></a><span class="lineno">  199</span>&#160;        <span class="keywordflow">case</span> SO_REUSEADDR:</div><div class="line"><a name="l00200"></a><span class="lineno">  200</span>&#160;        <span class="keywordflow">case</span> SO_SNDBUF:</div><div class="line"><a name="l00201"></a><span class="lineno">  201</span>&#160;            <span class="keywordflow">return</span> _SlDrvSetErrno(EINVAL);</div><div class="line"><a name="l00202"></a><span class="lineno">  202</span>&#160;        <span class="keywordflow">default</span>:</div><div class="line"><a name="l00203"></a><span class="lineno">  203</span>&#160;            <span class="keywordflow">break</span>;</div><div class="line"><a name="l00204"></a><span class="lineno">  204</span>&#160;    }</div><div class="line"><a name="l00205"></a><span class="lineno">  205</span>&#160;    </div><div class="line"><a name="l00206"></a><span class="lineno">  206</span>&#160;    <span class="keywordtype">int</span> RetVal = (int)<a class="code" href="group___socket.html#ga77d6029b0c39df5541b0b0d6484591b4">sl_GetSockOpt</a>(sd, level, optname, optval, optlen);</div><div class="line"><a name="l00207"></a><span class="lineno">  207</span>&#160;    <span class="keywordflow">return</span> _SlDrvSetErrno(RetVal);</div><div class="line"><a name="l00208"></a><span class="lineno">  208</span>&#160;}</div><div class="ttc" id="group___socket_html_ga77d6029b0c39df5541b0b0d6484591b4"><div class="ttname"><a href="group___socket.html#ga77d6029b0c39df5541b0b0d6484591b4">sl_GetSockOpt</a></div><div class="ttdeci">_i16 sl_GetSockOpt(_i16 sd, _i16 level, _i16 optname, void *optval, SlSocklen_t *optlen)</div><div class="ttdoc">Get socket options. </div><div class="ttdef"><b>Definition:</b> <a href="sl__socket_8c_source.html#l00968">sl_socket.c:968</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="gac0e1e895317be91692b6b8cc7e12b252"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac0e1e895317be91692b6b8cc7e12b252">&sect;&nbsp;</a></span>listen()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int listen </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>sd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>backlog</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Listen for connections on a socket. </p>
<p>The willingness to accept incoming connections and a queue limit for incoming connections are specified with <a class="el" href="group___b_s_d___socket.html#gac0e1e895317be91692b6b8cc7e12b252" title="Listen for connections on a socket. ">listen()</a>, and then the connections are accepted with accept. The <a class="el" href="group___b_s_d___socket.html#gac0e1e895317be91692b6b8cc7e12b252" title="Listen for connections on a socket. ">listen()</a> call applies only to sockets of type SOCK_STREAM The backlog parameter defines the maximum length the queue of pending connections may grow to.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">sd</td><td>Socket descriptor (handle) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">backlog</td><td>Specifies the listen queue depth.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Zero on success, or -1 on failure and sets errno to the corresponding BDS error code.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group___b_s_d___socket.html#ga3069f151a5fd4a29e3f0dafe7af43ea8" title="Create an endpoint for communication. ">socket</a> <a class="el" href="group___b_s_d___socket.html#ga9cd9fbec0dbb386f3ed5fce6c0bdb20a" title="Accept a connection on a socket. ">accept</a> <a class="el" href="group___b_s_d___socket.html#ga203a2eda9a8c5a71d6056c67cae6aff5" title="Assign a name to a socket. ">bind</a> </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Belongs to server_side </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd></dd></dl>

<p>Definition at line <a class="el" href="socket_8c_source.html#l00119">119</a> of file <a class="el" href="socket_8c_source.html">socket.c</a>.</p>
<div class="fragment"><div class="line"><a name="l00120"></a><span class="lineno">  120</span>&#160;{</div><div class="line"><a name="l00121"></a><span class="lineno">  121</span>&#160;    <span class="keywordtype">int</span> RetVal = (int)<a class="code" href="group___socket.html#ga7d864d86f8dd7296774072db021a69e7">sl_Listen</a>(sd, backlog);</div><div class="line"><a name="l00122"></a><span class="lineno">  122</span>&#160;    <span class="keywordflow">return</span> _SlDrvSetErrno(RetVal);</div><div class="line"><a name="l00123"></a><span class="lineno">  123</span>&#160;}</div><div class="ttc" id="group___socket_html_ga7d864d86f8dd7296774072db021a69e7"><div class="ttname"><a href="group___socket.html#ga7d864d86f8dd7296774072db021a69e7">sl_Listen</a></div><div class="ttdeci">_i16 sl_Listen(_i16 sd, _i16 backlog)</div><div class="ttdoc">Listen for connections on a socket. </div><div class="ttdef"><b>Definition:</b> <a href="sl__socket_8c_source.html#l00658">sl_socket.c:658</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="gad78fc85141d8c310b14d399f055823a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad78fc85141d8c310b14d399f055823a6">&sect;&nbsp;</a></span>recv()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ssize_t recv </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>sd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>pBuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>Len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read data from TCP socket. </p>
<p>Function receives a message from a connection-mode socket</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">sd</td><td>Socket handle </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">buf</td><td>Points to the buffer where the message should be stored. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">len</td><td>Specifies the length in bytes of the buffer pointed to by the buffer argument. Range: 1-16000 bytes </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">flags</td><td>Specifies the type of message reception. On this version, this parameter is not supported.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Return the number of bytes received, or a -1 if an error occurred. Errno is set accordingly.<br />
 Using a non-blocking recv a possible errno value is EAGAIN.<br />
 errno may be set to ENOMEM in case there are no resources in the system In this case try again later or increase MAX_CONCURRENT_ACTIONS</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group___socket.html#ga02f8b2eb34db39069a1385d4fce80eea" title="Read data from socket. ">sl_RecvFrom</a> </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Belongs to recv_api </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd></dd></dl>
<dl class="section user"><dt>Examples</dt><dd></dd></dl>
<ul>
<li>Receiving data using TCP socket: <div class="fragment"><div class="line">sockaddr_in  Addr;</div><div class="line">sockaddr_in  LocalAddr;</div><div class="line"><span class="keywordtype">int</span> AddrSize = <span class="keyword">sizeof</span>(socklen_t);</div><div class="line"><span class="keywordtype">int</span> SockID, newSockID;</div><div class="line"><span class="keywordtype">int</span> Status;</div><div class="line"><span class="keywordtype">char</span> Buf[RECV_BUF_LEN];</div><div class="line"></div><div class="line">LocalAddr.sin_family = AF_INET;</div><div class="line">LocalAddr.sin_port = htons(5001);</div><div class="line">LocalAddr.sin_addr.s_addr = 0;</div><div class="line"></div><div class="line">Addr.sin_family = AF_INET;</div><div class="line">Addr.sin_port = htons(5001);</div><div class="line">Addr.sin_addr.s_addr = htonl(SL_IPV4_VAL(10,1,1,200));</div><div class="line"></div><div class="line">SockID = <a class="code" href="group___b_s_d___socket.html#ga3069f151a5fd4a29e3f0dafe7af43ea8">socket</a>(AF_INET, SOCK_STREAM, 0);</div><div class="line">Status = <a class="code" href="group___b_s_d___socket.html#ga203a2eda9a8c5a71d6056c67cae6aff5">bind</a>(SockID, (sockaddr *)&amp;LocalAddr, AddrSize);</div><div class="line">Status = <a class="code" href="group___b_s_d___socket.html#gac0e1e895317be91692b6b8cc7e12b252">listen</a>(SockID, 0);</div><div class="line">newSockID = <a class="code" href="group___b_s_d___socket.html#ga9cd9fbec0dbb386f3ed5fce6c0bdb20a">accept</a>(SockID, (sockaddr *)&amp;Addr, (socklen_t*) &amp;AddrSize);</div><div class="line">Status = <a class="code" href="group___b_s_d___socket.html#gad78fc85141d8c310b14d399f055823a6">recv</a>(newSockID, Buf, 1460, 0);</div></div><!-- fragment --> <br />
 </li>
</ul>

<p>Definition at line <a class="el" href="socket_8c_source.html#l00141">141</a> of file <a class="el" href="socket_8c_source.html">socket.c</a>.</p>
<div class="fragment"><div class="line"><a name="l00142"></a><span class="lineno">  142</span>&#160;{</div><div class="line"><a name="l00143"></a><span class="lineno">  143</span>&#160;    ssize_t RetVal = (ssize_t)<a class="code" href="group___socket.html#ga26a0eacfbab2629e7f3daa0ad0080255">sl_Recv</a>(sd, pBuf, (_i16)Len, flags);</div><div class="line"><a name="l00144"></a><span class="lineno">  144</span>&#160;    <span class="keywordflow">return</span> (ssize_t)(_SlDrvSetErrno(RetVal));</div><div class="line"><a name="l00145"></a><span class="lineno">  145</span>&#160;}</div><div class="ttc" id="group___socket_html_ga26a0eacfbab2629e7f3daa0ad0080255"><div class="ttname"><a href="group___socket.html#ga26a0eacfbab2629e7f3daa0ad0080255">sl_Recv</a></div><div class="ttdeci">_i16 sl_Recv(_i16 sd, void *buf, _i16 len, _i16 flags)</div><div class="ttdoc">Read data from TCP socket. </div><div class="ttdef"><b>Definition:</b> <a href="sl__socket_8c_source.html#l00874">sl_socket.c:874</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="ga8d0c3ce56a97523b4c46e9e28b6d1434"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8d0c3ce56a97523b4c46e9e28b6d1434">&sect;&nbsp;</a></span>recvfrom()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ssize_t recvfrom </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>sd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_i16&#160;</td>
          <td class="paramname"><em>Len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_i16&#160;</td>
          <td class="paramname"><em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sockaddr *&#160;</td>
          <td class="paramname"><em>from</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">socklen_t *&#160;</td>
          <td class="paramname"><em>fromlen</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read data from socket. </p>
<p>Function receives a message from a connection-mode or connectionless-mode socket</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">sd</td><td>Socket handle </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">buf</td><td>Points to the buffer where the message should be stored. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">len</td><td>Specifies the length in bytes of the buffer pointed to by the buffer argument. Range: 1-16000 bytes </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">flags</td><td>Specifies the type of message reception. On this version, this parameter is not supported. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">from</td><td>Pointer to an address structure indicating the source address.<br />
 sockaddr:<br />
 - code for the address format. On this version only AF_INET is supported.<br />
 - socket address, the length depends on the code format </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">fromlen</td><td>Source address structure size. This parameter MUST be set to the size of the structure pointed to by addr.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Return the number of bytes received, or a -1 if an error occurred. Errno is set accordingly.<br />
 Using a non-blocking recv a possible errno value is EAGAIN.<br />
 errno will be set to EINVAL if fromlen has incorrect length. <br />
 errno may be set to ENOMEM in case there are no resources in the system In this case try again later or increase MAX_CONCURRENT_ACTIONS</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group___b_s_d___socket.html#gad78fc85141d8c310b14d399f055823a6" title="Read data from TCP socket. ">recv</a> </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Belongs to recv_api </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd></dd></dl>
<dl class="section user"><dt>Example</dt><dd></dd></dl>
<ul>
<li>Receiving data: <div class="fragment"><div class="line">sockaddr_in  Addr;</div><div class="line">sockaddr_in  LocalAddr;</div><div class="line"><span class="keywordtype">int</span> AddrSize = <span class="keyword">sizeof</span>(socklen_t);</div><div class="line"><span class="keywordtype">int</span> SockID, newSockID;</div><div class="line"><span class="keywordtype">int</span> Status;</div><div class="line"><span class="keywordtype">char</span> Buf[RECV_BUF_LEN];</div><div class="line"></div><div class="line">LocalAddr.sin_family = AF_INET;</div><div class="line">LocalAddr.sin_port = htons(5001);</div><div class="line">LocalAddr.sin_addr.s_addr = 0;</div><div class="line"></div><div class="line">SockID = <a class="code" href="group___b_s_d___socket.html#ga3069f151a5fd4a29e3f0dafe7af43ea8">socket</a>(AF_INET, SOCK_STREAM, 0);</div><div class="line">Status = <a class="code" href="group___b_s_d___socket.html#ga203a2eda9a8c5a71d6056c67cae6aff5">bind</a>(SockID, (sockaddr *)&amp;LocalAddr, AddrSize);</div><div class="line">Status = <a class="code" href="group___b_s_d___socket.html#ga8d0c3ce56a97523b4c46e9e28b6d1434">recvfrom</a>(SockID, Buf, 1472, 0, (sockaddr_in *)&amp;Addr, (socklen_t*)&amp;AddrSize); </div></div><!-- fragment --> </li>
</ul>

<p>Definition at line <a class="el" href="socket_8c_source.html#l00086">86</a> of file <a class="el" href="socket_8c_source.html">socket.c</a>.</p>
<div class="fragment"><div class="line"><a name="l00087"></a><span class="lineno">   87</span>&#160;{</div><div class="line"><a name="l00088"></a><span class="lineno">   88</span>&#160;    ssize_t RetVal = (ssize_t)<a class="code" href="group___socket.html#ga02f8b2eb34db39069a1385d4fce80eea">sl_RecvFrom</a>(sd, buf, Len, flags, from, fromlen);</div><div class="line"><a name="l00089"></a><span class="lineno">   89</span>&#160;    <span class="keywordflow">return</span> (ssize_t)(_SlDrvSetErrno(RetVal));</div><div class="line"><a name="l00090"></a><span class="lineno">   90</span>&#160;}</div><div class="ttc" id="group___socket_html_ga02f8b2eb34db39069a1385d4fce80eea"><div class="ttname"><a href="group___socket.html#ga02f8b2eb34db39069a1385d4fce80eea">sl_RecvFrom</a></div><div class="ttdeci">_i16 sl_RecvFrom(_i16 sd, void *buf, _i16 len, _i16 flags, SlSockAddr_t *from, SlSocklen_t *fromlen)</div><div class="ttdoc">Read data from socket. </div><div class="ttdef"><b>Definition:</b> <a href="sl__socket_8c_source.html#l00367">sl_socket.c:367</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="gabe92cff4414f58438af2502fae12121a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabe92cff4414f58438af2502fae12121a">&sect;&nbsp;</a></span>select()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int select </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nfds</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">fd_set *&#160;</td>
          <td class="paramname"><em>readsds</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">fd_set *&#160;</td>
          <td class="paramname"><em>writesds</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">fd_set *&#160;</td>
          <td class="paramname"><em>exceptsds</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct timeval *&#160;</td>
          <td class="paramname"><em>timeout</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Monitor socket activity. </p>
<p>Select allow a program to monitor multiple file descriptors, waiting until one or more of the file descriptors become "ready" for some class of I/O operation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">nfds</td><td>The highest-numbered file descriptor in any of the three sets, plus 1. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">readsds</td><td>Socket descriptors list for read monitoring and accept monitoring </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">writesds</td><td>Socket descriptors list for connect monitoring only, write monitoring is not supported </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">exceptsds</td><td>Socket descriptors list for exception monitoring, not supported. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">timeout</td><td>Is an upper bound on the amount of time elapsed before <a class="el" href="group___b_s_d___socket.html#gabe92cff4414f58438af2502fae12121a" title="Monitor socket activity. ">select()</a> returns. Null or above 0xffff seconds means infinity timeout. The minimum timeout is 10 milliseconds, less than 10 milliseconds will be set automatically to 10 milliseconds. Max microseconds supported is 0xfffc00. In trigger mode the timout fields must be set to zero.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>On success, <a class="el" href="group___b_s_d___socket.html#gabe92cff4414f58438af2502fae12121a" title="Monitor socket activity. ">select()</a> returns the number of file descriptors contained in the three returned descriptor sets (that is, the total number of bits that are set in readfds, writefds, exceptfds) which may be zero if the timeout expires before anything interesting happens.<br />
 On error, a negative value is returned. readsds - return the sockets on which read request will return without delay with valid data.<br />
 writesds - return the sockets on which write request will return without delay.<br />
 exceptsds - return the sockets closed recently. (not supported)<br />
 ENOMEM may be return in case there are no resources in the system In this case try again later or increase MAX_CONCURRENT_ACTIONS </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group___socket.html#gaa775fcb6d09bf35b9dac3e5eb8e8c997" title="Create an endpoint for communication. ">sl_Socket</a> </dd></dl>
<dl class="section note"><dt>Note</dt><dd>If the timeout value set to less than 10ms it will automatically set to 10ms to prevent overload of the system<br />
 Belongs to basic_api</dd></dl>
<p>Several threads can call select at the same time.<b>Calling</b> this API while the same command is called from another thread, may result in one of the following scenarios:</p><ol type="1">
<li>The command will be executed alongside other select callers (success).</li>
<li>The command will wait (internal) until the previous select finish, and then be executed.</li>
<li>There are not enough resources and SL_POOL_IS_EMPTY error will return. In this case, ENOMEM can be increased (result in memory increase) or try again later to issue the command.</li>
</ol>
<p>In case all the user sockets are open, select will exhibit the behaviour mentioned in (2) This is due to the fact select supports multiple callers by utilizing one user socket internally. User who wish to ensure multiple select calls at any given time, must reserve one socket out of the 16 given.</p>
<dl class="section warning"><dt>Warning</dt><dd></dd></dl>
<dl class="section user"><dt>Example</dt><dd></dd></dl>
<ul>
<li>Monitoring two sockets:</li>
</ul>
<div class="fragment"><div class="line"><span class="keywordtype">int</span> socketFD1;</div><div class="line"><span class="keywordtype">int</span> socketFD2;</div><div class="line">fd_set readfds;</div><div class="line"><span class="keyword">struct </span>timeval tv;</div><div class="line"></div><div class="line"><span class="comment">// go and connect to both  servers</span></div><div class="line">socketFD1 = <a class="code" href="group___b_s_d___socket.html#ga3069f151a5fd4a29e3f0dafe7af43ea8">socket</a>(...);</div><div class="line">socketFD2 = <a class="code" href="group___b_s_d___socket.html#ga3069f151a5fd4a29e3f0dafe7af43ea8">socket</a>(...);</div><div class="line"><a class="code" href="group___b_s_d___socket.html#ga8548b5734b7684ed0a0f4b684ed726c9">connect</a>(socketFD1, ...)...</div><div class="line">connect(socketFD2, ...)...</div><div class="line"></div><div class="line"><span class="comment">// clear the set ahead of time</span></div><div class="line">FD_ZERO(&amp;readfds);</div><div class="line"></div><div class="line"><span class="comment">// add our descriptors to the set</span></div><div class="line">FD_SET(socketFD1, &amp;readfds);</div><div class="line">FD_SET(socketFD2, &amp;readfds);</div><div class="line"></div><div class="line"><span class="comment">// since we opened socketFD2 second, it&#39;s the &quot;greater&quot;, so we use that for</span></div><div class="line"><span class="comment">// the nfds param in select();</span></div><div class="line">n = socketFD2 + 1;</div><div class="line"></div><div class="line"><span class="comment">// wait until either socket has data ready to be recv() (we set timeout to 10.5 Sec)</span></div><div class="line">tv.tv_sec = 10;</div><div class="line">tv.tv_usec = 500000;</div><div class="line">retVal = <a class="code" href="group___b_s_d___socket.html#gabe92cff4414f58438af2502fae12121a">select</a>(n, &amp;readfds, NULL, NULL, &amp;tv);</div><div class="line"></div><div class="line"><span class="keywordflow">if</span> (retVal == -1)</div><div class="line">{</div><div class="line">    printf(<span class="stringliteral">&quot;error: %d in select().\n&quot;</span>, errno);</div><div class="line">}</div><div class="line"><span class="keywordflow">else</span> <span class="keywordflow">if</span> (retVal == 0)</div><div class="line">{</div><div class="line">    printf(<span class="stringliteral">&quot;Timeout occurred!  No data after 10.5 seconds.\n&quot;</span>);</div><div class="line">}</div><div class="line"><span class="keywordflow">else</span></div><div class="line">{</div><div class="line">    <span class="comment">// one or both of the descriptors have data: go ahead and read it.</span></div><div class="line">    <span class="keywordflow">if</span> (FD_ISSET(socketFD1, &amp;readfds))</div><div class="line">    {</div><div class="line">        <a class="code" href="group___b_s_d___socket.html#gad78fc85141d8c310b14d399f055823a6">recv</a>(socketFD1, buf1, <span class="keyword">sizeof</span> buf1, 0);</div><div class="line">    }</div><div class="line">    <span class="keywordflow">if</span> (FD_ISSET(socketFD2, &amp;readfds))</div><div class="line">    {</div><div class="line">        <a class="code" href="group___b_s_d___socket.html#gad78fc85141d8c310b14d399f055823a6">recv</a>(socketFD2, buf2, <span class="keyword">sizeof</span> buf2, 0);</div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --> 
<p>Definition at line <a class="el" href="select_8h_source.html#l00185">185</a> of file <a class="el" href="select_8h_source.html">select.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00186"></a><span class="lineno">  186</span>&#160;{</div><div class="line"><a name="l00187"></a><span class="lineno">  187</span>&#160;    <span class="keywordtype">int</span> RetVal = (int)<a class="code" href="group___socket.html#ga97747fea9f469feeb7272b76e4fe9a0e">sl_Select</a>(nfds, readsds, writesds, exceptsds, timeout);</div><div class="line"><a name="l00188"></a><span class="lineno">  188</span>&#160;    <span class="keywordflow">return</span> _SlDrvSetErrno(RetVal);</div><div class="line"><a name="l00189"></a><span class="lineno">  189</span>&#160;}</div><div class="ttc" id="group___socket_html_ga97747fea9f469feeb7272b76e4fe9a0e"><div class="ttname"><a href="group___socket.html#ga97747fea9f469feeb7272b76e4fe9a0e">sl_Select</a></div><div class="ttdeci">_i16 sl_Select(_i16 nfds, SlFdSet_t *readsds, SlFdSet_t *writesds, SlFdSet_t *exceptsds, struct SlTimeval_t *timeout)</div><div class="ttdoc">Monitor socket activity. </div><div class="ttdef"><b>Definition:</b> <a href="sl__socket_8c_source.html#l01707">sl_socket.c:1707</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="ga5292f928b7aca5f3c8b86e77a4a02b67"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5292f928b7aca5f3c8b86e77a4a02b67">&sect;&nbsp;</a></span>send()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ssize_t send </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>sd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>pBuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_i16&#160;</td>
          <td class="paramname"><em>Len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_i16&#160;</td>
          <td class="paramname"><em>flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write data to TCP socket. </p>
<p>This function is used to transmit a message to another socket. Returns immediately after sending data to device. In case of TCP failure an async event SL_SOCKET_TX_FAILED_EVENT is going to be received.<br />
 </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">sd</td><td>Socket handle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">buf</td><td>Points to a buffer containing the message to be sent </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">len</td><td>Message size in bytes. Range: 1-1460 bytes </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">flags</td><td>Specifies the type of message transmission. On this version, this parameter is not supported for TCP.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Zero on success, or -1 on failure and sets errno to the corresponding BDS error code.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group___socket.html#ga7ca76d181974c71673c3bf3fc1fedfdc" title="Write data to socket. ">sl_SendTo</a> </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Belongs to send_api </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd></dd></dl>
<dl class="section user"><dt>Example</dt><dd></dd></dl>
<ul>
<li>Sending data: <div class="fragment"><div class="line">sockaddr_in  Addr;</div><div class="line"><span class="keywordtype">int</span> AddrSize = <span class="keyword">sizeof</span>(socklen_t);</div><div class="line"><span class="keywordtype">int</span> SockID;</div><div class="line"><span class="keywordtype">int</span> Status;</div><div class="line"><span class="keywordtype">char</span> Buf[SEND_BUF_LEN];</div><div class="line"></div><div class="line">Addr.sin_family = AF_INET;</div><div class="line">Addr.sin_port = htons(5001);</div><div class="line">Addr.sin_addr.s_addr = htonl(SL_IPV4_VAL(10,1,1,200));</div><div class="line"></div><div class="line">SockID = <a class="code" href="group___b_s_d___socket.html#ga3069f151a5fd4a29e3f0dafe7af43ea8">socket</a>(AF_INET, SOCK_STREAM, 0);</div><div class="line">Status = <a class="code" href="group___b_s_d___socket.html#ga8548b5734b7684ed0a0f4b684ed726c9">connect</a>(SockID, (sockaddr_in*)&amp;Addr, AddrSize);</div><div class="line">Status = <a class="code" href="group___b_s_d___socket.html#ga5292f928b7aca5f3c8b86e77a4a02b67">send</a>(SockID, Buf, 1460, 0 );</div></div><!-- fragment --> </li>
</ul>

<p>Definition at line <a class="el" href="socket_8c_source.html#l00108">108</a> of file <a class="el" href="socket_8c_source.html">socket.c</a>.</p>
<div class="fragment"><div class="line"><a name="l00109"></a><span class="lineno">  109</span>&#160;{</div><div class="line"><a name="l00110"></a><span class="lineno">  110</span>&#160;    ssize_t RetVal = (ssize_t)<a class="code" href="group___socket.html#ga2fc8c293bbcb796217076329e1bac518">sl_Send</a>(sd, pBuf, Len, flags);</div><div class="line"><a name="l00111"></a><span class="lineno">  111</span>&#160;    <span class="keywordflow">return</span> (ssize_t)(_SlDrvSetErrno(RetVal));</div><div class="line"><a name="l00112"></a><span class="lineno">  112</span>&#160;}</div><div class="ttc" id="group___socket_html_ga2fc8c293bbcb796217076329e1bac518"><div class="ttname"><a href="group___socket.html#ga2fc8c293bbcb796217076329e1bac518">sl_Send</a></div><div class="ttdeci">_i16 sl_Send(_i16 sd, const void *buf, _i16 len, _i16 flags)</div><div class="ttdoc">Write data to TCP socket. </div><div class="ttdef"><b>Definition:</b> <a href="sl__socket_8c_source.html#l00594">sl_socket.c:594</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="ga7c398c633b0f21a8ed43730d17030ba4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7c398c633b0f21a8ed43730d17030ba4">&sect;&nbsp;</a></span>sendto()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ssize_t sendto </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>sd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>pBuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>Len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sockaddr *&#160;</td>
          <td class="paramname"><em>to</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">socklen_t&#160;</td>
          <td class="paramname"><em>tolen</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write data to socket. </p>
<p>This function is used to transmit a message to another socket (connection less socket SOCK_DGRAM, SOCK_RAW).<br />
Returns immediately after sending data to device.<br />
In case of transmission failure an async event SL_SOCKET_TX_FAILED_EVENT is going to be received.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">sd</td><td>Socket handle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">buf</td><td>Points to a buffer containing the message to be sent </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">len</td><td>message size in bytes. Range: 1-1460 bytes </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">flags</td><td>Specifies the type of message transmission. On this version, this parameter is not supported </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">to</td><td>Pointer to an address structure indicating the destination address.<br />
 sockaddr:<br />
 - code for the address format. On this version only AF_INET is supported.<br />
 - socket address, the length depends on the code format </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">tolen</td><td>Destination address structure size</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Zero on success, or -1 on failure and sets errno to the corresponding BDS error code.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group___socket.html#ga2fc8c293bbcb796217076329e1bac518" title="Write data to TCP socket. ">sl_Send</a> </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Belongs to send_api </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd></dd></dl>
<dl class="section user"><dt>Example</dt><dd></dd></dl>
<ul>
<li>Sending data: <div class="fragment"><div class="line">sockaddr_in  Addr;</div><div class="line"><span class="keywordtype">int</span> AddrSize = <span class="keyword">sizeof</span>(socklen_t);</div><div class="line"><span class="keywordtype">int</span> SockID;</div><div class="line"><span class="keywordtype">int</span> Status;</div><div class="line"><span class="keywordtype">char</span> Buf[SEND_BUF_LEN];</div><div class="line"></div><div class="line">Addr.sin_family = AF_INET;</div><div class="line">Addr.sin_port = htons(5001);</div><div class="line">Addr.sin_addr.s_addr = htonl(SL_IPV4_VAL(10,1,1,200));</div><div class="line"></div><div class="line">SockID = <a class="code" href="group___b_s_d___socket.html#ga3069f151a5fd4a29e3f0dafe7af43ea8">socket</a>(AF_INET, SOCK_DGRAM, 0);</div><div class="line">Status = <a class="code" href="group___b_s_d___socket.html#ga7c398c633b0f21a8ed43730d17030ba4">sendto</a>(SockID, Buf, 1472, 0, (sockaddr_in *)&amp;Addr, AddrSize);</div></div><!-- fragment --> </li>
</ul>

<p>Definition at line <a class="el" href="socket_8c_source.html#l00075">75</a> of file <a class="el" href="socket_8c_source.html">socket.c</a>.</p>
<div class="fragment"><div class="line"><a name="l00076"></a><span class="lineno">   76</span>&#160;{</div><div class="line"><a name="l00077"></a><span class="lineno">   77</span>&#160;    ssize_t RetVal = (ssize_t)<a class="code" href="group___socket.html#ga7ca76d181974c71673c3bf3fc1fedfdc">sl_SendTo</a>(sd, pBuf, (_i16)Len, flags, to, tolen);</div><div class="line"><a name="l00078"></a><span class="lineno">   78</span>&#160;    <span class="keywordflow">return</span> (ssize_t)(_SlDrvSetErrno(RetVal));</div><div class="line"><a name="l00079"></a><span class="lineno">   79</span>&#160;}</div><div class="ttc" id="group___socket_html_ga7ca76d181974c71673c3bf3fc1fedfdc"><div class="ttname"><a href="group___socket.html#ga7ca76d181974c71673c3bf3fc1fedfdc">sl_SendTo</a></div><div class="ttdeci">_i16 sl_SendTo(_i16 sd, const void *buf, _i16 len, _i16 flags, const SlSockAddr_t *to, SlSocklen_t tolen)</div><div class="ttdoc">Write data to socket. </div><div class="ttdef"><b>Definition:</b> <a href="sl__socket_8c_source.html#l00288">sl_socket.c:288</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="gaafa5721213ca1bfb2c1ab1ea0f39bf5c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaafa5721213ca1bfb2c1ab1ea0f39bf5c">&sect;&nbsp;</a></span>setsockopt()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int setsockopt </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>sd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>optname</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>optval</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">socklen_t&#160;</td>
          <td class="paramname"><em>optlen</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set socket options-. </p>
<p>This function manipulate the options associated with a socket.<br />
Options may exist at multiple protocol levels; they are always present at the uppermost socket level.<br />
 When manipulating socket options the level at which the option resides and the name of the option must be specified. To manipulate options at the socket level, level is specified as SOL_SOCKET. To manipulate options at any other level the protocol number of the appropriate proto- col controlling the option is supplied. For example, to indicate that an option is to be interpreted by the TCP protocol, level should be set to the protocol number of TCP; <br />
 The parameters optval and optlen are used to access optval - ues for <a class="el" href="group___b_s_d___socket.html#gaafa5721213ca1bfb2c1ab1ea0f39bf5c" title="Set socket options-. ">setsockopt()</a>. For <a class="el" href="group___b_s_d___socket.html#ga37e0195dbaf69283dd8541c2ae631b82" title="Get socket options. ">getsockopt()</a> they identify a buffer in which the value for the requested option(s) are to be returned. For <a class="el" href="group___b_s_d___socket.html#ga37e0195dbaf69283dd8541c2ae631b82" title="Get socket options. ">getsockopt()</a>, optlen is a value-result parameter, initially containing the size of the buffer pointed to by option_value, and modified on return to indicate the actual size of the value returned. If no option value is to be supplied or returned, option_value may be NULL.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">sd</td><td>Socket handle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">level</td><td>Defines the protocol level for this option<ul>
<li><b>SOL_SOCKET</b> Socket level configurations (L4, transport layer)</li>
<li><b>IPPROTO_IP</b> IP level configurations (L3, network layer) </li>
</ul>
</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">optname</td><td>Defines the option name to interrogate<ul>
<li><b>SOL_SOCKET</b></li>
<li><b>SO_KEEPALIVE</b> <br />
 Enable/Disable periodic keep alive. Keeps TCP connections active by enabling the periodic transmission of messages <br />
 Timeout is 5 minutes.<br />
 Default: Enabled <br />
 This options takes <a class="el" href="group___socket.html#struct_sl_sock_keepalive__t">SlSockKeepalive_t</a> struct as parameter<ul>
<li><b>SO_KEEPALIVETIME</b> <br />
 Set keep alive timeout. Value is in seconds <br />
 Default: 5 minutes <br />
</li>
<li><b>SO_RX_NO_IP_BOUNDARY</b> <br />
 Enable/Disable rx ip boundary. In connectionless socket (udp/raw), unread data is dropped (when recvfrom len parameter &lt; data size), Enable this option in order to read the left data on the next recvfrom iteration Default: Disabled, IP boundary kept, <br />
 This options takes <a class="el" href="group___socket.html#struct_sl_sock_rx_no_ip_boundary__t">SlSockRxNoIpBoundary_t</a> struct as parameter</li>
<li><b>SO_RCVTIMEO</b> <br />
 Sets the timeout value that specifies the maximum amount of time an input function waits until it completes. <br />
 Default: No timeout <br />
 This options takes <a class="el" href="group___socket.html#struct_sl_timeval__t">SlTimeval_t</a> struct as parameter</li>
<li><b>SO_RCVBUF</b> <br />
 Sets tcp max recv window size. <br />
 This options takes <a class="el" href="group___socket.html#struct_sl_sock_winsize__t">SlSockWinsize_t</a> struct as parameter</li>
<li><b>SO_NONBLOCKING</b> <br />
 Sets socket to non-blocking operation Impacts: connect, accept, send, sendto, recv and recvfrom. <br />
 Default: Blocking. This options takes <a class="el" href="group___socket.html#struct_sl_sock_nonblocking__t">SlSockNonblocking_t</a> struct as parameter</li>
</ul>
</li>
<li><b>IPPROTO_IP</b><ul>
<li><b>IP_MULTICAST_TTL</b> <br />
 Set the time-to-live value of outgoing multicast packets for this socket. <br />
 This options takes <b>_u8</b> as parameter</li>
<li><b>IP_ADD_MEMBERSHIP</b> <br />
 UDP socket, Join a multicast group. <br />
 This options takes <a class="el" href="group___socket.html#struct_sl_sock_ip_mreq__t">SlSockIpMreq_t</a> struct as parameter</li>
<li><b>IP_DROP_MEMBERSHIP</b> <br />
 UDP socket, Leave a multicast group <br />
 This options takes <a class="el" href="group___socket.html#struct_sl_sock_ip_mreq__t">SlSockIpMreq_t</a> struct as parameter</li>
<li><b>SO_LINGER</b> <br />
 Socket lingers on close pending remaining send/receive packetst<br />
</li>
</ul>
</li>
</ul>
</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">optval</td><td>Specifies a value for the option </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">optlen</td><td>Specifies the length of the option value</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Zero on success, or -1 on failure and sets errno to the corresponding BDS error code.</dd></dl>
<dl class="section user"><dt>Persistent </dt><dd>All params are <b>Non- Persistent</b> </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group___b_s_d___socket.html#ga37e0195dbaf69283dd8541c2ae631b82" title="Get socket options. ">getsockopt</a> </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Belongs to basic_api </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd></dd></dl>

<p>Definition at line <a class="el" href="socket_8c_source.html#l00152">152</a> of file <a class="el" href="socket_8c_source.html">socket.c</a>.</p>
<div class="fragment"><div class="line"><a name="l00153"></a><span class="lineno">  153</span>&#160;{</div><div class="line"><a name="l00154"></a><span class="lineno">  154</span>&#160;    <span class="keywordflow">switch</span>(optname)</div><div class="line"><a name="l00155"></a><span class="lineno">  155</span>&#160;    {</div><div class="line"><a name="l00156"></a><span class="lineno">  156</span>&#160;        <span class="comment">/* This option (TCP_NODELAY) is always set by the NWP, setting it to true always success. */</span></div><div class="line"><a name="l00157"></a><span class="lineno">  157</span>&#160;        <span class="keywordflow">case</span> TCP_NODELAY:</div><div class="line"><a name="l00158"></a><span class="lineno">  158</span>&#160;            <span class="keywordflow">if</span>(optval)</div><div class="line"><a name="l00159"></a><span class="lineno">  159</span>&#160;            {</div><div class="line"><a name="l00160"></a><span class="lineno">  160</span>&#160;            <span class="comment">/* if user wish to have TCP_NODELAY = FALSE, we return EINVAL and failure, </span></div><div class="line"><a name="l00161"></a><span class="lineno">  161</span>&#160;<span class="comment">                in the cases below. */</span></div><div class="line"><a name="l00162"></a><span class="lineno">  162</span>&#160;                <span class="keywordflow">if</span>(*(_u32*)optval){ <span class="keywordflow">return</span> 0; }</div><div class="line"><a name="l00163"></a><span class="lineno">  163</span>&#160;            }</div><div class="line"><a name="l00164"></a><span class="lineno">  164</span>&#160;        <span class="comment">/* These sock opts Aren&#39;t supported by the cc31xx\cc32xx network stack, </span></div><div class="line"><a name="l00165"></a><span class="lineno">  165</span>&#160;<span class="comment">           hence, we silently ignore them and set errno to EINVAL (invalid argument).</span></div><div class="line"><a name="l00166"></a><span class="lineno">  166</span>&#160;<span class="comment">           This is made in order to not break of &quot;off-the-shelf&quot; BSD code. */</span></div><div class="line"><a name="l00167"></a><span class="lineno">  167</span>&#160;        <span class="keywordflow">case</span> SO_BROADCAST:</div><div class="line"><a name="l00168"></a><span class="lineno">  168</span>&#160;        <span class="keywordflow">case</span> SO_REUSEADDR:</div><div class="line"><a name="l00169"></a><span class="lineno">  169</span>&#160;        <span class="keywordflow">case</span> SO_SNDBUF:</div><div class="line"><a name="l00170"></a><span class="lineno">  170</span>&#160;            <span class="keywordflow">return</span> _SlDrvSetErrno(EINVAL);</div><div class="line"><a name="l00171"></a><span class="lineno">  171</span>&#160;        <span class="keywordflow">default</span>:</div><div class="line"><a name="l00172"></a><span class="lineno">  172</span>&#160;            <span class="keywordflow">break</span>;</div><div class="line"><a name="l00173"></a><span class="lineno">  173</span>&#160;    }</div><div class="line"><a name="l00174"></a><span class="lineno">  174</span>&#160;</div><div class="line"><a name="l00175"></a><span class="lineno">  175</span>&#160;    <span class="keywordtype">int</span> RetVal = (int)<a class="code" href="group___socket.html#ga6363ea2098e629c1a6e2bf80e731fb79">sl_SetSockOpt</a>(sd, level, optname, optval, optlen);</div><div class="line"><a name="l00176"></a><span class="lineno">  176</span>&#160;    <span class="keywordflow">return</span> _SlDrvSetErrno(RetVal);</div><div class="line"><a name="l00177"></a><span class="lineno">  177</span>&#160;}</div><div class="ttc" id="group___socket_html_ga6363ea2098e629c1a6e2bf80e731fb79"><div class="ttname"><a href="group___socket.html#ga6363ea2098e629c1a6e2bf80e731fb79">sl_SetSockOpt</a></div><div class="ttdeci">_i16 sl_SetSockOpt(_i16 sd, _i16 level, _i16 optname, const void *optval, SlSocklen_t optlen)</div><div class="ttdoc">Set socket options-. </div><div class="ttdef"><b>Definition:</b> <a href="sl__socket_8c_source.html#l00925">sl_socket.c:925</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="ga3069f151a5fd4a29e3f0dafe7af43ea8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3069f151a5fd4a29e3f0dafe7af43ea8">&sect;&nbsp;</a></span>socket()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int socket </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>Domain</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>Type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>Protocol</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create an endpoint for communication. </p>
<p>The socket function creates a new socket of a certain socket type, identified by an integer number, and allocates system resources to it.<br />
This function is called by the application layer to obtain a socket handle.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">Domain</td><td>Specifies the protocol family of the created socket. For example:<ul>
<li>AF_INET for network protocol IPv4</li>
<li>AF_INET6 for network protocol IPv6</li>
</ul>
</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Type</td><td>specifies the communication semantic, one of:<ul>
<li>SOCK_STREAM (reliable stream-oriented service or Stream Sockets)</li>
<li>SOCK_DGRAM (datagram service or Datagram Sockets)</li>
<li>SOCK_RAW (raw protocols atop the network layer)</li>
</ul>
</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Protocol</td><td>specifies a particular transport to be used with the socket. <br />
 The most common are<ul>
<li>IPPROTO_TCP</li>
<li>IPPROTO_UDP The value 0 may be used to select a default protocol from the selected domain and type</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>On success, socket handle that is used for consequent socket operations. <br />
 A successful return code should be a positive number (int16)<br />
 On error, a negative (int16) value will be returned specifying the error code.<ul>
<li>EAFNOSUPPORT - illegal domain parameter</li>
<li>EPROTOTYPE - illegal type parameter</li>
<li>EACCES - permission denied</li>
<li>ENSOCK - exceeded maximal number of socket</li>
<li>ENOMEM - memory allocation error</li>
<li>EINVAL - error in socket configuration</li>
<li>EPROTONOSUPPORT - illegal protocol parameter</li>
<li>EOPNOTSUPP - illegal combination of protocol and type parameters</li>
</ul>
</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group___b_s_d___socket.html#gad87d2a7392fe37239fe278ac4dad4da3" title="Gracefully close socket. ">close</a> </dd></dl>
<dl class="section note"><dt>Note</dt><dd>belongs to basic_api </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd></dd></dl>

<p>Definition at line <a class="el" href="socket_8c_source.html#l00051">51</a> of file <a class="el" href="socket_8c_source.html">socket.c</a>.</p>
<div class="fragment"><div class="line"><a name="l00052"></a><span class="lineno">   52</span>&#160;{</div><div class="line"><a name="l00053"></a><span class="lineno">   53</span>&#160;    <span class="keywordtype">int</span> RetVal = (int)<a class="code" href="group___socket.html#gaa775fcb6d09bf35b9dac3e5eb8e8c997">sl_Socket</a>(Domain, Type, Protocol);</div><div class="line"><a name="l00054"></a><span class="lineno">   54</span>&#160;    <span class="keywordflow">return</span> _SlDrvSetErrno(RetVal);</div><div class="line"><a name="l00055"></a><span class="lineno">   55</span>&#160;}</div><div class="ttc" id="group___socket_html_gaa775fcb6d09bf35b9dac3e5eb8e8c997"><div class="ttname"><a href="group___socket.html#gaa775fcb6d09bf35b9dac3e5eb8e8c997">sl_Socket</a></div><div class="ttdeci">_i16 sl_Socket(_i16 Domain, _i16 Type, _i16 Protocol)</div><div class="ttdoc">Create an endpoint for communication. </div><div class="ttdef"><b>Definition:</b> <a href="sl__socket_8c_source.html#l00137">sl_socket.c:137</a></div></div>
</div><!-- fragment -->
</div>
</div>
<hr/><h2 class="groupheader">Data Structure Documentation</h2>
<a name="structhostent" id="structhostent"></a>
<h2 class="memtitle"><span class="permalink"><a href="#structhostent">&sect;&nbsp;</a></span>hostent</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct hostent</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock">
<p>Definition at line <a class="el" href="netdb_8h_source.html#l00062">62</a> of file <a class="el" href="netdb_8h_source.html">netdb.h</a>.</p>
</div><table class="fieldtable">
<tr><th colspan="3">Data Fields</th></tr>
<tr><td class="fieldtype">
<a id="a058204dad180c9850b3ffaf6b32f5b4c"></a>char **</td>
<td class="fieldname">
h_addr_list</td>
<td class="fielddoc">
</td></tr>
<tr><td class="fieldtype">
<a id="a913b2bbf34d26ed76f7109a7a17bf4a3"></a>int</td>
<td class="fieldname">
h_addrtype</td>
<td class="fielddoc">
</td></tr>
<tr><td class="fieldtype">
<a id="ae14b193c012a3358601fa608b369ea16"></a>char **</td>
<td class="fieldname">
h_aliases</td>
<td class="fielddoc">
</td></tr>
<tr><td class="fieldtype">
<a id="aa5906b78ee4dffe8785c3d40de2e69f5"></a>int</td>
<td class="fieldname">
h_length</td>
<td class="fielddoc">
</td></tr>
<tr><td class="fieldtype">
<a id="a42431644cca2256f1058e3f5f4a5c5c4"></a>char *</td>
<td class="fieldname">
h_name</td>
<td class="fielddoc">
</td></tr>
</table>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.8.9.1-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.12 </li>
  </ul>
</div>
</body>
</html>
