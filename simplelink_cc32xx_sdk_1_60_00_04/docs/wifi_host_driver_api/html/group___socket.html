<!-- HTML header for doxygen 1.8.9.1-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.12"/>
<title>SimpleLink CC3120/CC3220 Host Driver: Socket</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="slgen.css" rel="stylesheet" type="text/css"/>
<link href="slnavtree.css" rel="stylesheet" type="text/css"/>
<link href="sltabs.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="4" cellpadding="4">
 <tbody>
 <tr>
  <td id="projectlogo"><img alt="Logo" src="ti_logo.png" height="50px" /></td>
  <td style="padding-left: 0.5em;">
   <div id="projectname">SimpleLink CC3120/CC3220 Host Driver
   &#160;<span id="projectnumber">Version&#160;2.0.1.26</span>
   </div>
   <div id="projectbrief">Simplifies the implementation of Internet connectivity</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.12 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('group___socket.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">Socket</div>  </div>
</div><!--header-->
<div class="contents">

<p>Controls standard client/server sockets programming options and capabilities.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gaa775fcb6d09bf35b9dac3e5eb8e8c997"><td class="memItemLeft" align="right" valign="top">_i16&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___socket.html#gaa775fcb6d09bf35b9dac3e5eb8e8c997">sl_Socket</a> (_i16 Domain, _i16 Type, _i16 Protocol)</td></tr>
<tr class="memdesc:gaa775fcb6d09bf35b9dac3e5eb8e8c997"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create an endpoint for communication.  <a href="#gaa775fcb6d09bf35b9dac3e5eb8e8c997">More...</a><br /></td></tr>
<tr class="separator:gaa775fcb6d09bf35b9dac3e5eb8e8c997"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacc7971a6e41592c8ef90936b25495a8b"><td class="memItemLeft" align="right" valign="top">_i16&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___socket.html#gacc7971a6e41592c8ef90936b25495a8b">sl_Close</a> (_i16 sd)</td></tr>
<tr class="memdesc:gacc7971a6e41592c8ef90936b25495a8b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gracefully close socket.  <a href="#gacc7971a6e41592c8ef90936b25495a8b">More...</a><br /></td></tr>
<tr class="separator:gacc7971a6e41592c8ef90936b25495a8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga72085bf8fae027f8fe31a0eb99a6808b"><td class="memItemLeft" align="right" valign="top">_i16&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___socket.html#ga72085bf8fae027f8fe31a0eb99a6808b">sl_Accept</a> (_i16 sd, <a class="el" href="group___socket.html#struct_sl_sock_addr__t">SlSockAddr_t</a> *addr, SlSocklen_t *addrlen)</td></tr>
<tr class="memdesc:ga72085bf8fae027f8fe31a0eb99a6808b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Accept a connection on a socket.  <a href="#ga72085bf8fae027f8fe31a0eb99a6808b">More...</a><br /></td></tr>
<tr class="separator:ga72085bf8fae027f8fe31a0eb99a6808b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadcb0c4792127dceb1feb3e9b87ab2094"><td class="memItemLeft" align="right" valign="top">_i16&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___socket.html#gadcb0c4792127dceb1feb3e9b87ab2094">sl_Bind</a> (_i16 sd, const <a class="el" href="group___socket.html#struct_sl_sock_addr__t">SlSockAddr_t</a> *addr, _i16 addrlen)</td></tr>
<tr class="memdesc:gadcb0c4792127dceb1feb3e9b87ab2094"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assign a name to a socket.  <a href="#gadcb0c4792127dceb1feb3e9b87ab2094">More...</a><br /></td></tr>
<tr class="separator:gadcb0c4792127dceb1feb3e9b87ab2094"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7d864d86f8dd7296774072db021a69e7"><td class="memItemLeft" align="right" valign="top">_i16&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___socket.html#ga7d864d86f8dd7296774072db021a69e7">sl_Listen</a> (_i16 sd, _i16 backlog)</td></tr>
<tr class="memdesc:ga7d864d86f8dd7296774072db021a69e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Listen for connections on a socket.  <a href="#ga7d864d86f8dd7296774072db021a69e7">More...</a><br /></td></tr>
<tr class="separator:ga7d864d86f8dd7296774072db021a69e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad8b9db85493e84b19994840f4cff0ca0"><td class="memItemLeft" align="right" valign="top">_i16&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___socket.html#gad8b9db85493e84b19994840f4cff0ca0">sl_Connect</a> (_i16 sd, const <a class="el" href="group___socket.html#struct_sl_sock_addr__t">SlSockAddr_t</a> *addr, _i16 addrlen)</td></tr>
<tr class="memdesc:gad8b9db85493e84b19994840f4cff0ca0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initiate a connection on a socket.  <a href="#gad8b9db85493e84b19994840f4cff0ca0">More...</a><br /></td></tr>
<tr class="separator:gad8b9db85493e84b19994840f4cff0ca0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga97747fea9f469feeb7272b76e4fe9a0e"><td class="memItemLeft" align="right" valign="top">_i16&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___socket.html#ga97747fea9f469feeb7272b76e4fe9a0e">sl_Select</a> (_i16 nfds, <a class="el" href="group___socket.html#struct_sl_fd_set__t">SlFdSet_t</a> *readsds, <a class="el" href="group___socket.html#struct_sl_fd_set__t">SlFdSet_t</a> *writesds, <a class="el" href="group___socket.html#struct_sl_fd_set__t">SlFdSet_t</a> *exceptsds, struct <a class="el" href="group___socket.html#struct_sl_timeval__t">SlTimeval_t</a> *timeout)</td></tr>
<tr class="memdesc:ga97747fea9f469feeb7272b76e4fe9a0e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Monitor socket activity.  <a href="#ga97747fea9f469feeb7272b76e4fe9a0e">More...</a><br /></td></tr>
<tr class="separator:ga97747fea9f469feeb7272b76e4fe9a0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6363ea2098e629c1a6e2bf80e731fb79"><td class="memItemLeft" align="right" valign="top">_i16&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___socket.html#ga6363ea2098e629c1a6e2bf80e731fb79">sl_SetSockOpt</a> (_i16 sd, _i16 level, _i16 optname, const void *optval, SlSocklen_t optlen)</td></tr>
<tr class="memdesc:ga6363ea2098e629c1a6e2bf80e731fb79"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set socket options-.  <a href="#ga6363ea2098e629c1a6e2bf80e731fb79">More...</a><br /></td></tr>
<tr class="separator:ga6363ea2098e629c1a6e2bf80e731fb79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga77d6029b0c39df5541b0b0d6484591b4"><td class="memItemLeft" align="right" valign="top">_i16&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___socket.html#ga77d6029b0c39df5541b0b0d6484591b4">sl_GetSockOpt</a> (_i16 sd, _i16 level, _i16 optname, void *optval, SlSocklen_t *optlen)</td></tr>
<tr class="memdesc:ga77d6029b0c39df5541b0b0d6484591b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get socket options.  <a href="#ga77d6029b0c39df5541b0b0d6484591b4">More...</a><br /></td></tr>
<tr class="separator:ga77d6029b0c39df5541b0b0d6484591b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga26a0eacfbab2629e7f3daa0ad0080255"><td class="memItemLeft" align="right" valign="top">_i16&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___socket.html#ga26a0eacfbab2629e7f3daa0ad0080255">sl_Recv</a> (_i16 sd, void *buf, _i16 len, _i16 flags)</td></tr>
<tr class="memdesc:ga26a0eacfbab2629e7f3daa0ad0080255"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read data from TCP socket.  <a href="#ga26a0eacfbab2629e7f3daa0ad0080255">More...</a><br /></td></tr>
<tr class="separator:ga26a0eacfbab2629e7f3daa0ad0080255"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga02f8b2eb34db39069a1385d4fce80eea"><td class="memItemLeft" align="right" valign="top">_i16&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___socket.html#ga02f8b2eb34db39069a1385d4fce80eea">sl_RecvFrom</a> (_i16 sd, void *buf, _i16 len, _i16 flags, <a class="el" href="group___socket.html#struct_sl_sock_addr__t">SlSockAddr_t</a> *from, SlSocklen_t *fromlen)</td></tr>
<tr class="memdesc:ga02f8b2eb34db39069a1385d4fce80eea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read data from socket.  <a href="#ga02f8b2eb34db39069a1385d4fce80eea">More...</a><br /></td></tr>
<tr class="separator:ga02f8b2eb34db39069a1385d4fce80eea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2fc8c293bbcb796217076329e1bac518"><td class="memItemLeft" align="right" valign="top">_i16&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___socket.html#ga2fc8c293bbcb796217076329e1bac518">sl_Send</a> (_i16 sd, const void *buf, _i16 len, _i16 flags)</td></tr>
<tr class="memdesc:ga2fc8c293bbcb796217076329e1bac518"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write data to TCP socket.  <a href="#ga2fc8c293bbcb796217076329e1bac518">More...</a><br /></td></tr>
<tr class="separator:ga2fc8c293bbcb796217076329e1bac518"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7ca76d181974c71673c3bf3fc1fedfdc"><td class="memItemLeft" align="right" valign="top">_i16&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___socket.html#ga7ca76d181974c71673c3bf3fc1fedfdc">sl_SendTo</a> (_i16 sd, const void *buf, _i16 len, _i16 flags, const <a class="el" href="group___socket.html#struct_sl_sock_addr__t">SlSockAddr_t</a> *to, SlSocklen_t tolen)</td></tr>
<tr class="memdesc:ga7ca76d181974c71673c3bf3fc1fedfdc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write data to socket.  <a href="#ga7ca76d181974c71673c3bf3fc1fedfdc">More...</a><br /></td></tr>
<tr class="separator:ga7ca76d181974c71673c3bf3fc1fedfdc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9275c1dadaba20e46381343800d0127b"><td class="memItemLeft" align="right" valign="top">_i16&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___socket.html#ga9275c1dadaba20e46381343800d0127b">sl_StartTLS</a> (_i16 sd)</td></tr>
<tr class="memdesc:ga9275c1dadaba20e46381343800d0127b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initiate TLS connection on a socket.  <a href="#ga9275c1dadaba20e46381343800d0127b">More...</a><br /></td></tr>
<tr class="separator:ga9275c1dadaba20e46381343800d0127b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga712c2a31c2844b54c33ede3a9a148d61"><td class="memItemLeft" align="right" valign="top">_u32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___socket.html#ga712c2a31c2844b54c33ede3a9a148d61">sl_Htonl</a> (_u32 val)</td></tr>
<tr class="memdesc:ga712c2a31c2844b54c33ede3a9a148d61"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reorder the bytes of a 32-bit unsigned value.  <a href="#ga712c2a31c2844b54c33ede3a9a148d61">More...</a><br /></td></tr>
<tr class="separator:ga712c2a31c2844b54c33ede3a9a148d61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadfb6f98e5c75a46050780e8afbae13bd"><td class="memItemLeft" align="right" valign="top">_u16&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___socket.html#gadfb6f98e5c75a46050780e8afbae13bd">sl_Htons</a> (_u16 val)</td></tr>
<tr class="memdesc:gadfb6f98e5c75a46050780e8afbae13bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reorder the bytes of a 16-bit unsigned value.  <a href="#gadfb6f98e5c75a46050780e8afbae13bd">More...</a><br /></td></tr>
<tr class="separator:gadfb6f98e5c75a46050780e8afbae13bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga727dd5a1c20faa5d718cb5a2724b0981"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___socket.html#ga727dd5a1c20faa5d718cb5a2724b0981">SlNetIfWifi_socket</a> (void *ifContext, int16_t Domain, int16_t Type, int16_t Protocol, void **sdContext)</td></tr>
<tr class="memdesc:ga727dd5a1c20faa5d718cb5a2724b0981"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create an endpoint for communication.  <a href="#ga727dd5a1c20faa5d718cb5a2724b0981">More...</a><br /></td></tr>
<tr class="separator:ga727dd5a1c20faa5d718cb5a2724b0981"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6fef019848f9a4f730b065237dbd875a"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___socket.html#ga6fef019848f9a4f730b065237dbd875a">SlNetIfWifi_close</a> (int16_t sd, void *sdContext)</td></tr>
<tr class="memdesc:ga6fef019848f9a4f730b065237dbd875a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gracefully close socket.  <a href="#ga6fef019848f9a4f730b065237dbd875a">More...</a><br /></td></tr>
<tr class="separator:ga6fef019848f9a4f730b065237dbd875a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafc0cdc3f19064c810f4d5f723384502d"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___socket.html#gafc0cdc3f19064c810f4d5f723384502d">SlNetIfWifi_accept</a> (int16_t sd, void *sdContext, SlNetSock_Addr_t *addr, SlNetSocklen_t *addrlen, uint8_t flags, void **acceptedSdContext)</td></tr>
<tr class="memdesc:gafc0cdc3f19064c810f4d5f723384502d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Accept a connection on a socket.  <a href="#gafc0cdc3f19064c810f4d5f723384502d">More...</a><br /></td></tr>
<tr class="separator:gafc0cdc3f19064c810f4d5f723384502d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad86c6b5d5ecb41afcafa1026b2bd542b"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___socket.html#gad86c6b5d5ecb41afcafa1026b2bd542b">SlNetIfWifi_bind</a> (int16_t sd, void *sdContext, const SlNetSock_Addr_t *addr, int16_t addrlen)</td></tr>
<tr class="memdesc:gad86c6b5d5ecb41afcafa1026b2bd542b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assign a name to a socket.  <a href="#gad86c6b5d5ecb41afcafa1026b2bd542b">More...</a><br /></td></tr>
<tr class="separator:gad86c6b5d5ecb41afcafa1026b2bd542b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga911c4ed3bb7039b3274ecd09f7df6e04"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___socket.html#ga911c4ed3bb7039b3274ecd09f7df6e04">SlNetIfWifi_listen</a> (int16_t sd, void *sdContext, int16_t backlog)</td></tr>
<tr class="memdesc:ga911c4ed3bb7039b3274ecd09f7df6e04"><td class="mdescLeft">&#160;</td><td class="mdescRight">Listen for connections on a socket.  <a href="#ga911c4ed3bb7039b3274ecd09f7df6e04">More...</a><br /></td></tr>
<tr class="separator:ga911c4ed3bb7039b3274ecd09f7df6e04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadfedf7a7ca8571caa534535169830980"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___socket.html#gadfedf7a7ca8571caa534535169830980">SlNetIfWifi_connect</a> (int16_t sd, void *sdContext, const SlNetSock_Addr_t *addr, SlNetSocklen_t addrlen, uint8_t flags)</td></tr>
<tr class="memdesc:gadfedf7a7ca8571caa534535169830980"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initiate a connection on a socket.  <a href="#gadfedf7a7ca8571caa534535169830980">More...</a><br /></td></tr>
<tr class="separator:gadfedf7a7ca8571caa534535169830980"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga591a5867e6f7a446a8f2cd66b612cfb3"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___socket.html#ga591a5867e6f7a446a8f2cd66b612cfb3">SlNetIfWifi_getSockName</a> (int16_t sd, void *sdContext, SlNetSock_Addr_t *addr, SlNetSocklen_t *addrlen)</td></tr>
<tr class="memdesc:ga591a5867e6f7a446a8f2cd66b612cfb3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get local address info by socket descriptor<br />
Returns the local address info of the socket descriptor.  <a href="#ga591a5867e6f7a446a8f2cd66b612cfb3">More...</a><br /></td></tr>
<tr class="separator:ga591a5867e6f7a446a8f2cd66b612cfb3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga599feb994650b8842573eebc9e65eaea"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___socket.html#ga599feb994650b8842573eebc9e65eaea">SlNetIfWifi_select</a> (void *ifContext, int16_t nfds, SlNetSock_SdSet_t *readsds, SlNetSock_SdSet_t *writesds, SlNetSock_SdSet_t *exceptsds, SlNetSock_Timeval_t *timeout)</td></tr>
<tr class="memdesc:ga599feb994650b8842573eebc9e65eaea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Monitor socket activity.  <a href="#ga599feb994650b8842573eebc9e65eaea">More...</a><br /></td></tr>
<tr class="separator:ga599feb994650b8842573eebc9e65eaea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa88290743d74f108aab46844aee496f8"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___socket.html#gaa88290743d74f108aab46844aee496f8">SlNetIfWifi_setSockOpt</a> (int16_t sd, void *sdContext, int16_t level, int16_t optname, void *optval, SlNetSocklen_t optlen)</td></tr>
<tr class="memdesc:gaa88290743d74f108aab46844aee496f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set socket options-.  <a href="#gaa88290743d74f108aab46844aee496f8">More...</a><br /></td></tr>
<tr class="separator:gaa88290743d74f108aab46844aee496f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9fc02898bc65c0a0c55de78355436682"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___socket.html#ga9fc02898bc65c0a0c55de78355436682">SlNetIfWifi_getSockOpt</a> (int16_t sd, void *sdContext, int16_t level, int16_t optname, void *optval, SlNetSocklen_t *optlen)</td></tr>
<tr class="memdesc:ga9fc02898bc65c0a0c55de78355436682"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get socket options.  <a href="#ga9fc02898bc65c0a0c55de78355436682">More...</a><br /></td></tr>
<tr class="separator:ga9fc02898bc65c0a0c55de78355436682"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabfa0d07de48de4a955bb39263e865adc"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___socket.html#gabfa0d07de48de4a955bb39263e865adc">SlNetIfWifi_recv</a> (int16_t sd, void *sdContext, void *buf, uint32_t len, uint32_t flags)</td></tr>
<tr class="memdesc:gabfa0d07de48de4a955bb39263e865adc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read data from TCP socket.  <a href="#gabfa0d07de48de4a955bb39263e865adc">More...</a><br /></td></tr>
<tr class="separator:gabfa0d07de48de4a955bb39263e865adc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafe9672d3c7813b7f414fb57421f92063"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___socket.html#gafe9672d3c7813b7f414fb57421f92063">SlNetIfWifi_recvFrom</a> (int16_t sd, void *sdContext, void *buf, uint32_t len, uint32_t flags, SlNetSock_Addr_t *from, SlNetSocklen_t *fromlen)</td></tr>
<tr class="memdesc:gafe9672d3c7813b7f414fb57421f92063"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read data from socket.  <a href="#gafe9672d3c7813b7f414fb57421f92063">More...</a><br /></td></tr>
<tr class="separator:gafe9672d3c7813b7f414fb57421f92063"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7c6f32b5a1821e1ee95d1c30453022d3"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___socket.html#ga7c6f32b5a1821e1ee95d1c30453022d3">SlNetIfWifi_send</a> (int16_t sd, void *sdContext, const void *buf, uint32_t len, uint32_t flags)</td></tr>
<tr class="memdesc:ga7c6f32b5a1821e1ee95d1c30453022d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write data to TCP socket.  <a href="#ga7c6f32b5a1821e1ee95d1c30453022d3">More...</a><br /></td></tr>
<tr class="separator:ga7c6f32b5a1821e1ee95d1c30453022d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga547e0e6febe3702cd5ba758c0d0b3d01"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___socket.html#ga547e0e6febe3702cd5ba758c0d0b3d01">SlNetIfWifi_sendTo</a> (int16_t sd, void *sdContext, const void *buf, uint32_t len, uint32_t flags, const SlNetSock_Addr_t *to, SlNetSocklen_t tolen)</td></tr>
<tr class="memdesc:ga547e0e6febe3702cd5ba758c0d0b3d01"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write data to socket.  <a href="#ga547e0e6febe3702cd5ba758c0d0b3d01">More...</a><br /></td></tr>
<tr class="separator:ga547e0e6febe3702cd5ba758c0d0b3d01"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacd8c0e81a019e8170d2d2b7ef571271a"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___socket.html#gacd8c0e81a019e8170d2d2b7ef571271a">SlNetIfWifi_sockstartSec</a> (int16_t sd, void *sdContext, SlNetSockSecAttrib_t *secAttrib, uint8_t flags)</td></tr>
<tr class="memdesc:gacd8c0e81a019e8170d2d2b7ef571271a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Start a security session on an opened socket.  <a href="#gacd8c0e81a019e8170d2d2b7ef571271a">More...</a><br /></td></tr>
<tr class="separator:gacd8c0e81a019e8170d2d2b7ef571271a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9e2ff1207f1a794d56c34dad84cb1f07"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___socket.html#ga9e2ff1207f1a794d56c34dad84cb1f07">SlNetIfWifi_getHostByName</a> (void *ifContext, char *name, const uint16_t nameLen, uint32_t *ipAddr, uint16_t *ipAddrLen, const uint8_t family)</td></tr>
<tr class="memdesc:ga9e2ff1207f1a794d56c34dad84cb1f07"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get host IP by name<br />
Obtain the IP Address of machine on network, by machine name.  <a href="#ga9e2ff1207f1a794d56c34dad84cb1f07">More...</a><br /></td></tr>
<tr class="separator:ga9e2ff1207f1a794d56c34dad84cb1f07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga837e7844a3cd20cf93fb955673b78cf7"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___socket.html#ga837e7844a3cd20cf93fb955673b78cf7">SlNetIfWifi_getIPAddr</a> (void *ifContext, SlNetIfAddressType_e addrType, uint16_t *addrConfig, uint32_t *ipAddr)</td></tr>
<tr class="memdesc:ga837e7844a3cd20cf93fb955673b78cf7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get IP Address of specific interface.  <a href="#ga837e7844a3cd20cf93fb955673b78cf7">More...</a><br /></td></tr>
<tr class="separator:ga837e7844a3cd20cf93fb955673b78cf7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae6fe2a9ee49eea4f1c3f177c92f5cb44"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___socket.html#gae6fe2a9ee49eea4f1c3f177c92f5cb44">SlNetIfWifi_getConnectionStatus</a> (void *ifContext)</td></tr>
<tr class="memdesc:gae6fe2a9ee49eea4f1c3f177c92f5cb44"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get interface connection status.  <a href="#gae6fe2a9ee49eea4f1c3f177c92f5cb44">More...</a><br /></td></tr>
<tr class="separator:gae6fe2a9ee49eea4f1c3f177c92f5cb44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf1220dc47c33ac6f39eee4e3d4be5343"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___socket.html#gaf1220dc47c33ac6f39eee4e3d4be5343">SlNetIfWifi_loadSecObj</a> (void *ifContext, uint16_t objType, char *objName, int16_t objNameLen, uint8_t *objBuff, int16_t objBuffLen)</td></tr>
<tr class="memdesc:gaf1220dc47c33ac6f39eee4e3d4be5343"><td class="mdescLeft">&#160;</td><td class="mdescRight">Load secured buffer to the network stack.  <a href="#gaf1220dc47c33ac6f39eee4e3d4be5343">More...</a><br /></td></tr>
<tr class="separator:gaf1220dc47c33ac6f39eee4e3d4be5343"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1f773f78ee46e8edc089397d9f013ff0"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___socket.html#ga1f773f78ee46e8edc089397d9f013ff0">SlNetIfWifi_CreateContext</a> (uint16_t ifID, const char *ifName, void **ifContext)</td></tr>
<tr class="memdesc:ga1f773f78ee46e8edc089397d9f013ff0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate and store interface data.  <a href="#ga1f773f78ee46e8edc089397d9f013ff0">More...</a><br /></td></tr>
<tr class="separator:ga1f773f78ee46e8edc089397d9f013ff0"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:gae3ff21af093d8fd5546f3acef3b78f09"><td class="memItemLeft" align="right" valign="top"><a id="gae3ff21af093d8fd5546f3acef3b78f09"></a>
typedef struct <a class="el" href="group___socket.html#struct_sl_in_addr__t">SlInAddr_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>SlInAddr_t</b></td></tr>
<tr class="separator:gae3ff21af093d8fd5546f3acef3b78f09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaedd8baedbdd7761c2031b6e021059d90"><td class="memItemLeft" align="right" valign="top"><a id="gaedd8baedbdd7761c2031b6e021059d90"></a>
typedef struct <a class="el" href="group___socket.html#struct_sl_in6_addr__t">SlIn6Addr_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>SlIn6Addr_t</b></td></tr>
<tr class="separator:gaedd8baedbdd7761c2031b6e021059d90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga93b3df36a64402df053e5cfac6d87a74"><td class="memItemLeft" align="right" valign="top"><a id="ga93b3df36a64402df053e5cfac6d87a74"></a>
typedef _i32&#160;</td><td class="memItemRight" valign="bottom"><b>SlTime_t</b></td></tr>
<tr class="separator:ga93b3df36a64402df053e5cfac6d87a74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac6d5291702d188bfa225b26e0f1af694"><td class="memItemLeft" align="right" valign="top"><a id="gac6d5291702d188bfa225b26e0f1af694"></a>
typedef _i32&#160;</td><td class="memItemRight" valign="bottom"><b>SlSuseconds_t</b></td></tr>
<tr class="separator:gac6d5291702d188bfa225b26e0f1af694"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4bf2360a18aa0cc9aa924ad4d14ace35"><td class="memItemLeft" align="right" valign="top"><a id="ga4bf2360a18aa0cc9aa924ad4d14ace35"></a>
typedef struct <a class="el" href="group___socket.html#struct_sl_timeval__t">SlTimeval_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>SlTimeval_t</b></td></tr>
<tr class="separator:ga4bf2360a18aa0cc9aa924ad4d14ace35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae854a687870d2f21bcb16914f53cde5f"><td class="memItemLeft" align="right" valign="top"><a id="gae854a687870d2f21bcb16914f53cde5f"></a>
typedef _u16&#160;</td><td class="memItemRight" valign="bottom"><b>SlSocklen_t</b></td></tr>
<tr class="separator:gae854a687870d2f21bcb16914f53cde5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5a7dcfebf54a6357d9091ddc926d1c29"><td class="memItemLeft" align="right" valign="top"><a id="ga5a7dcfebf54a6357d9091ddc926d1c29"></a>
typedef struct <a class="el" href="group___socket.html#struct_sl_sock_addr__t">SlSockAddr_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>SlSockAddr_t</b></td></tr>
<tr class="separator:ga5a7dcfebf54a6357d9091ddc926d1c29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1f45039fe18856959d6413f1427289ec"><td class="memItemLeft" align="right" valign="top"><a id="ga1f45039fe18856959d6413f1427289ec"></a>
typedef struct <a class="el" href="group___socket.html#struct_sl_sock_addr_in6__t">SlSockAddrIn6_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>SlSockAddrIn6_t</b></td></tr>
<tr class="separator:ga1f45039fe18856959d6413f1427289ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga63c21db5a666d0174059a273916b1ef3"><td class="memItemLeft" align="right" valign="top"><a id="ga63c21db5a666d0174059a273916b1ef3"></a>
typedef struct <a class="el" href="group___socket.html#struct_sl_sock_addr_in__t">SlSockAddrIn_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>SlSockAddrIn_t</b></td></tr>
<tr class="separator:ga63c21db5a666d0174059a273916b1ef3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga98ceac31d1e1ccea46183e40268966b3"><td class="memItemLeft" align="right" valign="top"><a id="ga98ceac31d1e1ccea46183e40268966b3"></a>
typedef struct <a class="el" href="group___socket.html#struct_sl_fd_set__t">SlFdSet_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>SlFdSet_t</b></td></tr>
<tr class="separator:ga98ceac31d1e1ccea46183e40268966b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:gae705bc6e7dea77561748924c1cde7fb6"><td class="memItemLeft" align="right" valign="top"><a id="gae705bc6e7dea77561748924c1cde7fb6"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><b>SlTxInhibitThreshold_e</b> { <br />
&#160;&#160;<b>SL_TX_INHIBIT_THRESHOLD_MIN</b> = 1, 
<br />
&#160;&#160;<b>SL_TX_INHIBIT_THRESHOLD_LOW</b> = 2, 
<br />
&#160;&#160;<b>SL_TX_INHIBIT_THRESHOLD_DEFAULT</b> = 3, 
<br />
&#160;&#160;<b>SL_TX_INHIBIT_THRESHOLD_MED</b> = 4, 
<br />
&#160;&#160;<b>SL_TX_INHIBIT_THRESHOLD_HIGH</b> = 5, 
<br />
&#160;&#160;<b>SL_TX_INHIBIT_THRESHOLD_MAX</b> = 6
<br />
 }</td></tr>
<tr class="separator:gae705bc6e7dea77561748924c1cde7fb6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad2ea486bb12f6906685e61e64d10766e"><td class="memItemLeft" align="right" valign="top"><a id="gad2ea486bb12f6906685e61e64d10766e"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><b>SlSockSecureSocketFilesIndex_e</b> { <br />
&#160;&#160;<b>SL_BSD_SECURED_PRIVATE_KEY_IDX</b> = 0, 
<br />
&#160;&#160;<b>SL_BSD_SECURED_CERTIFICATE_IDX</b>, 
<br />
&#160;&#160;<b>SL_BSD_SECURED_CA_IDX</b>, 
<br />
&#160;&#160;<b>SL_BSD_SECURED_DH_IDX</b>
<br />
 }</td></tr>
<tr class="separator:gad2ea486bb12f6906685e61e64d10766e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:ga76088f0c7d79c2131c41fa0777fc43ed"><td class="memItemLeft" align="right" valign="top">SlNetIf_Config_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___socket.html#ga76088f0c7d79c2131c41fa0777fc43ed">SlNetIfConfigWifi</a></td></tr>
<tr class="separator:ga76088f0c7d79c2131c41fa0777fc43ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>Controls standard client/server sockets programming options and capabilities. </p>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga72085bf8fae027f8fe31a0eb99a6808b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga72085bf8fae027f8fe31a0eb99a6808b">&sect;&nbsp;</a></span>sl_Accept()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">_i16 sl_Accept </td>
          <td>(</td>
          <td class="paramtype">_i16&#160;</td>
          <td class="paramname"><em>sd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___socket.html#struct_sl_sock_addr__t">SlSockAddr_t</a> *&#160;</td>
          <td class="paramname"><em>addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SlSocklen_t *&#160;</td>
          <td class="paramname"><em>addrlen</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Accept a connection on a socket. </p>
<p>This function is used with connection-based socket types (SOCK_STREAM).<br />
It extracts the first connection request on the queue of pending connections, creates a new connected socket, and returns a new file descriptor referring to that socket.<br />
The newly created socket is not in the listening state. The original socket sd is unaffected by this call. <br />
The argument sd is a socket that has been created with <a class="el" href="group___socket.html#gaa775fcb6d09bf35b9dac3e5eb8e8c997" title="Create an endpoint for communication. ">sl_Socket()</a>, bound to a local address with <a class="el" href="group___socket.html#gadcb0c4792127dceb1feb3e9b87ab2094" title="Assign a name to a socket. ">sl_Bind()</a>, and is listening for connections after a <a class="el" href="group___socket.html#ga7d864d86f8dd7296774072db021a69e7" title="Listen for connections on a socket. ">sl_Listen()</a>. The argument <b><em>addr</em> is</b> a pointer to a sockaddr structure. This structure is filled in with the address of the peer socket, as known to the communications layer. The exact format of the address returned addr is determined by the socket's address family. <br />
The <b><em>addrlen</em> argument</b> is a value-result argument: it should initially contain the size of the structure pointed to by addr, on return it will contain the actual length (in bytes) of the address returned.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">sd</td><td>Socket descriptor (handle) </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">addr</td><td>The argument addr is a pointer to a sockaddr structure. This structure is filled in with the address of the peer socket, as known to the communications layer. The exact format of the address returned addr is determined by the socket's address<br />
 sockaddr:<br />
 - code for the address format. On this version only AF_INET is supported.<br />
 - socket address, the length depends on the code format </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">addrlen</td><td>The addrlen argument is a value-result argument: it should initially contain the size of the structure pointed to by addr</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>On success, a socket handle.<br />
 On a non-blocking accept a possible negative value is SL_EAGAIN.<br />
 On failure, negative error code.<br />
 SL_POOL_IS_EMPTY may be return in case there are no resources in the system In this case try again later or increase MAX_CONCURRENT_ACTIONS</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group___socket.html#gaa775fcb6d09bf35b9dac3e5eb8e8c997" title="Create an endpoint for communication. ">sl_Socket</a> <a class="el" href="group___socket.html#gadcb0c4792127dceb1feb3e9b87ab2094" title="Assign a name to a socket. ">sl_Bind</a> <a class="el" href="group___socket.html#ga7d864d86f8dd7296774072db021a69e7" title="Listen for connections on a socket. ">sl_Listen</a> </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Belongs to server_side </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd></dd></dl>

<p>Definition at line <a class="el" href="sl__socket_8c_source.html#l00692">692</a> of file <a class="el" href="sl__socket_8c_source.html">sl_socket.c</a>.</p>
<div class="fragment"><div class="line"><a name="l00693"></a><span class="lineno">  693</span>&#160;{</div><div class="line"><a name="l00694"></a><span class="lineno">  694</span>&#160;    _SlSockAcceptMsg_u       Msg;</div><div class="line"><a name="l00695"></a><span class="lineno">  695</span>&#160;    _SlReturnVal_t           RetVal;</div><div class="line"><a name="l00696"></a><span class="lineno">  696</span>&#160;    <a class="code" href="union_sl_socket_addr_response__u.html">SlSocketAddrResponse_u</a>   AsyncRsp;</div><div class="line"><a name="l00697"></a><span class="lineno">  697</span>&#160;</div><div class="line"><a name="l00698"></a><span class="lineno">  698</span>&#160;    _u8 ObjIdx = MAX_CONCURRENT_ACTIONS;</div><div class="line"><a name="l00699"></a><span class="lineno">  699</span>&#160;</div><div class="line"><a name="l00700"></a><span class="lineno">  700</span>&#160;    <span class="comment">/* verify that this api is allowed. if not allowed then</span></div><div class="line"><a name="l00701"></a><span class="lineno">  701</span>&#160;<span class="comment">    ignore the API execution and return immediately with an error */</span></div><div class="line"><a name="l00702"></a><span class="lineno">  702</span>&#160;    VERIFY_API_ALLOWED(SL_OPCODE_SILO_SOCKET);</div><div class="line"><a name="l00703"></a><span class="lineno">  703</span>&#160;</div><div class="line"><a name="l00704"></a><span class="lineno">  704</span>&#160;    Msg.Cmd.Sd = (_u8)sd;</div><div class="line"><a name="l00705"></a><span class="lineno">  705</span>&#160;</div><div class="line"><a name="l00706"></a><span class="lineno">  706</span>&#160;    <span class="keywordflow">if</span>((addr != NULL) &amp;&amp; (addrlen != NULL))</div><div class="line"><a name="l00707"></a><span class="lineno">  707</span>&#160;    {</div><div class="line"><a name="l00708"></a><span class="lineno">  708</span>&#160;        <span class="comment">/* If addr is present, addrlen has to be provided */</span></div><div class="line"><a name="l00709"></a><span class="lineno">  709</span>&#160;        Msg.Cmd.Family = (_u8)((<span class="keyword">sizeof</span>(<a class="code" href="group___socket.html#struct_sl_sock_addr_in__t">SlSockAddrIn_t</a>) == *addrlen) ? SL_AF_INET : SL_AF_INET6);</div><div class="line"><a name="l00710"></a><span class="lineno">  710</span>&#160;    }</div><div class="line"><a name="l00711"></a><span class="lineno">  711</span>&#160;    <span class="keywordflow">else</span></div><div class="line"><a name="l00712"></a><span class="lineno">  712</span>&#160;    {</div><div class="line"><a name="l00713"></a><span class="lineno">  713</span>&#160;        <span class="comment">/* In any other case, addrlen is ignored */</span></div><div class="line"><a name="l00714"></a><span class="lineno">  714</span>&#160;        Msg.Cmd.Family = (_u8)0;</div><div class="line"><a name="l00715"></a><span class="lineno">  715</span>&#160;    }</div><div class="line"><a name="l00716"></a><span class="lineno">  716</span>&#160;</div><div class="line"><a name="l00717"></a><span class="lineno">  717</span>&#160;    ObjIdx = _SlDrvProtectAsyncRespSetting((_u8*)&amp;AsyncRsp, ACCEPT_ID, (_u8)sd  &amp; SL_BSD_SOCKET_ID_MASK);</div><div class="line"><a name="l00718"></a><span class="lineno">  718</span>&#160;</div><div class="line"><a name="l00719"></a><span class="lineno">  719</span>&#160;    <span class="keywordflow">if</span> (MAX_CONCURRENT_ACTIONS == ObjIdx)</div><div class="line"><a name="l00720"></a><span class="lineno">  720</span>&#160;    {</div><div class="line"><a name="l00721"></a><span class="lineno">  721</span>&#160;        <span class="keywordflow">return</span> SL_POOL_IS_EMPTY;</div><div class="line"><a name="l00722"></a><span class="lineno">  722</span>&#160;    }</div><div class="line"><a name="l00723"></a><span class="lineno">  723</span>&#160;    </div><div class="line"><a name="l00724"></a><span class="lineno">  724</span>&#160;    <span class="comment">/* send the command */</span></div><div class="line"><a name="l00725"></a><span class="lineno">  725</span>&#160;    VERIFY_RET_OK(_SlDrvCmdOp((<a class="code" href="struct___sl_cmd_ctrl__t.html">_SlCmdCtrl_t</a> *)&amp;_SlAcceptCmdCtrl, &amp;Msg, NULL));</div><div class="line"><a name="l00726"></a><span class="lineno">  726</span>&#160;    VERIFY_PROTOCOL(Msg.Rsp.Sd == (_u8)sd);</div><div class="line"><a name="l00727"></a><span class="lineno">  727</span>&#160;</div><div class="line"><a name="l00728"></a><span class="lineno">  728</span>&#160;    RetVal = Msg.Rsp.StatusOrLen;</div><div class="line"><a name="l00729"></a><span class="lineno">  729</span>&#160;</div><div class="line"><a name="l00730"></a><span class="lineno">  730</span>&#160;    <span class="keywordflow">if</span>(SL_OS_RET_CODE_OK == RetVal)</div><div class="line"><a name="l00731"></a><span class="lineno">  731</span>&#160;    {</div><div class="line"><a name="l00732"></a><span class="lineno">  732</span>&#160;<span class="preprocessor">#ifndef SL_TINY    </span></div><div class="line"><a name="l00733"></a><span class="lineno">  733</span>&#160;        <span class="comment">/* in case socket is non-blocking one, the async event should be received immediately */</span></div><div class="line"><a name="l00734"></a><span class="lineno">  734</span>&#160;        <span class="keywordflow">if</span>( g_pCB-&gt;SocketNonBlocking &amp; (1&lt;&lt;(sd &amp; SL_BSD_SOCKET_ID_MASK) ))</div><div class="line"><a name="l00735"></a><span class="lineno">  735</span>&#160;        {</div><div class="line"><a name="l00736"></a><span class="lineno">  736</span>&#160;            SL_DRV_SYNC_OBJ_WAIT_TIMEOUT(&amp;g_pCB-&gt;ObjPool[ObjIdx].SyncObj,</div><div class="line"><a name="l00737"></a><span class="lineno">  737</span>&#160;                                         SL_DRIVER_TIMEOUT_SHORT,</div><div class="line"><a name="l00738"></a><span class="lineno">  738</span>&#160;                                         SL_OPCODE_SOCKET_ACCEPTASYNCRESPONSE</div><div class="line"><a name="l00739"></a><span class="lineno">  739</span>&#160;                                         );</div><div class="line"><a name="l00740"></a><span class="lineno">  740</span>&#160;        }</div><div class="line"><a name="l00741"></a><span class="lineno">  741</span>&#160;        <span class="keywordflow">else</span></div><div class="line"><a name="l00742"></a><span class="lineno">  742</span>&#160;<span class="preprocessor">#endif         </span></div><div class="line"><a name="l00743"></a><span class="lineno">  743</span>&#160;        {</div><div class="line"><a name="l00744"></a><span class="lineno">  744</span>&#160;            <span class="comment">/* wait for async and get Data Read parameters */</span></div><div class="line"><a name="l00745"></a><span class="lineno">  745</span>&#160;            SL_DRV_SYNC_OBJ_WAIT_FOREVER(&amp;g_pCB-&gt;ObjPool[ObjIdx].SyncObj);</div><div class="line"><a name="l00746"></a><span class="lineno">  746</span>&#160;        }</div><div class="line"><a name="l00747"></a><span class="lineno">  747</span>&#160;</div><div class="line"><a name="l00748"></a><span class="lineno">  748</span>&#160;        VERIFY_PROTOCOL(AsyncRsp.IpV4.Sd == (_u8)sd);</div><div class="line"><a name="l00749"></a><span class="lineno">  749</span>&#160;</div><div class="line"><a name="l00750"></a><span class="lineno">  750</span>&#160;        RetVal = AsyncRsp.IpV4.StatusOrLen;</div><div class="line"><a name="l00751"></a><span class="lineno">  751</span>&#160;<span class="preprocessor">#if 0 </span><span class="comment">/*  Kept for backup */</span><span class="preprocessor"></span></div><div class="line"><a name="l00752"></a><span class="lineno">  752</span>&#160;        _SlSocketParseAddress(&amp;AsyncRsp, addr, addrlen);</div><div class="line"><a name="l00753"></a><span class="lineno">  753</span>&#160;<span class="preprocessor">#else</span></div><div class="line"><a name="l00754"></a><span class="lineno">  754</span>&#160;        <span class="keywordflow">if</span>((addr != NULL) &amp;&amp; (addrlen != NULL))</div><div class="line"><a name="l00755"></a><span class="lineno">  755</span>&#160;        {</div><div class="line"><a name="l00756"></a><span class="lineno">  756</span>&#160;            addr-&gt;sa_family = AsyncRsp.IpV4.Family;</div><div class="line"><a name="l00757"></a><span class="lineno">  757</span>&#160;</div><div class="line"><a name="l00758"></a><span class="lineno">  758</span>&#160;            <span class="keywordflow">if</span>(SL_AF_INET == addr-&gt;sa_family)</div><div class="line"><a name="l00759"></a><span class="lineno">  759</span>&#160;            {</div><div class="line"><a name="l00760"></a><span class="lineno">  760</span>&#160;                <span class="keywordflow">if</span>( *addrlen == (SlSocklen_t)<span class="keyword">sizeof</span>( <a class="code" href="group___socket.html#struct_sl_sock_addr_in__t">SlSockAddrIn_t</a> ) )</div><div class="line"><a name="l00761"></a><span class="lineno">  761</span>&#160;                {</div><div class="line"><a name="l00762"></a><span class="lineno">  762</span>&#160;                    ((<a class="code" href="group___socket.html#struct_sl_sock_addr_in__t">SlSockAddrIn_t</a> *)addr)-&gt;sin_port         = AsyncRsp.IpV4.Port;</div><div class="line"><a name="l00763"></a><span class="lineno">  763</span>&#160;                    ((<a class="code" href="group___socket.html#struct_sl_sock_addr_in__t">SlSockAddrIn_t</a> *)addr)-&gt;sin_addr.s_addr  = AsyncRsp.IpV4.Address;</div><div class="line"><a name="l00764"></a><span class="lineno">  764</span>&#160;                }</div><div class="line"><a name="l00765"></a><span class="lineno">  765</span>&#160;                <span class="keywordflow">else</span></div><div class="line"><a name="l00766"></a><span class="lineno">  766</span>&#160;                {</div><div class="line"><a name="l00767"></a><span class="lineno">  767</span>&#160;                    *addrlen = 0;</div><div class="line"><a name="l00768"></a><span class="lineno">  768</span>&#160;                }</div><div class="line"><a name="l00769"></a><span class="lineno">  769</span>&#160;            }</div><div class="line"><a name="l00770"></a><span class="lineno">  770</span>&#160;<span class="preprocessor">#ifdef SL_SUPPORT_IPV6</span></div><div class="line"><a name="l00771"></a><span class="lineno">  771</span>&#160;            <span class="keywordflow">else</span> <span class="keywordflow">if</span>(SL_AF_INET6 == addr-&gt;sa_family)</div><div class="line"><a name="l00772"></a><span class="lineno">  772</span>&#160;            {</div><div class="line"><a name="l00773"></a><span class="lineno">  773</span>&#160;                <span class="keywordflow">if</span>( *addrlen == <span class="keyword">sizeof</span>( <a class="code" href="group___socket.html#struct_sl_sock_addr_in6__t">SlSockAddrIn6_t</a> ) )</div><div class="line"><a name="l00774"></a><span class="lineno">  774</span>&#160;                {</div><div class="line"><a name="l00775"></a><span class="lineno">  775</span>&#160;                    ((<a class="code" href="group___socket.html#struct_sl_sock_addr_in6__t">SlSockAddrIn6_t</a> *)addr)-&gt;sin6_port                   = AsyncRsp.IpV6.Port    ;</div><div class="line"><a name="l00776"></a><span class="lineno">  776</span>&#160;                    sl_Memcpy(((<a class="code" href="group___socket.html#struct_sl_sock_addr_in6__t">SlSockAddrIn6_t</a> *)addr)-&gt;sin6_addr._S6_un._S6_u32, AsyncRsp.IpV6.Address, 16);</div><div class="line"><a name="l00777"></a><span class="lineno">  777</span>&#160;                }</div><div class="line"><a name="l00778"></a><span class="lineno">  778</span>&#160;                <span class="keywordflow">else</span></div><div class="line"><a name="l00779"></a><span class="lineno">  779</span>&#160;                {</div><div class="line"><a name="l00780"></a><span class="lineno">  780</span>&#160;                    *addrlen = 0;</div><div class="line"><a name="l00781"></a><span class="lineno">  781</span>&#160;                }</div><div class="line"><a name="l00782"></a><span class="lineno">  782</span>&#160;            }</div><div class="line"><a name="l00783"></a><span class="lineno">  783</span>&#160;<span class="preprocessor">#endif</span></div><div class="line"><a name="l00784"></a><span class="lineno">  784</span>&#160;        }</div><div class="line"><a name="l00785"></a><span class="lineno">  785</span>&#160;<span class="preprocessor">#endif</span></div><div class="line"><a name="l00786"></a><span class="lineno">  786</span>&#160;    }</div><div class="line"><a name="l00787"></a><span class="lineno">  787</span>&#160;</div><div class="line"><a name="l00788"></a><span class="lineno">  788</span>&#160;    _SlDrvReleasePoolObj(ObjIdx);</div><div class="line"><a name="l00789"></a><span class="lineno">  789</span>&#160;    <span class="keywordflow">return</span> (_i16)RetVal;</div><div class="line"><a name="l00790"></a><span class="lineno">  790</span>&#160;}</div><div class="ttc" id="group___socket_html_struct_sl_sock_addr_in6__t"><div class="ttname"><a href="group___socket.html#struct_sl_sock_addr_in6__t">SlSockAddrIn6_t</a></div><div class="ttdef"><b>Definition:</b> <a href="sl__socket_8h_source.html#l00393">sl_socket.h:393</a></div></div>
<div class="ttc" id="struct___sl_cmd_ctrl__t_html"><div class="ttname"><a href="struct___sl_cmd_ctrl__t.html">_SlCmdCtrl_t</a></div><div class="ttdef"><b>Definition:</b> <a href="driver_8h_source.html#l00179">driver.h:179</a></div></div>
<div class="ttc" id="union_sl_socket_addr_response__u_html"><div class="ttname"><a href="union_sl_socket_addr_response__u.html">SlSocketAddrResponse_u</a></div><div class="ttdef"><b>Definition:</b> <a href="protocol_8h_source.html#l00810">protocol.h:810</a></div></div>
<div class="ttc" id="group___socket_html_struct_sl_sock_addr_in__t"><div class="ttname"><a href="group___socket.html#struct_sl_sock_addr_in__t">SlSockAddrIn_t</a></div><div class="ttdef"><b>Definition:</b> <a href="sl__socket_8h_source.html#l00404">sl_socket.h:404</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="gadcb0c4792127dceb1feb3e9b87ab2094"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadcb0c4792127dceb1feb3e9b87ab2094">&sect;&nbsp;</a></span>sl_Bind()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">_i16 sl_Bind </td>
          <td>(</td>
          <td class="paramtype">_i16&#160;</td>
          <td class="paramname"><em>sd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group___socket.html#struct_sl_sock_addr__t">SlSockAddr_t</a> *&#160;</td>
          <td class="paramname"><em>addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_i16&#160;</td>
          <td class="paramname"><em>addrlen</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Assign a name to a socket. </p>
<p>This function gives the socket the local address addr. addr is addrlen bytes long. Traditionally, this is called When a socket is created with socket, it exists in a name space (address family) but has no name assigned. It is necessary to assign a local address before a SOCK_STREAM socket may receive connections.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">sd</td><td>Socket descriptor (handle) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">addr</td><td>Specifies the destination addrs<br />
 sockaddr:<br />
 - code for the address format. On this version only SL_AF_INET is supported.<br />
 - socket address, the length depends on the code format </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">addrlen</td><td>Contains the size of the structure pointed to by addr</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Zero on success, or negative error code on failure</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group___socket.html#gaa775fcb6d09bf35b9dac3e5eb8e8c997" title="Create an endpoint for communication. ">sl_Socket</a> <a class="el" href="group___socket.html#ga72085bf8fae027f8fe31a0eb99a6808b" title="Accept a connection on a socket. ">sl_Accept</a> <a class="el" href="group___socket.html#ga7d864d86f8dd7296774072db021a69e7" title="Listen for connections on a socket. ">sl_Listen</a> </dd></dl>
<dl class="section note"><dt>Note</dt><dd>belongs to basic_api </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd></dd></dl>

<p>Definition at line <a class="el" href="sl__socket_8c_source.html#l00240">240</a> of file <a class="el" href="sl__socket_8c_source.html">sl_socket.c</a>.</p>
<div class="fragment"><div class="line"><a name="l00241"></a><span class="lineno">  241</span>&#160;{</div><div class="line"><a name="l00242"></a><span class="lineno">  242</span>&#160;    _SlSockBindMsg_u    Msg;</div><div class="line"><a name="l00243"></a><span class="lineno">  243</span>&#160;    <a class="code" href="struct___sl_cmd_ctrl__t.html">_SlCmdCtrl_t</a>        CmdCtrl = {0, 0, (_SlArgSize_t)<span class="keyword">sizeof</span>(<a class="code" href="struct_sl_socket_response__t.html">SlSocketResponse_t</a>)};</div><div class="line"><a name="l00244"></a><span class="lineno">  244</span>&#160;</div><div class="line"><a name="l00245"></a><span class="lineno">  245</span>&#160;    <span class="comment">/* verify that this api is allowed. if not allowed then</span></div><div class="line"><a name="l00246"></a><span class="lineno">  246</span>&#160;<span class="comment">    ignore the API execution and return immediately with an error */</span></div><div class="line"><a name="l00247"></a><span class="lineno">  247</span>&#160;    VERIFY_API_ALLOWED(SL_OPCODE_SILO_SOCKET);</div><div class="line"><a name="l00248"></a><span class="lineno">  248</span>&#160;</div><div class="line"><a name="l00249"></a><span class="lineno">  249</span>&#160;    <span class="keywordflow">switch</span>(addr-&gt;sa_family)</div><div class="line"><a name="l00250"></a><span class="lineno">  250</span>&#160;    {</div><div class="line"><a name="l00251"></a><span class="lineno">  251</span>&#160;        <span class="keywordflow">case</span> SL_AF_INET:</div><div class="line"><a name="l00252"></a><span class="lineno">  252</span>&#160;            CmdCtrl.Opcode = SL_OPCODE_SOCKET_BIND;</div><div class="line"><a name="l00253"></a><span class="lineno">  253</span>&#160;            CmdCtrl.TxDescLen = (_SlArgSize_t)<span class="keyword">sizeof</span>(<a class="code" href="struct_sl_socket_addr_i_pv4_command__t.html">SlSocketAddrIPv4Command_t</a>);</div><div class="line"><a name="l00254"></a><span class="lineno">  254</span>&#160;            <span class="keywordflow">break</span>;</div><div class="line"><a name="l00255"></a><span class="lineno">  255</span>&#160;<span class="preprocessor">#ifndef SL_TINY</span></div><div class="line"><a name="l00256"></a><span class="lineno">  256</span>&#160;<span class="preprocessor">#ifdef SL_SUPPORT_IPV6</span></div><div class="line"><a name="l00257"></a><span class="lineno">  257</span>&#160;        <span class="keywordflow">case</span> SL_AF_INET6:</div><div class="line"><a name="l00258"></a><span class="lineno">  258</span>&#160;            CmdCtrl.Opcode = SL_OPCODE_SOCKET_BIND_V6;</div><div class="line"><a name="l00259"></a><span class="lineno">  259</span>&#160;            CmdCtrl.TxDescLen = (_SlArgSize_t)<span class="keyword">sizeof</span>(<a class="code" href="struct_sl_socket_addr_i_pv6_command__t.html">SlSocketAddrIPv6Command_t</a>);</div><div class="line"><a name="l00260"></a><span class="lineno">  260</span>&#160;            <span class="keywordflow">break</span>;</div><div class="line"><a name="l00261"></a><span class="lineno">  261</span>&#160;<span class="preprocessor">#endif</span></div><div class="line"><a name="l00262"></a><span class="lineno">  262</span>&#160;<span class="preprocessor">#endif</span></div><div class="line"><a name="l00263"></a><span class="lineno">  263</span>&#160;        <span class="keywordflow">case</span> SL_AF_RF:</div><div class="line"><a name="l00264"></a><span class="lineno">  264</span>&#160;        <span class="keywordflow">default</span>:</div><div class="line"><a name="l00265"></a><span class="lineno">  265</span>&#160;            <span class="keywordflow">return</span> SL_RET_CODE_INVALID_INPUT;</div><div class="line"><a name="l00266"></a><span class="lineno">  266</span>&#160;    }</div><div class="line"><a name="l00267"></a><span class="lineno">  267</span>&#160;</div><div class="line"><a name="l00268"></a><span class="lineno">  268</span>&#160;    Msg.Cmd.IpV4.LenOrPadding = 0;</div><div class="line"><a name="l00269"></a><span class="lineno">  269</span>&#160;    Msg.Cmd.IpV4.Sd = (_u8)sd;</div><div class="line"><a name="l00270"></a><span class="lineno">  270</span>&#160;</div><div class="line"><a name="l00271"></a><span class="lineno">  271</span>&#160;    _SlSocketBuildAddress(addr, &amp;Msg.Cmd);</div><div class="line"><a name="l00272"></a><span class="lineno">  272</span>&#160;    VERIFY_RET_OK(_SlDrvCmdOp((<a class="code" href="struct___sl_cmd_ctrl__t.html">_SlCmdCtrl_t</a> *)&amp;CmdCtrl, &amp;Msg, NULL));</div><div class="line"><a name="l00273"></a><span class="lineno">  273</span>&#160;</div><div class="line"><a name="l00274"></a><span class="lineno">  274</span>&#160;    <span class="keywordflow">return</span> Msg.Rsp.StatusOrLen;</div><div class="line"><a name="l00275"></a><span class="lineno">  275</span>&#160;}</div><div class="ttc" id="struct_sl_socket_response__t_html"><div class="ttname"><a href="struct_sl_socket_response__t.html">SlSocketResponse_t</a></div><div class="ttdef"><b>Definition:</b> <a href="protocol_8h_source.html#l00729">protocol.h:729</a></div></div>
<div class="ttc" id="struct___sl_cmd_ctrl__t_html"><div class="ttname"><a href="struct___sl_cmd_ctrl__t.html">_SlCmdCtrl_t</a></div><div class="ttdef"><b>Definition:</b> <a href="driver_8h_source.html#l00179">driver.h:179</a></div></div>
<div class="ttc" id="struct_sl_socket_addr_i_pv4_command__t_html"><div class="ttname"><a href="struct_sl_socket_addr_i_pv4_command__t.html">SlSocketAddrIPv4Command_t</a></div><div class="ttdef"><b>Definition:</b> <a href="protocol_8h_source.html#l00773">protocol.h:773</a></div></div>
<div class="ttc" id="struct_sl_socket_addr_i_pv6_command__t_html"><div class="ttname"><a href="struct_sl_socket_addr_i_pv6_command__t.html">SlSocketAddrIPv6Command_t</a></div><div class="ttdef"><b>Definition:</b> <a href="protocol_8h_source.html#l00792">protocol.h:792</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="gacc7971a6e41592c8ef90936b25495a8b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacc7971a6e41592c8ef90936b25495a8b">&sect;&nbsp;</a></span>sl_Close()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">_i16 sl_Close </td>
          <td>(</td>
          <td class="paramtype">_i16&#160;</td>
          <td class="paramname"><em>sd</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gracefully close socket. </p>
<p>This function causes the system to release resources allocated to a socket. <br />
In case of TCP, the connection is terminated.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">sd</td><td>Socket handle (received in sl_Socket)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Zero on success, or negative error code on failure</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group___socket.html#gaa775fcb6d09bf35b9dac3e5eb8e8c997" title="Create an endpoint for communication. ">sl_Socket</a> </dd></dl>
<dl class="section note"><dt>Note</dt><dd>belongs to ext_api </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd></dd></dl>

<p>Definition at line <a class="el" href="sl__socket_8c_source.html#l00180">180</a> of file <a class="el" href="sl__socket_8c_source.html">sl_socket.c</a>.</p>
<div class="fragment"><div class="line"><a name="l00181"></a><span class="lineno">  181</span>&#160;{</div><div class="line"><a name="l00182"></a><span class="lineno">  182</span>&#160;    _SlSockCloseMsg_u    Msg;</div><div class="line"><a name="l00183"></a><span class="lineno">  183</span>&#160;    _u8                  ObjIdx = MAX_CONCURRENT_ACTIONS;</div><div class="line"><a name="l00184"></a><span class="lineno">  184</span>&#160;    <a class="code" href="struct_sl_socket_response__t.html">SlSocketResponse_t</a>   AsyncRsp;</div><div class="line"><a name="l00185"></a><span class="lineno">  185</span>&#160;    _SlReturnVal_t       RetVal;</div><div class="line"><a name="l00186"></a><span class="lineno">  186</span>&#160;    _u8                  bSocketInAction = FALSE;</div><div class="line"><a name="l00187"></a><span class="lineno">  187</span>&#160;</div><div class="line"><a name="l00188"></a><span class="lineno">  188</span>&#160;    <span class="comment">/* verify that this api is allowed. if not allowed then</span></div><div class="line"><a name="l00189"></a><span class="lineno">  189</span>&#160;<span class="comment">    ignore the API execution and return immediately with an error */</span></div><div class="line"><a name="l00190"></a><span class="lineno">  190</span>&#160;    VERIFY_API_ALLOWED(SL_OPCODE_SILO_SOCKET);</div><div class="line"><a name="l00191"></a><span class="lineno">  191</span>&#160;</div><div class="line"><a name="l00192"></a><span class="lineno">  192</span>&#160;    Msg.Cmd.Sd = (_u8)sd;</div><div class="line"><a name="l00193"></a><span class="lineno">  193</span>&#160;    _SlDrvMemZero(&amp;AsyncRsp, <span class="keyword">sizeof</span>(<a class="code" href="struct_sl_socket_response__t.html">SlSocketResponse_t</a>));</div><div class="line"><a name="l00194"></a><span class="lineno">  194</span>&#160;</div><div class="line"><a name="l00195"></a><span class="lineno">  195</span>&#160;    <span class="comment">/* check if the socket has already action in progress */</span></div><div class="line"><a name="l00196"></a><span class="lineno">  196</span>&#160;    bSocketInAction = !!(g_pCB-&gt;ActiveActionsBitmap &amp; (1&lt;&lt;sd));</div><div class="line"><a name="l00197"></a><span class="lineno">  197</span>&#160;</div><div class="line"><a name="l00198"></a><span class="lineno">  198</span>&#160;    <span class="keywordflow">if</span> (bSocketInAction == FALSE)</div><div class="line"><a name="l00199"></a><span class="lineno">  199</span>&#160;    {</div><div class="line"><a name="l00200"></a><span class="lineno">  200</span>&#160;        ObjIdx = _SlDrvProtectAsyncRespSetting((_u8*)&amp;AsyncRsp, CLOSE_ID, (_u8)(sd  &amp; SL_BSD_SOCKET_ID_MASK));</div><div class="line"><a name="l00201"></a><span class="lineno">  201</span>&#160;</div><div class="line"><a name="l00202"></a><span class="lineno">  202</span>&#160;        <span class="keywordflow">if</span> (MAX_CONCURRENT_ACTIONS == ObjIdx)</div><div class="line"><a name="l00203"></a><span class="lineno">  203</span>&#160;        {</div><div class="line"><a name="l00204"></a><span class="lineno">  204</span>&#160;            <span class="keywordflow">return</span> SL_POOL_IS_EMPTY;</div><div class="line"><a name="l00205"></a><span class="lineno">  205</span>&#160;        }</div><div class="line"><a name="l00206"></a><span class="lineno">  206</span>&#160;    }</div><div class="line"><a name="l00207"></a><span class="lineno">  207</span>&#160;</div><div class="line"><a name="l00208"></a><span class="lineno">  208</span>&#160;    VERIFY_RET_OK(_SlDrvCmdOp((<a class="code" href="struct___sl_cmd_ctrl__t.html">_SlCmdCtrl_t</a> *)&amp;_SlSockCloseCmdCtrl, &amp;Msg, NULL));</div><div class="line"><a name="l00209"></a><span class="lineno">  209</span>&#160;    </div><div class="line"><a name="l00210"></a><span class="lineno">  210</span>&#160;    RetVal = Msg.Rsp.StatusOrLen;</div><div class="line"><a name="l00211"></a><span class="lineno">  211</span>&#160;</div><div class="line"><a name="l00212"></a><span class="lineno">  212</span>&#160;    <span class="keywordflow">if</span> (bSocketInAction == FALSE)</div><div class="line"><a name="l00213"></a><span class="lineno">  213</span>&#160;    {</div><div class="line"><a name="l00214"></a><span class="lineno">  214</span>&#160;        <span class="keywordflow">if</span>( SL_RET_CODE_OK == RetVal)</div><div class="line"><a name="l00215"></a><span class="lineno">  215</span>&#160;        {    </div><div class="line"><a name="l00216"></a><span class="lineno">  216</span>&#160;            SL_DRV_SYNC_OBJ_WAIT_TIMEOUT(&amp;g_pCB-&gt;ObjPool[ObjIdx].SyncObj,</div><div class="line"><a name="l00217"></a><span class="lineno">  217</span>&#160;                            SL_DRIVER_TIMEOUT_LONG,</div><div class="line"><a name="l00218"></a><span class="lineno">  218</span>&#160;                            SL_OPCODE_SOCKET_SOCKETCLOSEASYNCEVENT</div><div class="line"><a name="l00219"></a><span class="lineno">  219</span>&#160;                            );</div><div class="line"><a name="l00220"></a><span class="lineno">  220</span>&#160;            RetVal = AsyncRsp.StatusOrLen;</div><div class="line"><a name="l00221"></a><span class="lineno">  221</span>&#160;        }</div><div class="line"><a name="l00222"></a><span class="lineno">  222</span>&#160;</div><div class="line"><a name="l00223"></a><span class="lineno">  223</span>&#160;        _SlDrvReleasePoolObj(ObjIdx);</div><div class="line"><a name="l00224"></a><span class="lineno">  224</span>&#160;    }</div><div class="line"><a name="l00225"></a><span class="lineno">  225</span>&#160;</div><div class="line"><a name="l00226"></a><span class="lineno">  226</span>&#160;    <span class="keywordflow">return</span> RetVal;</div><div class="line"><a name="l00227"></a><span class="lineno">  227</span>&#160;}</div><div class="ttc" id="struct_sl_socket_response__t_html"><div class="ttname"><a href="struct_sl_socket_response__t.html">SlSocketResponse_t</a></div><div class="ttdef"><b>Definition:</b> <a href="protocol_8h_source.html#l00729">protocol.h:729</a></div></div>
<div class="ttc" id="struct___sl_cmd_ctrl__t_html"><div class="ttname"><a href="struct___sl_cmd_ctrl__t.html">_SlCmdCtrl_t</a></div><div class="ttdef"><b>Definition:</b> <a href="driver_8h_source.html#l00179">driver.h:179</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="gad8b9db85493e84b19994840f4cff0ca0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad8b9db85493e84b19994840f4cff0ca0">&sect;&nbsp;</a></span>sl_Connect()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">_i16 sl_Connect </td>
          <td>(</td>
          <td class="paramtype">_i16&#160;</td>
          <td class="paramname"><em>sd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group___socket.html#struct_sl_sock_addr__t">SlSockAddr_t</a> *&#160;</td>
          <td class="paramname"><em>addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_i16&#160;</td>
          <td class="paramname"><em>addrlen</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initiate a connection on a socket. </p>
<p>Function connects the socket referred to by the socket descriptor sd, to the address specified by addr. The addrlen argument specifies the size of addr. The format of the address in addr is determined by the address space of the socket. If it is of type SOCK_DGRAM, this call specifies the peer with which the socket is to be associated; this address is that to which datagrams are to be sent, and the only address from which datagrams are to be received. If the socket is of type SOCK_STREAM, this call attempts to make a connection to another socket. The other socket is specified by address, which is an address in the communications space of the socket.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">sd</td><td>Socket descriptor (handle) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">addr</td><td>Specifies the destination addr<br />
 sockaddr:<br />
 - code for the address format. On this version only AF_INET is supported.<br />
 - socket address, the length depends on the code format</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">addrlen</td><td>Contains the size of the structure pointed to by addr</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>On success, a socket handle.<br />
 On a non-blocking connect a possible negative value is SL_EALREADY. On failure, negative value.<br />
 SL_POOL_IS_EMPTY may be return in case there are no resources in the system In this case try again later or increase MAX_CONCURRENT_ACTIONS</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group___socket.html#gaa775fcb6d09bf35b9dac3e5eb8e8c997" title="Create an endpoint for communication. ">sl_Socket</a> </dd></dl>
<dl class="section note"><dt>Note</dt><dd>belongs to client_side </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd></dd></dl>

<p>Definition at line <a class="el" href="sl__socket_8c_source.html#l00456">456</a> of file <a class="el" href="sl__socket_8c_source.html">sl_socket.c</a>.</p>
<div class="fragment"><div class="line"><a name="l00457"></a><span class="lineno">  457</span>&#160;{</div><div class="line"><a name="l00458"></a><span class="lineno">  458</span>&#160;      _SlSockConnectMsg_u  Msg;</div><div class="line"><a name="l00459"></a><span class="lineno">  459</span>&#160;      _SlReturnVal_t       RetVal;</div><div class="line"><a name="l00460"></a><span class="lineno">  460</span>&#160;      <a class="code" href="struct___sl_cmd_ctrl__t.html">_SlCmdCtrl_t</a>         CmdCtrl = {0, (_SlArgSize_t)0, (_SlArgSize_t)<span class="keyword">sizeof</span>(<a class="code" href="struct_sl_socket_response__t.html">SlSocketResponse_t</a>)};</div><div class="line"><a name="l00461"></a><span class="lineno">  461</span>&#160;      <a class="code" href="struct_sl_socket_response__t.html">SlSocketResponse_t</a>   AsyncRsp;</div><div class="line"><a name="l00462"></a><span class="lineno">  462</span>&#160;      _u8 ObjIdx = MAX_CONCURRENT_ACTIONS;</div><div class="line"><a name="l00463"></a><span class="lineno">  463</span>&#160;</div><div class="line"><a name="l00464"></a><span class="lineno">  464</span>&#160;    <span class="comment">/* verify that this api is allowed. if not allowed then</span></div><div class="line"><a name="l00465"></a><span class="lineno">  465</span>&#160;<span class="comment">    ignore the API execution and return immediately with an error */</span></div><div class="line"><a name="l00466"></a><span class="lineno">  466</span>&#160;    VERIFY_API_ALLOWED(SL_OPCODE_SILO_SOCKET);</div><div class="line"><a name="l00467"></a><span class="lineno">  467</span>&#160;    _SlDrvMemZero(&amp;AsyncRsp, <span class="keyword">sizeof</span>(<a class="code" href="struct_sl_socket_response__t.html">SlSocketResponse_t</a>));</div><div class="line"><a name="l00468"></a><span class="lineno">  468</span>&#160;</div><div class="line"><a name="l00469"></a><span class="lineno">  469</span>&#160;    <span class="keywordflow">switch</span>(addr-&gt;sa_family)</div><div class="line"><a name="l00470"></a><span class="lineno">  470</span>&#160;    {</div><div class="line"><a name="l00471"></a><span class="lineno">  471</span>&#160;        <span class="keywordflow">case</span> SL_AF_INET :</div><div class="line"><a name="l00472"></a><span class="lineno">  472</span>&#160;            CmdCtrl.Opcode = SL_OPCODE_SOCKET_CONNECT;</div><div class="line"><a name="l00473"></a><span class="lineno">  473</span>&#160;            CmdCtrl.TxDescLen = (_SlArgSize_t)<span class="keyword">sizeof</span>(<a class="code" href="struct_sl_socket_addr_i_pv4_command__t.html">SlSocketAddrIPv4Command_t</a>);</div><div class="line"><a name="l00474"></a><span class="lineno">  474</span>&#160;            <span class="comment">/* Do nothing - cmd already initialized to this type */</span></div><div class="line"><a name="l00475"></a><span class="lineno">  475</span>&#160;            <span class="keywordflow">break</span>;</div><div class="line"><a name="l00476"></a><span class="lineno">  476</span>&#160;<span class="preprocessor">#ifdef SL_SUPPORT_IPV6</span></div><div class="line"><a name="l00477"></a><span class="lineno">  477</span>&#160;        <span class="keywordflow">case</span> SL_AF_INET6:</div><div class="line"><a name="l00478"></a><span class="lineno">  478</span>&#160;            CmdCtrl.Opcode = SL_OPCODE_SOCKET_CONNECT_V6;</div><div class="line"><a name="l00479"></a><span class="lineno">  479</span>&#160;            CmdCtrl.TxDescLen = (_SlArgSize_t)<span class="keyword">sizeof</span>(<a class="code" href="struct_sl_socket_addr_i_pv6_command__t.html">SlSocketAddrIPv6Command_t</a>);</div><div class="line"><a name="l00480"></a><span class="lineno">  480</span>&#160;            <span class="keywordflow">break</span>;</div><div class="line"><a name="l00481"></a><span class="lineno">  481</span>&#160;<span class="preprocessor">#endif</span></div><div class="line"><a name="l00482"></a><span class="lineno">  482</span>&#160;        <span class="keywordflow">case</span> SL_AF_RF:</div><div class="line"><a name="l00483"></a><span class="lineno">  483</span>&#160;        <span class="keywordflow">default</span>:</div><div class="line"><a name="l00484"></a><span class="lineno">  484</span>&#160;            <span class="keywordflow">return</span> SL_RET_CODE_INVALID_INPUT;</div><div class="line"><a name="l00485"></a><span class="lineno">  485</span>&#160;    }</div><div class="line"><a name="l00486"></a><span class="lineno">  486</span>&#160;</div><div class="line"><a name="l00487"></a><span class="lineno">  487</span>&#160;    Msg.Cmd.IpV4.LenOrPadding = 0;</div><div class="line"><a name="l00488"></a><span class="lineno">  488</span>&#160;    Msg.Cmd.IpV4.Sd = (_u8)sd;</div><div class="line"><a name="l00489"></a><span class="lineno">  489</span>&#160;</div><div class="line"><a name="l00490"></a><span class="lineno">  490</span>&#160;    _SlSocketBuildAddress(addr, &amp;Msg.Cmd);</div><div class="line"><a name="l00491"></a><span class="lineno">  491</span>&#160;</div><div class="line"><a name="l00492"></a><span class="lineno">  492</span>&#160;    ObjIdx = _SlDrvProtectAsyncRespSetting((_u8*)&amp;AsyncRsp, CONNECT_ID, (_u8)(sd  &amp; SL_BSD_SOCKET_ID_MASK));</div><div class="line"><a name="l00493"></a><span class="lineno">  493</span>&#160;</div><div class="line"><a name="l00494"></a><span class="lineno">  494</span>&#160;    <span class="keywordflow">if</span> (MAX_CONCURRENT_ACTIONS == ObjIdx)</div><div class="line"><a name="l00495"></a><span class="lineno">  495</span>&#160;    {</div><div class="line"><a name="l00496"></a><span class="lineno">  496</span>&#160;        <span class="keywordflow">return</span> SL_POOL_IS_EMPTY;</div><div class="line"><a name="l00497"></a><span class="lineno">  497</span>&#160;    }</div><div class="line"><a name="l00498"></a><span class="lineno">  498</span>&#160;</div><div class="line"><a name="l00499"></a><span class="lineno">  499</span>&#160;    <span class="comment">/* send the command */</span></div><div class="line"><a name="l00500"></a><span class="lineno">  500</span>&#160;    VERIFY_RET_OK(_SlDrvCmdOp((<a class="code" href="struct___sl_cmd_ctrl__t.html">_SlCmdCtrl_t</a> *)&amp;CmdCtrl, &amp;Msg, NULL));</div><div class="line"><a name="l00501"></a><span class="lineno">  501</span>&#160;    VERIFY_PROTOCOL(Msg.Rsp.Sd == (_u8)sd);</div><div class="line"><a name="l00502"></a><span class="lineno">  502</span>&#160;</div><div class="line"><a name="l00503"></a><span class="lineno">  503</span>&#160;    RetVal = Msg.Rsp.StatusOrLen;</div><div class="line"><a name="l00504"></a><span class="lineno">  504</span>&#160;</div><div class="line"><a name="l00505"></a><span class="lineno">  505</span>&#160;    <span class="keywordflow">if</span>(SL_RET_CODE_OK == RetVal)</div><div class="line"><a name="l00506"></a><span class="lineno">  506</span>&#160;    {</div><div class="line"><a name="l00507"></a><span class="lineno">  507</span>&#160;<span class="preprocessor">#ifndef SL_TINY    </span></div><div class="line"><a name="l00508"></a><span class="lineno">  508</span>&#160;        <span class="comment">/*In case socket is non-blocking one, the async event should be received immediately */</span></div><div class="line"><a name="l00509"></a><span class="lineno">  509</span>&#160;        <span class="keywordflow">if</span>( g_pCB-&gt;SocketNonBlocking &amp; (1&lt;&lt;(sd &amp; SL_BSD_SOCKET_ID_MASK) ))</div><div class="line"><a name="l00510"></a><span class="lineno">  510</span>&#160;        {</div><div class="line"><a name="l00511"></a><span class="lineno">  511</span>&#160;            SL_DRV_SYNC_OBJ_WAIT_TIMEOUT(&amp;g_pCB-&gt;ObjPool[ObjIdx].SyncObj,</div><div class="line"><a name="l00512"></a><span class="lineno">  512</span>&#160;                                          SL_DRIVER_TIMEOUT_SHORT,</div><div class="line"><a name="l00513"></a><span class="lineno">  513</span>&#160;                                          SL_OPCODE_SOCKET_CONNECTASYNCRESPONSE</div><div class="line"><a name="l00514"></a><span class="lineno">  514</span>&#160;                                          );</div><div class="line"><a name="l00515"></a><span class="lineno">  515</span>&#160;        }</div><div class="line"><a name="l00516"></a><span class="lineno">  516</span>&#160;        <span class="keywordflow">else</span></div><div class="line"><a name="l00517"></a><span class="lineno">  517</span>&#160;<span class="preprocessor">#endif</span></div><div class="line"><a name="l00518"></a><span class="lineno">  518</span>&#160;        {</div><div class="line"><a name="l00519"></a><span class="lineno">  519</span>&#160;</div><div class="line"><a name="l00520"></a><span class="lineno">  520</span>&#160;            <span class="comment">/* wait for async and get Data Read parameters */</span></div><div class="line"><a name="l00521"></a><span class="lineno">  521</span>&#160;            SL_DRV_SYNC_OBJ_WAIT_FOREVER(&amp;g_pCB-&gt;ObjPool[ObjIdx].SyncObj);</div><div class="line"><a name="l00522"></a><span class="lineno">  522</span>&#160;        }</div><div class="line"><a name="l00523"></a><span class="lineno">  523</span>&#160;</div><div class="line"><a name="l00524"></a><span class="lineno">  524</span>&#160;        VERIFY_PROTOCOL(AsyncRsp.Sd == (_u8)sd);</div><div class="line"><a name="l00525"></a><span class="lineno">  525</span>&#160;        RetVal = AsyncRsp.StatusOrLen;</div><div class="line"><a name="l00526"></a><span class="lineno">  526</span>&#160;    }</div><div class="line"><a name="l00527"></a><span class="lineno">  527</span>&#160;</div><div class="line"><a name="l00528"></a><span class="lineno">  528</span>&#160;    _SlDrvReleasePoolObj(ObjIdx);</div><div class="line"><a name="l00529"></a><span class="lineno">  529</span>&#160;    <span class="keywordflow">return</span> RetVal;</div><div class="line"><a name="l00530"></a><span class="lineno">  530</span>&#160;}</div><div class="ttc" id="struct_sl_socket_response__t_html"><div class="ttname"><a href="struct_sl_socket_response__t.html">SlSocketResponse_t</a></div><div class="ttdef"><b>Definition:</b> <a href="protocol_8h_source.html#l00729">protocol.h:729</a></div></div>
<div class="ttc" id="struct___sl_cmd_ctrl__t_html"><div class="ttname"><a href="struct___sl_cmd_ctrl__t.html">_SlCmdCtrl_t</a></div><div class="ttdef"><b>Definition:</b> <a href="driver_8h_source.html#l00179">driver.h:179</a></div></div>
<div class="ttc" id="struct_sl_socket_addr_i_pv4_command__t_html"><div class="ttname"><a href="struct_sl_socket_addr_i_pv4_command__t.html">SlSocketAddrIPv4Command_t</a></div><div class="ttdef"><b>Definition:</b> <a href="protocol_8h_source.html#l00773">protocol.h:773</a></div></div>
<div class="ttc" id="struct_sl_socket_addr_i_pv6_command__t_html"><div class="ttname"><a href="struct_sl_socket_addr_i_pv6_command__t.html">SlSocketAddrIPv6Command_t</a></div><div class="ttdef"><b>Definition:</b> <a href="protocol_8h_source.html#l00792">protocol.h:792</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="ga77d6029b0c39df5541b0b0d6484591b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga77d6029b0c39df5541b0b0d6484591b4">&sect;&nbsp;</a></span>sl_GetSockOpt()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">_i16 sl_GetSockOpt </td>
          <td>(</td>
          <td class="paramtype">_i16&#160;</td>
          <td class="paramname"><em>sd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_i16&#160;</td>
          <td class="paramname"><em>level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_i16&#160;</td>
          <td class="paramname"><em>optname</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>optval</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SlSocklen_t *&#160;</td>
          <td class="paramname"><em>optlen</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get socket options. </p>
<p>This function manipulate the options associated with a socket. Options may exist at multiple protocol levels; they are always present at the uppermost socket level.<br />
 When manipulating socket options the level at which the option resides and the name of the option must be specified. To manipulate options at the socket level, level is specified as SOL_SOCKET. To manipulate options at any other level the protocol number of the appropriate protocol controlling the option is supplied. For example, to indicate that an option is to be interpreted by the TCP protocol, level should be set to the protocol number of TCP; <br />
 The parameters optval and optlen are used to access optvalues for <a class="el" href="group___b_s_d___socket.html#gaafa5721213ca1bfb2c1ab1ea0f39bf5c" title="Set socket options-. ">setsockopt()</a>. For <a class="el" href="group___b_s_d___socket.html#ga37e0195dbaf69283dd8541c2ae631b82" title="Get socket options. ">getsockopt()</a> they identify a buffer in which the value for the requested option(s) are to be returned. For <a class="el" href="group___b_s_d___socket.html#ga37e0195dbaf69283dd8541c2ae631b82" title="Get socket options. ">getsockopt()</a>, optlen is a value-result parameter, initially containing the size of the buffer pointed to by option_value, and modified on return to indicate the actual size of the value returned. If no option value is to be supplied or returned, option_value may be NULL.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">sd</td><td>Socket handle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">level</td><td>Defines the protocol level for this option </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">optname</td><td>defines the option name to interrogate </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">optval</td><td>Specifies a value for the option </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">optlen</td><td>Specifies the length of the option value</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Zero on success, or negative error code on failure </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group___socket.html#ga6363ea2098e629c1a6e2bf80e731fb79" title="Set socket options-. ">sl_SetSockOpt</a> </dd></dl>
<dl class="section note"><dt>Note</dt><dd>See sl_SetSockOpt Belongs to ext_api </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd></dd></dl>

<p>Definition at line <a class="el" href="sl__socket_8c_source.html#l00968">968</a> of file <a class="el" href="sl__socket_8c_source.html">sl_socket.c</a>.</p>
<div class="fragment"><div class="line"><a name="l00969"></a><span class="lineno">  969</span>&#160;{</div><div class="line"><a name="l00970"></a><span class="lineno">  970</span>&#160;    _SlGetSockOptMsg_u    Msg;</div><div class="line"><a name="l00971"></a><span class="lineno">  971</span>&#160;    <a class="code" href="struct___sl_cmd_ext__t.html">_SlCmdExt_t</a>           CmdExt;</div><div class="line"><a name="l00972"></a><span class="lineno">  972</span>&#160;</div><div class="line"><a name="l00973"></a><span class="lineno">  973</span>&#160;    <span class="comment">/* verify that this api is allowed. if not allowed then</span></div><div class="line"><a name="l00974"></a><span class="lineno">  974</span>&#160;<span class="comment">    ignore the API execution and return immediately with an error */</span></div><div class="line"><a name="l00975"></a><span class="lineno">  975</span>&#160;    VERIFY_API_ALLOWED(SL_OPCODE_SILO_SOCKET);</div><div class="line"><a name="l00976"></a><span class="lineno">  976</span>&#160;    <span class="keywordflow">if</span> (*optlen == 0)</div><div class="line"><a name="l00977"></a><span class="lineno">  977</span>&#160;    {</div><div class="line"><a name="l00978"></a><span class="lineno">  978</span>&#160;        <span class="keywordflow">return</span> SL_EZEROLEN;</div><div class="line"><a name="l00979"></a><span class="lineno">  979</span>&#160;    }</div><div class="line"><a name="l00980"></a><span class="lineno">  980</span>&#160;</div><div class="line"><a name="l00981"></a><span class="lineno">  981</span>&#160;    _SlDrvResetCmdExt(&amp;CmdExt);</div><div class="line"><a name="l00982"></a><span class="lineno">  982</span>&#160;    CmdExt.RxPayloadLen = (_i16)(*optlen);</div><div class="line"><a name="l00983"></a><span class="lineno">  983</span>&#160;    CmdExt.pRxPayload = optval;</div><div class="line"><a name="l00984"></a><span class="lineno">  984</span>&#160;</div><div class="line"><a name="l00985"></a><span class="lineno">  985</span>&#160;    Msg.Cmd.Sd = (_u8)sd;</div><div class="line"><a name="l00986"></a><span class="lineno">  986</span>&#160;    Msg.Cmd.Level = (_u8)level;</div><div class="line"><a name="l00987"></a><span class="lineno">  987</span>&#160;    Msg.Cmd.OptionLen = (_u8)(*optlen);</div><div class="line"><a name="l00988"></a><span class="lineno">  988</span>&#160;    Msg.Cmd.OptionName = (_u8)optname;</div><div class="line"><a name="l00989"></a><span class="lineno">  989</span>&#160;</div><div class="line"><a name="l00990"></a><span class="lineno">  990</span>&#160;    VERIFY_RET_OK(_SlDrvCmdOp((<a class="code" href="struct___sl_cmd_ctrl__t.html">_SlCmdCtrl_t</a> *)&amp;_SlGetSockOptCmdCtrl, &amp;Msg, &amp;CmdExt));</div><div class="line"><a name="l00991"></a><span class="lineno">  991</span>&#160;</div><div class="line"><a name="l00992"></a><span class="lineno">  992</span>&#160;    <span class="keywordflow">if</span> (CmdExt.RxPayloadLen &lt; CmdExt.ActualRxPayloadLen) </div><div class="line"><a name="l00993"></a><span class="lineno">  993</span>&#160;    {</div><div class="line"><a name="l00994"></a><span class="lineno">  994</span>&#160;        *optlen = Msg.Rsp.OptionLen;</div><div class="line"><a name="l00995"></a><span class="lineno">  995</span>&#160;        <span class="keywordflow">return</span> SL_ESMALLBUF;</div><div class="line"><a name="l00996"></a><span class="lineno">  996</span>&#160;    }</div><div class="line"><a name="l00997"></a><span class="lineno">  997</span>&#160;    <span class="keywordflow">else</span></div><div class="line"><a name="l00998"></a><span class="lineno">  998</span>&#160;    {</div><div class="line"><a name="l00999"></a><span class="lineno">  999</span>&#160;        *optlen = (_u8)CmdExt.ActualRxPayloadLen;</div><div class="line"><a name="l01000"></a><span class="lineno"> 1000</span>&#160;    }</div><div class="line"><a name="l01001"></a><span class="lineno"> 1001</span>&#160;    <span class="keywordflow">return</span> (_i16)Msg.Rsp.Status;</div><div class="line"><a name="l01002"></a><span class="lineno"> 1002</span>&#160;}</div><div class="ttc" id="struct___sl_cmd_ctrl__t_html"><div class="ttname"><a href="struct___sl_cmd_ctrl__t.html">_SlCmdCtrl_t</a></div><div class="ttdef"><b>Definition:</b> <a href="driver_8h_source.html#l00179">driver.h:179</a></div></div>
<div class="ttc" id="struct___sl_cmd_ext__t_html"><div class="ttname"><a href="struct___sl_cmd_ext__t.html">_SlCmdExt_t</a></div><div class="ttdef"><b>Definition:</b> <a href="driver_8h_source.html#l00186">driver.h:186</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="ga712c2a31c2844b54c33ede3a9a148d61"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga712c2a31c2844b54c33ede3a9a148d61">&sect;&nbsp;</a></span>sl_Htonl()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">_u32 sl_Htonl </td>
          <td>(</td>
          <td class="paramtype">_u32&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reorder the bytes of a 32-bit unsigned value. </p>
<p>This function is used to Reorder the bytes of a 32-bit unsigned value from processor order to network order.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">val</td><td>Variable to reorder</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Return the reorder variable,</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group___socket.html#ga7ca76d181974c71673c3bf3fc1fedfdc" title="Write data to socket. ">sl_SendTo</a> <a class="el" href="group___socket.html#gadcb0c4792127dceb1feb3e9b87ab2094" title="Assign a name to a socket. ">sl_Bind</a> <a class="el" href="group___socket.html#gad8b9db85493e84b19994840f4cff0ca0" title="Initiate a connection on a socket. ">sl_Connect</a> <a class="el" href="group___socket.html#ga02f8b2eb34db39069a1385d4fce80eea" title="Read data from socket. ">sl_RecvFrom</a> <a class="el" href="group___socket.html#ga72085bf8fae027f8fe31a0eb99a6808b" title="Accept a connection on a socket. ">sl_Accept</a> </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Belongs to send_api </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd></dd></dl>

<p>Definition at line <a class="el" href="sl__socket_8c_source.html#l00797">797</a> of file <a class="el" href="sl__socket_8c_source.html">sl_socket.c</a>.</p>
<div class="fragment"><div class="line"><a name="l00798"></a><span class="lineno">  798</span>&#160;{</div><div class="line"><a name="l00799"></a><span class="lineno">  799</span>&#160;    _u32 i = 1; </div><div class="line"><a name="l00800"></a><span class="lineno">  800</span>&#160;    _i8 *p = (_i8 *)&amp;i;  </div><div class="line"><a name="l00801"></a><span class="lineno">  801</span>&#160;    <span class="keywordflow">if</span> (p[0] == 1) <span class="comment">/* little endian */</span></div><div class="line"><a name="l00802"></a><span class="lineno">  802</span>&#160;    {</div><div class="line"><a name="l00803"></a><span class="lineno">  803</span>&#160;        p[0] = ((_i8* )&amp;val)[3];</div><div class="line"><a name="l00804"></a><span class="lineno">  804</span>&#160;        p[1] = ((_i8* )&amp;val)[2];</div><div class="line"><a name="l00805"></a><span class="lineno">  805</span>&#160;        p[2] = ((_i8* )&amp;val)[1];</div><div class="line"><a name="l00806"></a><span class="lineno">  806</span>&#160;        p[3] = ((_i8* )&amp;val)[0];</div><div class="line"><a name="l00807"></a><span class="lineno">  807</span>&#160;        <span class="keywordflow">return</span> i;</div><div class="line"><a name="l00808"></a><span class="lineno">  808</span>&#160;    }</div><div class="line"><a name="l00809"></a><span class="lineno">  809</span>&#160;    <span class="keywordflow">else</span> <span class="comment">/* big endian */</span></div><div class="line"><a name="l00810"></a><span class="lineno">  810</span>&#160;    {</div><div class="line"><a name="l00811"></a><span class="lineno">  811</span>&#160;        <span class="keywordflow">return</span> val; </div><div class="line"><a name="l00812"></a><span class="lineno">  812</span>&#160;    }</div><div class="line"><a name="l00813"></a><span class="lineno">  813</span>&#160;}</div></div><!-- fragment -->
</div>
</div>
<a id="gadfb6f98e5c75a46050780e8afbae13bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadfb6f98e5c75a46050780e8afbae13bd">&sect;&nbsp;</a></span>sl_Htons()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">_u16 sl_Htons </td>
          <td>(</td>
          <td class="paramtype">_u16&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reorder the bytes of a 16-bit unsigned value. </p>
<p>This function is used to Reorder the bytes of a 16-bit unsigned value from processor order to network order.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">val</td><td>Variable to reorder</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Return the reorder variable,</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group___socket.html#ga7ca76d181974c71673c3bf3fc1fedfdc" title="Write data to socket. ">sl_SendTo</a> <a class="el" href="group___socket.html#gadcb0c4792127dceb1feb3e9b87ab2094" title="Assign a name to a socket. ">sl_Bind</a> <a class="el" href="group___socket.html#gad8b9db85493e84b19994840f4cff0ca0" title="Initiate a connection on a socket. ">sl_Connect</a> <a class="el" href="group___socket.html#ga02f8b2eb34db39069a1385d4fce80eea" title="Read data from socket. ">sl_RecvFrom</a> <a class="el" href="group___socket.html#ga72085bf8fae027f8fe31a0eb99a6808b" title="Accept a connection on a socket. ">sl_Accept</a> </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Belongs to send_api </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd></dd></dl>

<p>Definition at line <a class="el" href="sl__socket_8c_source.html#l00818">818</a> of file <a class="el" href="sl__socket_8c_source.html">sl_socket.c</a>.</p>
<div class="fragment"><div class="line"><a name="l00819"></a><span class="lineno">  819</span>&#160;{</div><div class="line"><a name="l00820"></a><span class="lineno">  820</span>&#160;    _i16 i = 1; </div><div class="line"><a name="l00821"></a><span class="lineno">  821</span>&#160;    _i8 *p = (_i8 *)&amp;i;  </div><div class="line"><a name="l00822"></a><span class="lineno">  822</span>&#160;    <span class="keywordflow">if</span> (p[0] == 1) <span class="comment">/* little endian */</span></div><div class="line"><a name="l00823"></a><span class="lineno">  823</span>&#160;    {</div><div class="line"><a name="l00824"></a><span class="lineno">  824</span>&#160;        p[0] = ((_i8* )&amp;val)[1];</div><div class="line"><a name="l00825"></a><span class="lineno">  825</span>&#160;        p[1] = ((_i8* )&amp;val)[0];</div><div class="line"><a name="l00826"></a><span class="lineno">  826</span>&#160;        <span class="keywordflow">return</span> (_u16)i;</div><div class="line"><a name="l00827"></a><span class="lineno">  827</span>&#160;    }</div><div class="line"><a name="l00828"></a><span class="lineno">  828</span>&#160;    <span class="keywordflow">else</span> <span class="comment">/* big endian */</span></div><div class="line"><a name="l00829"></a><span class="lineno">  829</span>&#160;    {</div><div class="line"><a name="l00830"></a><span class="lineno">  830</span>&#160;        <span class="keywordflow">return</span> val; </div><div class="line"><a name="l00831"></a><span class="lineno">  831</span>&#160;    }</div><div class="line"><a name="l00832"></a><span class="lineno">  832</span>&#160;}</div></div><!-- fragment -->
</div>
</div>
<a id="ga7d864d86f8dd7296774072db021a69e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7d864d86f8dd7296774072db021a69e7">&sect;&nbsp;</a></span>sl_Listen()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">_i16 sl_Listen </td>
          <td>(</td>
          <td class="paramtype">_i16&#160;</td>
          <td class="paramname"><em>sd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_i16&#160;</td>
          <td class="paramname"><em>backlog</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Listen for connections on a socket. </p>
<p>The willingness to accept incoming connections and a queue limit for incoming connections are specified with <a class="el" href="group___b_s_d___socket.html#gac0e1e895317be91692b6b8cc7e12b252" title="Listen for connections on a socket. ">listen()</a>, and then the connections are accepted with accept. The <a class="el" href="group___b_s_d___socket.html#gac0e1e895317be91692b6b8cc7e12b252" title="Listen for connections on a socket. ">listen()</a> call applies only to sockets of type SOCK_STREAM The backlog parameter defines the maximum length the queue of pending connections may grow to.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">sd</td><td>Socket descriptor (handle) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">backlog</td><td>Specifies the listen queue depth.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Zero on success, or negative error code on failure</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group___socket.html#gaa775fcb6d09bf35b9dac3e5eb8e8c997" title="Create an endpoint for communication. ">sl_Socket</a> <a class="el" href="group___socket.html#ga72085bf8fae027f8fe31a0eb99a6808b" title="Accept a connection on a socket. ">sl_Accept</a> <a class="el" href="group___socket.html#gadcb0c4792127dceb1feb3e9b87ab2094" title="Assign a name to a socket. ">sl_Bind</a> </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Belongs to server_side </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd></dd></dl>

<p>Definition at line <a class="el" href="sl__socket_8c_source.html#l00658">658</a> of file <a class="el" href="sl__socket_8c_source.html">sl_socket.c</a>.</p>
<div class="fragment"><div class="line"><a name="l00659"></a><span class="lineno">  659</span>&#160;{</div><div class="line"><a name="l00660"></a><span class="lineno">  660</span>&#160;    _SlListenMsg_u  Msg;</div><div class="line"><a name="l00661"></a><span class="lineno">  661</span>&#160;</div><div class="line"><a name="l00662"></a><span class="lineno">  662</span>&#160;    <span class="comment">/* verify that this api is allowed. if not allowed then</span></div><div class="line"><a name="l00663"></a><span class="lineno">  663</span>&#160;<span class="comment">    ignore the API execution and return immediately with an error */</span></div><div class="line"><a name="l00664"></a><span class="lineno">  664</span>&#160;    VERIFY_API_ALLOWED(SL_OPCODE_SILO_SOCKET);</div><div class="line"><a name="l00665"></a><span class="lineno">  665</span>&#160;</div><div class="line"><a name="l00666"></a><span class="lineno">  666</span>&#160;    Msg.Cmd.Sd = (_u8)sd;</div><div class="line"><a name="l00667"></a><span class="lineno">  667</span>&#160;    Msg.Cmd.Backlog = (_u8)backlog;</div><div class="line"><a name="l00668"></a><span class="lineno">  668</span>&#160;</div><div class="line"><a name="l00669"></a><span class="lineno">  669</span>&#160;    VERIFY_RET_OK(_SlDrvCmdOp((<a class="code" href="struct___sl_cmd_ctrl__t.html">_SlCmdCtrl_t</a> *)&amp;_SlListenCmdCtrl, &amp;Msg, NULL));</div><div class="line"><a name="l00670"></a><span class="lineno">  670</span>&#160;    <span class="keywordflow">return</span> (_i16)Msg.Rsp.status;</div><div class="line"><a name="l00671"></a><span class="lineno">  671</span>&#160;}</div><div class="ttc" id="struct___sl_cmd_ctrl__t_html"><div class="ttname"><a href="struct___sl_cmd_ctrl__t.html">_SlCmdCtrl_t</a></div><div class="ttdef"><b>Definition:</b> <a href="driver_8h_source.html#l00179">driver.h:179</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="ga26a0eacfbab2629e7f3daa0ad0080255"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga26a0eacfbab2629e7f3daa0ad0080255">&sect;&nbsp;</a></span>sl_Recv()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">_i16 sl_Recv </td>
          <td>(</td>
          <td class="paramtype">_i16&#160;</td>
          <td class="paramname"><em>sd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_i16&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_i16&#160;</td>
          <td class="paramname"><em>flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read data from TCP socket. </p>
<p>Function receives a message from a connection-mode socket</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">sd</td><td>Socket handle </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">buf</td><td>Points to the buffer where the message should be stored. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">len</td><td>Specifies the length in bytes of the buffer pointed to by the buffer argument. Range: 1-16000 bytes </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">flags</td><td>Specifies the type of message reception. On this version, this parameter is not supported.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Return the number of bytes received, or a negative value if an error occurred.<br />
 Using a non-blocking recv a possible negative value is SL_EAGAIN.<br />
 SL_POOL_IS_EMPTY may be return in case there are no resources in the system In this case try again later or increase MAX_CONCURRENT_ACTIONS</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group___socket.html#ga02f8b2eb34db39069a1385d4fce80eea" title="Read data from socket. ">sl_RecvFrom</a> </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Belongs to recv_api </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd></dd></dl>
<dl class="section user"><dt>Examples</dt><dd></dd></dl>
<ul>
<li>Receiving data using TCP socket: <div class="fragment"><div class="line"><a class="code" href="group___socket.html#struct_sl_sock_addr_in__t">SlSockAddrIn_t</a>  Addr;</div><div class="line"><a class="code" href="group___socket.html#struct_sl_sock_addr_in__t">SlSockAddrIn_t</a>  LocalAddr;</div><div class="line">_i16 AddrSize = <span class="keyword">sizeof</span>(<a class="code" href="group___socket.html#struct_sl_sock_addr_in__t">SlSockAddrIn_t</a>);</div><div class="line">_i16 SockID, newSockID;</div><div class="line">_i16 Status;</div><div class="line">_i8 Buf[RECV_BUF_LEN];</div><div class="line"></div><div class="line">LocalAddr.sin_family = SL_AF_INET;</div><div class="line">LocalAddr.sin_port = <a class="code" href="group___socket.html#gadfb6f98e5c75a46050780e8afbae13bd">sl_Htons</a>(5001);</div><div class="line">LocalAddr.sin_addr.s_addr = 0;</div><div class="line"></div><div class="line">Addr.sin_family = SL_AF_INET;</div><div class="line">Addr.sin_port = <a class="code" href="group___socket.html#gadfb6f98e5c75a46050780e8afbae13bd">sl_Htons</a>(5001);</div><div class="line">Addr.sin_addr.s_addr = <a class="code" href="group___socket.html#ga712c2a31c2844b54c33ede3a9a148d61">sl_Htonl</a>(SL_IPV4_VAL(10,1,1,200));</div><div class="line"></div><div class="line">SockID = <a class="code" href="group___socket.html#gaa775fcb6d09bf35b9dac3e5eb8e8c997">sl_Socket</a>(SL_AF_INET,SL_SOCK_STREAM, 0);</div><div class="line">Status = <a class="code" href="group___socket.html#gadcb0c4792127dceb1feb3e9b87ab2094">sl_Bind</a>(SockID, (<a class="code" href="group___socket.html#struct_sl_sock_addr__t">SlSockAddr_t</a> *)&amp;LocalAddr, AddrSize);</div><div class="line">Status = <a class="code" href="group___socket.html#ga7d864d86f8dd7296774072db021a69e7">sl_Listen</a>(SockID, 0);</div><div class="line">newSockID = <a class="code" href="group___socket.html#ga72085bf8fae027f8fe31a0eb99a6808b">sl_Accept</a>(SockID, (<a class="code" href="group___socket.html#struct_sl_sock_addr__t">SlSockAddr_t</a>*)&amp;Addr, (SlSocklen_t*) &amp;AddrSize);</div><div class="line">Status = <a class="code" href="group___socket.html#ga26a0eacfbab2629e7f3daa0ad0080255">sl_Recv</a>(newSockID, Buf, 1460, 0);</div></div><!-- fragment --> <br />
</li>
<li>Rx transceiver mode using a raw socket: <div class="fragment"><div class="line">_i8 buffer[1536];</div><div class="line">_i16 sd;</div><div class="line">_u16 size;</div><div class="line"><a class="code" href="group___socket.html#struct_sl_transceiver_rx_over_head__t">SlTransceiverRxOverHead_t</a> *transHeader;</div><div class="line">sd = <a class="code" href="group___socket.html#gaa775fcb6d09bf35b9dac3e5eb8e8c997">sl_Socket</a>(SL_AF_RF,SL_SOCK_RAW,11); <span class="comment">// channel 11</span></div><div class="line"><span class="keywordflow">while</span>(1)</div><div class="line">{</div><div class="line">    size = <a class="code" href="group___socket.html#ga26a0eacfbab2629e7f3daa0ad0080255">sl_Recv</a>(sd,buffer,1536,0);</div><div class="line">    transHeader = (<a class="code" href="group___socket.html#struct_sl_transceiver_rx_over_head__t">SlTransceiverRxOverHead_t</a> *)buffer;</div><div class="line">    printf(<span class="stringliteral">&quot;RSSI is %d frame type is 0x%x size %d\n&quot;</span>,transHeader-&gt;rssi,buffer[<span class="keyword">sizeof</span>(<a class="code" href="group___socket.html#struct_sl_transceiver_rx_over_head__t">SlTransceiverRxOverHead_t</a>)],size);</div><div class="line">}</div></div><!-- fragment --> </li>
</ul>

<p>Definition at line <a class="el" href="sl__socket_8c_source.html#l00874">874</a> of file <a class="el" href="sl__socket_8c_source.html">sl_socket.c</a>.</p>
<div class="fragment"><div class="line"><a name="l00875"></a><span class="lineno">  875</span>&#160;{</div><div class="line"><a name="l00876"></a><span class="lineno">  876</span>&#160;    _SlRecvMsg_u   Msg;</div><div class="line"><a name="l00877"></a><span class="lineno">  877</span>&#160;    <a class="code" href="struct___sl_cmd_ext__t.html">_SlCmdExt_t</a>    CmdExt;</div><div class="line"><a name="l00878"></a><span class="lineno">  878</span>&#160;    _SlReturnVal_t status;</div><div class="line"><a name="l00879"></a><span class="lineno">  879</span>&#160;</div><div class="line"><a name="l00880"></a><span class="lineno">  880</span>&#160;    <span class="comment">/* verify that this api is allowed. if not allowed then</span></div><div class="line"><a name="l00881"></a><span class="lineno">  881</span>&#160;<span class="comment">    ignore the API execution and return immediately with an error */</span></div><div class="line"><a name="l00882"></a><span class="lineno">  882</span>&#160;    VERIFY_API_ALLOWED(SL_OPCODE_SILO_SOCKET);</div><div class="line"><a name="l00883"></a><span class="lineno">  883</span>&#160;</div><div class="line"><a name="l00884"></a><span class="lineno">  884</span>&#160;    _SlDrvResetCmdExt(&amp;CmdExt);</div><div class="line"><a name="l00885"></a><span class="lineno">  885</span>&#160;    CmdExt.RxPayloadLen = Len;</div><div class="line"><a name="l00886"></a><span class="lineno">  886</span>&#160;    CmdExt.pRxPayload = (_u8 *)pBuf;</div><div class="line"><a name="l00887"></a><span class="lineno">  887</span>&#160;</div><div class="line"><a name="l00888"></a><span class="lineno">  888</span>&#160;    Msg.Cmd.Sd = (_u8)sd;</div><div class="line"><a name="l00889"></a><span class="lineno">  889</span>&#160;    Msg.Cmd.StatusOrLen = (_u16)Len;</div><div class="line"><a name="l00890"></a><span class="lineno">  890</span>&#160;</div><div class="line"><a name="l00891"></a><span class="lineno">  891</span>&#160;    <span class="comment">/*  no size truncation in recv path */</span></div><div class="line"><a name="l00892"></a><span class="lineno">  892</span>&#160;    CmdExt.RxPayloadLen = (_i16)Msg.Cmd.StatusOrLen;</div><div class="line"><a name="l00893"></a><span class="lineno">  893</span>&#160;</div><div class="line"><a name="l00894"></a><span class="lineno">  894</span>&#160;    Msg.Cmd.FamilyAndFlags = (_u8)(flags &amp; 0x0F);</div><div class="line"><a name="l00895"></a><span class="lineno">  895</span>&#160;</div><div class="line"><a name="l00896"></a><span class="lineno">  896</span>&#160;    status = _SlDrvDataReadOp((_SlSd_t)sd, (<a class="code" href="struct___sl_cmd_ctrl__t.html">_SlCmdCtrl_t</a> *)&amp;_SlRecvCmdCtrl, &amp;Msg, &amp;CmdExt);</div><div class="line"><a name="l00897"></a><span class="lineno">  897</span>&#160;    <span class="keywordflow">if</span>( status != SL_OS_RET_CODE_OK )</div><div class="line"><a name="l00898"></a><span class="lineno">  898</span>&#160;    {</div><div class="line"><a name="l00899"></a><span class="lineno">  899</span>&#160;        <span class="keywordflow">return</span> status;</div><div class="line"><a name="l00900"></a><span class="lineno">  900</span>&#160;    }</div><div class="line"><a name="l00901"></a><span class="lineno">  901</span>&#160;     </div><div class="line"><a name="l00902"></a><span class="lineno">  902</span>&#160;    <span class="comment">/*  if the Device side sends less than expected it is not the Driver&#39;s role */</span></div><div class="line"><a name="l00903"></a><span class="lineno">  903</span>&#160;    <span class="comment">/*  the returned value could be smaller than the requested size */</span></div><div class="line"><a name="l00904"></a><span class="lineno">  904</span>&#160;    <span class="keywordflow">return</span> (_i16)Msg.Rsp.StatusOrLen;</div><div class="line"><a name="l00905"></a><span class="lineno">  905</span>&#160;}</div><div class="ttc" id="struct___sl_cmd_ctrl__t_html"><div class="ttname"><a href="struct___sl_cmd_ctrl__t.html">_SlCmdCtrl_t</a></div><div class="ttdef"><b>Definition:</b> <a href="driver_8h_source.html#l00179">driver.h:179</a></div></div>
<div class="ttc" id="struct___sl_cmd_ext__t_html"><div class="ttname"><a href="struct___sl_cmd_ext__t.html">_SlCmdExt_t</a></div><div class="ttdef"><b>Definition:</b> <a href="driver_8h_source.html#l00186">driver.h:186</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="ga02f8b2eb34db39069a1385d4fce80eea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga02f8b2eb34db39069a1385d4fce80eea">&sect;&nbsp;</a></span>sl_RecvFrom()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">_i16 sl_RecvFrom </td>
          <td>(</td>
          <td class="paramtype">_i16&#160;</td>
          <td class="paramname"><em>sd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_i16&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_i16&#160;</td>
          <td class="paramname"><em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___socket.html#struct_sl_sock_addr__t">SlSockAddr_t</a> *&#160;</td>
          <td class="paramname"><em>from</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SlSocklen_t *&#160;</td>
          <td class="paramname"><em>fromlen</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read data from socket. </p>
<p>Function receives a message from a connection-mode or connectionless-mode socket</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">sd</td><td>Socket handle </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">buf</td><td>Points to the buffer where the message should be stored. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">len</td><td>Specifies the length in bytes of the buffer pointed to by the buffer argument. Range: 1-16000 bytes </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">flags</td><td>Specifies the type of message reception. On this version, this parameter is not supported. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">from</td><td>Pointer to an address structure indicating the source address.<br />
 sockaddr:<br />
 - code for the address format. On this version only AF_INET is supported.<br />
 - socket address, the length depends on the code format </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">fromlen</td><td>Source address structure size. This parameter MUST be set to the size of the structure pointed to by addr.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Return the number of bytes received, or a negative value if an error occurred.<br />
 Using a non-blocking recv a possible negative value is SL_EAGAIN. SL_RET_CODE_INVALID_INPUT (-2) will be returned if fromlen has incorrect length. <br />
 SL_POOL_IS_EMPTY may be return in case there are no resources in the system In this case try again later or increase MAX_CONCURRENT_ACTIONS</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group___socket.html#ga26a0eacfbab2629e7f3daa0ad0080255" title="Read data from TCP socket. ">sl_Recv</a> </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Belongs to recv_api </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd></dd></dl>
<dl class="section user"><dt>Example</dt><dd></dd></dl>
<ul>
<li>Receiving data: <div class="fragment"><div class="line"><a class="code" href="group___socket.html#struct_sl_sock_addr_in__t">SlSockAddrIn_t</a>  Addr;</div><div class="line"><a class="code" href="group___socket.html#struct_sl_sock_addr_in__t">SlSockAddrIn_t</a>  LocalAddr;</div><div class="line">_i16 AddrSize = <span class="keyword">sizeof</span>(<a class="code" href="group___socket.html#struct_sl_sock_addr_in__t">SlSockAddrIn_t</a>);</div><div class="line">_i16 SockID;</div><div class="line">_i16 Status;</div><div class="line">_i8 Buf[RECV_BUF_LEN];</div><div class="line"></div><div class="line">LocalAddr.sin_family = SL_AF_INET;</div><div class="line">LocalAddr.sin_port = <a class="code" href="group___socket.html#gadfb6f98e5c75a46050780e8afbae13bd">sl_Htons</a>(5001);</div><div class="line">LocalAddr.sin_addr.s_addr = 0;</div><div class="line"></div><div class="line">SockID = <a class="code" href="group___socket.html#gaa775fcb6d09bf35b9dac3e5eb8e8c997">sl_Socket</a>(SL_AF_INET,SL_SOCK_DGRAM, 0);</div><div class="line">Status = <a class="code" href="group___socket.html#gadcb0c4792127dceb1feb3e9b87ab2094">sl_Bind</a>(SockID, (<a class="code" href="group___socket.html#struct_sl_sock_addr__t">SlSockAddr_t</a> *)&amp;LocalAddr, AddrSize);</div><div class="line">Status = <a class="code" href="group___socket.html#ga02f8b2eb34db39069a1385d4fce80eea">sl_RecvFrom</a>(SockID, Buf, 1472, 0, (<a class="code" href="group___socket.html#struct_sl_sock_addr__t">SlSockAddr_t</a> *)&amp;Addr, (SlSocklen_t*)&amp;AddrSize);</div></div><!-- fragment --> </li>
</ul>

<p>Definition at line <a class="el" href="sl__socket_8c_source.html#l00367">367</a> of file <a class="el" href="sl__socket_8c_source.html">sl_socket.c</a>.</p>
<div class="fragment"><div class="line"><a name="l00368"></a><span class="lineno">  368</span>&#160;{</div><div class="line"><a name="l00369"></a><span class="lineno">  369</span>&#160;    _SlRecvfromMsg_u    Msg;</div><div class="line"><a name="l00370"></a><span class="lineno">  370</span>&#160;    <a class="code" href="struct___sl_cmd_ext__t.html">_SlCmdExt_t</a>         CmdExt;</div><div class="line"><a name="l00371"></a><span class="lineno">  371</span>&#160;    _i16                RetVal;</div><div class="line"><a name="l00372"></a><span class="lineno">  372</span>&#160;</div><div class="line"><a name="l00373"></a><span class="lineno">  373</span>&#160;    <span class="comment">/* verify that this api is allowed. if not allowed then</span></div><div class="line"><a name="l00374"></a><span class="lineno">  374</span>&#160;<span class="comment">    ignore the API execution and return immediately with an error */</span></div><div class="line"><a name="l00375"></a><span class="lineno">  375</span>&#160;    VERIFY_API_ALLOWED(SL_OPCODE_SILO_SOCKET);</div><div class="line"><a name="l00376"></a><span class="lineno">  376</span>&#160;</div><div class="line"><a name="l00377"></a><span class="lineno">  377</span>&#160;    <span class="comment">/* RAW transceiver use only sl_Recv  */</span></div><div class="line"><a name="l00378"></a><span class="lineno">  378</span>&#160;    <span class="keywordflow">if</span> ((sd &amp; SL_SOCKET_PAYLOAD_TYPE_MASK) == SL_SOCKET_PAYLOAD_TYPE_RAW_TRANCEIVER)</div><div class="line"><a name="l00379"></a><span class="lineno">  379</span>&#160;    {</div><div class="line"><a name="l00380"></a><span class="lineno">  380</span>&#160;        <span class="keywordflow">return</span> SL_ERROR_BSD_SOC_ERROR;</div><div class="line"><a name="l00381"></a><span class="lineno">  381</span>&#160;    }</div><div class="line"><a name="l00382"></a><span class="lineno">  382</span>&#160;</div><div class="line"><a name="l00383"></a><span class="lineno">  383</span>&#160;    _SlDrvResetCmdExt(&amp;CmdExt);</div><div class="line"><a name="l00384"></a><span class="lineno">  384</span>&#160;    CmdExt.RxPayloadLen = Len;</div><div class="line"><a name="l00385"></a><span class="lineno">  385</span>&#160;    CmdExt.pRxPayload = (_u8 *)buf;</div><div class="line"><a name="l00386"></a><span class="lineno">  386</span>&#160;</div><div class="line"><a name="l00387"></a><span class="lineno">  387</span>&#160;    Msg.Cmd.Sd = (_u8)sd;</div><div class="line"><a name="l00388"></a><span class="lineno">  388</span>&#160;    Msg.Cmd.StatusOrLen = (_u16)Len;</div><div class="line"><a name="l00389"></a><span class="lineno">  389</span>&#160;    </div><div class="line"><a name="l00390"></a><span class="lineno">  390</span>&#160;    <span class="comment">/*  no size truncation in recv path */</span></div><div class="line"><a name="l00391"></a><span class="lineno">  391</span>&#160;    CmdExt.RxPayloadLen = (_i16)Msg.Cmd.StatusOrLen;</div><div class="line"><a name="l00392"></a><span class="lineno">  392</span>&#160;</div><div class="line"><a name="l00393"></a><span class="lineno">  393</span>&#160;    Msg.Cmd.FamilyAndFlags = (_u8)(flags &amp; 0x0F);</div><div class="line"><a name="l00394"></a><span class="lineno">  394</span>&#160;</div><div class="line"><a name="l00395"></a><span class="lineno">  395</span>&#160;    <span class="keywordflow">if</span>(<span class="keyword">sizeof</span>(<a class="code" href="group___socket.html#struct_sl_sock_addr_in__t">SlSockAddrIn_t</a>) == *fromlen)</div><div class="line"><a name="l00396"></a><span class="lineno">  396</span>&#160;    {</div><div class="line"><a name="l00397"></a><span class="lineno">  397</span>&#160;        Msg.Cmd.FamilyAndFlags |= (SL_AF_INET &lt;&lt; 4);</div><div class="line"><a name="l00398"></a><span class="lineno">  398</span>&#160;    }</div><div class="line"><a name="l00399"></a><span class="lineno">  399</span>&#160;    <span class="keywordflow">else</span> <span class="keywordflow">if</span> (<span class="keyword">sizeof</span>(<a class="code" href="group___socket.html#struct_sl_sock_addr_in6__t">SlSockAddrIn6_t</a>) == *fromlen)</div><div class="line"><a name="l00400"></a><span class="lineno">  400</span>&#160;    {</div><div class="line"><a name="l00401"></a><span class="lineno">  401</span>&#160;        Msg.Cmd.FamilyAndFlags |= (SL_AF_INET6 &lt;&lt; 4);</div><div class="line"><a name="l00402"></a><span class="lineno">  402</span>&#160;    }</div><div class="line"><a name="l00403"></a><span class="lineno">  403</span>&#160;    <span class="keywordflow">else</span></div><div class="line"><a name="l00404"></a><span class="lineno">  404</span>&#160;    {</div><div class="line"><a name="l00405"></a><span class="lineno">  405</span>&#160;        <span class="keywordflow">return</span> SL_RET_CODE_INVALID_INPUT;</div><div class="line"><a name="l00406"></a><span class="lineno">  406</span>&#160;    }</div><div class="line"><a name="l00407"></a><span class="lineno">  407</span>&#160;</div><div class="line"><a name="l00408"></a><span class="lineno">  408</span>&#160;    RetVal = _SlDrvDataReadOp((_SlSd_t)sd, (<a class="code" href="struct___sl_cmd_ctrl__t.html">_SlCmdCtrl_t</a> *)&amp;_SlRecvfomCmdCtrl, &amp;Msg, &amp;CmdExt);</div><div class="line"><a name="l00409"></a><span class="lineno">  409</span>&#160;    <span class="keywordflow">if</span>( RetVal != SL_OS_RET_CODE_OK )</div><div class="line"><a name="l00410"></a><span class="lineno">  410</span>&#160;    {</div><div class="line"><a name="l00411"></a><span class="lineno">  411</span>&#160;        <span class="keywordflow">return</span> RetVal;</div><div class="line"><a name="l00412"></a><span class="lineno">  412</span>&#160;    }</div><div class="line"><a name="l00413"></a><span class="lineno">  413</span>&#160;</div><div class="line"><a name="l00414"></a><span class="lineno">  414</span>&#160;    RetVal = Msg.Rsp.IpV4.StatusOrLen;</div><div class="line"><a name="l00415"></a><span class="lineno">  415</span>&#160;</div><div class="line"><a name="l00416"></a><span class="lineno">  416</span>&#160;    <span class="keywordflow">if</span>(RetVal &gt;= 0)</div><div class="line"><a name="l00417"></a><span class="lineno">  417</span>&#160;    {</div><div class="line"><a name="l00418"></a><span class="lineno">  418</span>&#160;        VERIFY_PROTOCOL(sd == (_i16)Msg.Rsp.IpV4.Sd);</div><div class="line"><a name="l00419"></a><span class="lineno">  419</span>&#160;<span class="preprocessor">#if 0</span></div><div class="line"><a name="l00420"></a><span class="lineno">  420</span>&#160;        _SlSocketParseAddress(&amp;Msg.Rsp, from, fromlen);</div><div class="line"><a name="l00421"></a><span class="lineno">  421</span>&#160;<span class="preprocessor">#else</span></div><div class="line"><a name="l00422"></a><span class="lineno">  422</span>&#160;        from-&gt;sa_family = Msg.Rsp.IpV4.Family;</div><div class="line"><a name="l00423"></a><span class="lineno">  423</span>&#160;        <span class="keywordflow">if</span>(SL_AF_INET == from-&gt;sa_family)</div><div class="line"><a name="l00424"></a><span class="lineno">  424</span>&#160;        {</div><div class="line"><a name="l00425"></a><span class="lineno">  425</span>&#160;            ((<a class="code" href="group___socket.html#struct_sl_sock_addr_in__t">SlSockAddrIn_t</a> *)from)-&gt;sin_port = Msg.Rsp.IpV4.Port;</div><div class="line"><a name="l00426"></a><span class="lineno">  426</span>&#160;            ((<a class="code" href="group___socket.html#struct_sl_sock_addr_in__t">SlSockAddrIn_t</a> *)from)-&gt;sin_addr.s_addr = Msg.Rsp.IpV4.Address;</div><div class="line"><a name="l00427"></a><span class="lineno">  427</span>&#160;            *fromlen = (SlSocklen_t)<span class="keyword">sizeof</span>(<a class="code" href="group___socket.html#struct_sl_sock_addr_in__t">SlSockAddrIn_t</a>);</div><div class="line"><a name="l00428"></a><span class="lineno">  428</span>&#160;        }</div><div class="line"><a name="l00429"></a><span class="lineno">  429</span>&#160;<span class="preprocessor">#ifdef SL_SUPPORT_IPV6</span></div><div class="line"><a name="l00430"></a><span class="lineno">  430</span>&#160;        <span class="keywordflow">else</span> <span class="keywordflow">if</span>(SL_AF_INET6 == from-&gt;sa_family)</div><div class="line"><a name="l00431"></a><span class="lineno">  431</span>&#160;        {</div><div class="line"><a name="l00432"></a><span class="lineno">  432</span>&#160;            VERIFY_PROTOCOL(*fromlen &gt;= <span class="keyword">sizeof</span>(<a class="code" href="group___socket.html#struct_sl_sock_addr_in6__t">SlSockAddrIn6_t</a>));</div><div class="line"><a name="l00433"></a><span class="lineno">  433</span>&#160;</div><div class="line"><a name="l00434"></a><span class="lineno">  434</span>&#160;            ((<a class="code" href="group___socket.html#struct_sl_sock_addr_in6__t">SlSockAddrIn6_t</a> *)from)-&gt;sin6_port = Msg.Rsp.IpV6.Port;</div><div class="line"><a name="l00435"></a><span class="lineno">  435</span>&#160;            sl_Memcpy(((<a class="code" href="group___socket.html#struct_sl_sock_addr_in6__t">SlSockAddrIn6_t</a> *)from)-&gt;sin6_addr._S6_un._S6_u32, Msg.Rsp.IpV6.Address, 16);</div><div class="line"><a name="l00436"></a><span class="lineno">  436</span>&#160;            *fromlen = <span class="keyword">sizeof</span>(<a class="code" href="group___socket.html#struct_sl_sock_addr_in6__t">SlSockAddrIn6_t</a>);</div><div class="line"><a name="l00437"></a><span class="lineno">  437</span>&#160;        }</div><div class="line"><a name="l00438"></a><span class="lineno">  438</span>&#160;<span class="preprocessor">#endif</span></div><div class="line"><a name="l00439"></a><span class="lineno">  439</span>&#160;<span class="preprocessor">#endif</span></div><div class="line"><a name="l00440"></a><span class="lineno">  440</span>&#160;    }</div><div class="line"><a name="l00441"></a><span class="lineno">  441</span>&#160;</div><div class="line"><a name="l00442"></a><span class="lineno">  442</span>&#160;    <span class="keywordflow">return</span> (_i16)RetVal;</div><div class="line"><a name="l00443"></a><span class="lineno">  443</span>&#160;}</div><div class="ttc" id="group___socket_html_struct_sl_sock_addr_in6__t"><div class="ttname"><a href="group___socket.html#struct_sl_sock_addr_in6__t">SlSockAddrIn6_t</a></div><div class="ttdef"><b>Definition:</b> <a href="sl__socket_8h_source.html#l00393">sl_socket.h:393</a></div></div>
<div class="ttc" id="struct___sl_cmd_ctrl__t_html"><div class="ttname"><a href="struct___sl_cmd_ctrl__t.html">_SlCmdCtrl_t</a></div><div class="ttdef"><b>Definition:</b> <a href="driver_8h_source.html#l00179">driver.h:179</a></div></div>
<div class="ttc" id="struct___sl_cmd_ext__t_html"><div class="ttname"><a href="struct___sl_cmd_ext__t.html">_SlCmdExt_t</a></div><div class="ttdef"><b>Definition:</b> <a href="driver_8h_source.html#l00186">driver.h:186</a></div></div>
<div class="ttc" id="group___socket_html_struct_sl_sock_addr_in__t"><div class="ttname"><a href="group___socket.html#struct_sl_sock_addr_in__t">SlSockAddrIn_t</a></div><div class="ttdef"><b>Definition:</b> <a href="sl__socket_8h_source.html#l00404">sl_socket.h:404</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="ga97747fea9f469feeb7272b76e4fe9a0e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga97747fea9f469feeb7272b76e4fe9a0e">&sect;&nbsp;</a></span>sl_Select()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">_i16 sl_Select </td>
          <td>(</td>
          <td class="paramtype">_i16&#160;</td>
          <td class="paramname"><em>nfds</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___socket.html#struct_sl_fd_set__t">SlFdSet_t</a> *&#160;</td>
          <td class="paramname"><em>readsds</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___socket.html#struct_sl_fd_set__t">SlFdSet_t</a> *&#160;</td>
          <td class="paramname"><em>writesds</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___socket.html#struct_sl_fd_set__t">SlFdSet_t</a> *&#160;</td>
          <td class="paramname"><em>exceptsds</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="group___socket.html#struct_sl_timeval__t">SlTimeval_t</a> *&#160;</td>
          <td class="paramname"><em>timeout</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Monitor socket activity. </p>
<p>Select allow a program to monitor multiple file descriptors, waiting until one or more of the file descriptors become "ready" for some class of I/O operation. If trigger mode is enabled the active fdset is the one that was retrieved in the first triggered call. To enable the trigger mode, an handler must be statically registered as slcb_SocketTriggerEventHandler in <a class="el" href="user_8h_source.html">user.h</a></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">nfds</td><td>The highest-numbered file descriptor in any of the three sets, plus 1. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">readsds</td><td>Socket descriptors list for read monitoring and accept monitoring </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">writesds</td><td>Socket descriptors list for connect monitoring only, write monitoring is not supported </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">exceptsds</td><td>Socket descriptors list for exception monitoring, not supported. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">timeout</td><td>Is an upper bound on the amount of time elapsed before <a class="el" href="group___b_s_d___socket.html#gabe92cff4414f58438af2502fae12121a" title="Monitor socket activity. ">select()</a> returns. Null or above 0xffff seconds means infinity timeout. The minimum timeout is 10 milliseconds, less than 10 milliseconds will be set automatically to 10 milliseconds. Max microseconds supported is 0xfffc00. In trigger mode the timout fields must be set to zero.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>On success, <a class="el" href="group___b_s_d___socket.html#gabe92cff4414f58438af2502fae12121a" title="Monitor socket activity. ">select()</a> returns the number of file descriptors contained in the three returned descriptor sets (that is, the total number of bits that are set in readfds, writefds, exceptfds) which may be zero if the timeout expires before anything interesting happens.<br />
 On error, a negative value is returned. readsds - return the sockets on which read request will return without delay with valid data.<br />
 writesds - return the sockets on which write request will return without delay.<br />
 exceptsds - return the sockets closed recently. <br />
 SL_POOL_IS_EMPTY may be return in case there are no resources in the system In this case try again later or increase MAX_CONCURRENT_ACTIONS</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group___socket.html#gaa775fcb6d09bf35b9dac3e5eb8e8c997" title="Create an endpoint for communication. ">sl_Socket</a> </dd></dl>
<dl class="section note"><dt>Note</dt><dd>If the timeout value set to less than 10ms it will automatically set to 10ms to prevent overload of the system<br />
 Belongs to basic_api</dd></dl>
<p>Several threads can call sl_Select at the same time.<b>Calling</b> this API while the same command is called from another thread, may result in one of the following scenarios:</p><ol type="1">
<li>The command will be executed alongside other select callers (success).</li>
<li>The command will wait (internal) until the previous sl_select finish, and then be executed.</li>
<li>There are not enough resources and SL_POOL_IS_EMPTY error will return. In this case, MAX_CONCURRENT_ACTIONS can be increased (result in memory increase) or try again later to issue the command.</li>
</ol>
<p>In case all the user sockets are open, sl_Select will exhibit the behaviour mentioned in (2) This is due to the fact sl_select supports multiple callers by utilizing one user socket internally. User who wish to ensure multiple select calls at any given time, must reserve one socket out of the 16 given.</p>
<dl class="section warning"><dt>Warning</dt><dd>multiple select calls aren't supported when trigger mode is active. The two are mutually exclusive. </dd></dl>

<p>Definition at line <a class="el" href="sl__socket_8c_source.html#l01707">1707</a> of file <a class="el" href="sl__socket_8c_source.html">sl_socket.c</a>.</p>
<div class="fragment"><div class="line"><a name="l01708"></a><span class="lineno"> 1708</span>&#160;{</div><div class="line"><a name="l01709"></a><span class="lineno"> 1709</span>&#160;    _SlSelectMsg_u            Msg;</div><div class="line"><a name="l01710"></a><span class="lineno"> 1710</span>&#160;    <a class="code" href="struct_sl_select_async_response__t.html">SlSelectAsyncResponse_t</a>   AsyncRsp;</div><div class="line"><a name="l01711"></a><span class="lineno"> 1711</span>&#160;    _u8                       ObjIdx = MAX_CONCURRENT_ACTIONS;</div><div class="line"><a name="l01712"></a><span class="lineno"> 1712</span>&#160;<span class="preprocessor">#if ((defined(SL_RUNTIME_EVENT_REGISTERATION) || defined(slcb_SocketTriggerEventHandler)))</span></div><div class="line"><a name="l01713"></a><span class="lineno"> 1713</span>&#160;    _u8                       IsNonBlocking = FALSE;</div><div class="line"><a name="l01714"></a><span class="lineno"> 1714</span>&#160;<span class="preprocessor">#endif</span></div><div class="line"><a name="l01715"></a><span class="lineno"> 1715</span>&#160;</div><div class="line"><a name="l01716"></a><span class="lineno"> 1716</span>&#160;    <span class="comment">/* verify that this API is allowed. if not allowed then</span></div><div class="line"><a name="l01717"></a><span class="lineno"> 1717</span>&#160;<span class="comment">    ignore the API execution and return immediately with an error */</span></div><div class="line"><a name="l01718"></a><span class="lineno"> 1718</span>&#160;    VERIFY_API_ALLOWED(SL_OPCODE_SILO_SOCKET);</div><div class="line"><a name="l01719"></a><span class="lineno"> 1719</span>&#160;</div><div class="line"><a name="l01720"></a><span class="lineno"> 1720</span>&#160;<span class="preprocessor">#if ((defined(SL_RUNTIME_EVENT_REGISTERATION) || defined(slcb_SocketTriggerEventHandler)))</span></div><div class="line"><a name="l01721"></a><span class="lineno"> 1721</span>&#160;    <span class="keywordflow">if</span>(1 == _SlIsEventRegistered(SL_EVENT_HDL_SOCKET_TRIGGER))</div><div class="line"><a name="l01722"></a><span class="lineno"> 1722</span>&#160;    {</div><div class="line"><a name="l01723"></a><span class="lineno"> 1723</span>&#160;        <span class="keywordflow">if</span>( NULL != timeout )</div><div class="line"><a name="l01724"></a><span class="lineno"> 1724</span>&#160;        {</div><div class="line"><a name="l01725"></a><span class="lineno"> 1725</span>&#160;            <span class="comment">/* Set that we are in Non-Blocking mode */</span></div><div class="line"><a name="l01726"></a><span class="lineno"> 1726</span>&#160;            <span class="keywordflow">if</span> ( (0 == timeout-&gt;tv_sec) &amp;&amp; (0 == timeout-&gt;tv_usec) )</div><div class="line"><a name="l01727"></a><span class="lineno"> 1727</span>&#160;            {</div><div class="line"><a name="l01728"></a><span class="lineno"> 1728</span>&#160;                IsNonBlocking = TRUE;</div><div class="line"><a name="l01729"></a><span class="lineno"> 1729</span>&#160;            }</div><div class="line"><a name="l01730"></a><span class="lineno"> 1730</span>&#160;            <span class="keywordflow">else</span></div><div class="line"><a name="l01731"></a><span class="lineno"> 1731</span>&#160;            {</div><div class="line"><a name="l01732"></a><span class="lineno"> 1732</span>&#160;                SL_DRV_PROTECTION_OBJ_LOCK_FOREVER();</div><div class="line"><a name="l01733"></a><span class="lineno"> 1733</span>&#160;</div><div class="line"><a name="l01734"></a><span class="lineno"> 1734</span>&#160;                <span class="comment">/* If there is a trigger select running in the progress abort the new blocking request */</span></div><div class="line"><a name="l01735"></a><span class="lineno"> 1735</span>&#160;                <span class="keywordflow">if</span> (g_pCB-&gt;SocketTriggerSelect.Info.State &gt; SOCK_TRIGGER_READY)</div><div class="line"><a name="l01736"></a><span class="lineno"> 1736</span>&#160;                {</div><div class="line"><a name="l01737"></a><span class="lineno"> 1737</span>&#160;                    SL_DRV_PROTECTION_OBJ_UNLOCK();</div><div class="line"><a name="l01738"></a><span class="lineno"> 1738</span>&#160;                    <span class="keywordflow">return</span> SL_RET_CODE_SOCKET_SELECT_IN_PROGRESS_ERROR;</div><div class="line"><a name="l01739"></a><span class="lineno"> 1739</span>&#160;                }</div><div class="line"><a name="l01740"></a><span class="lineno"> 1740</span>&#160;</div><div class="line"><a name="l01741"></a><span class="lineno"> 1741</span>&#160;                SL_DRV_PROTECTION_OBJ_UNLOCK();</div><div class="line"><a name="l01742"></a><span class="lineno"> 1742</span>&#160;            }</div><div class="line"><a name="l01743"></a><span class="lineno"> 1743</span>&#160;</div><div class="line"><a name="l01744"></a><span class="lineno"> 1744</span>&#160;            <span class="keywordflow">if</span> (IsNonBlocking == TRUE)</div><div class="line"><a name="l01745"></a><span class="lineno"> 1745</span>&#160;            {</div><div class="line"><a name="l01746"></a><span class="lineno"> 1746</span>&#160;                <span class="comment">/* return EAGAIN if we alreay have select trigger in progress */</span></div><div class="line"><a name="l01747"></a><span class="lineno"> 1747</span>&#160;                <span class="keywordflow">if</span> (g_pCB-&gt;SocketTriggerSelect.Info.State == SOCK_TRIGGER_WAITING_FOR_RESP)</div><div class="line"><a name="l01748"></a><span class="lineno"> 1748</span>&#160;                {</div><div class="line"><a name="l01749"></a><span class="lineno"> 1749</span>&#160;                    <span class="keywordflow">return</span> SL_ERROR_BSD_EAGAIN;</div><div class="line"><a name="l01750"></a><span class="lineno"> 1750</span>&#160;                }</div><div class="line"><a name="l01751"></a><span class="lineno"> 1751</span>&#160;                <span class="comment">/* return the stored response if already received */</span></div><div class="line"><a name="l01752"></a><span class="lineno"> 1752</span>&#160;                <span class="keywordflow">else</span> <span class="keywordflow">if</span> (g_pCB-&gt;SocketTriggerSelect.Info.State == SOCK_TRIGGER_RESP_RECEIVED)</div><div class="line"><a name="l01753"></a><span class="lineno"> 1753</span>&#160;                {</div><div class="line"><a name="l01754"></a><span class="lineno"> 1754</span>&#160;                    <span class="keywordflow">if</span>(  ((_i16)g_pCB-&gt;SocketTriggerSelect.Resp.Status) &gt;= 0 )</div><div class="line"><a name="l01755"></a><span class="lineno"> 1755</span>&#160;                    {</div><div class="line"><a name="l01756"></a><span class="lineno"> 1756</span>&#160;                        <span class="keywordflow">if</span>( readsds )</div><div class="line"><a name="l01757"></a><span class="lineno"> 1757</span>&#160;                        {</div><div class="line"><a name="l01758"></a><span class="lineno"> 1758</span>&#160;                            readsds-&gt;fd_array[0]  = g_pCB-&gt;SocketTriggerSelect.Resp.ReadFds;</div><div class="line"><a name="l01759"></a><span class="lineno"> 1759</span>&#160;                        }</div><div class="line"><a name="l01760"></a><span class="lineno"> 1760</span>&#160;                        <span class="keywordflow">if</span>( writesds )</div><div class="line"><a name="l01761"></a><span class="lineno"> 1761</span>&#160;                        {</div><div class="line"><a name="l01762"></a><span class="lineno"> 1762</span>&#160;                            writesds-&gt;fd_array[0] = g_pCB-&gt;SocketTriggerSelect.Resp.WriteFds;</div><div class="line"><a name="l01763"></a><span class="lineno"> 1763</span>&#160;                        }</div><div class="line"><a name="l01764"></a><span class="lineno"> 1764</span>&#160;                    }</div><div class="line"><a name="l01765"></a><span class="lineno"> 1765</span>&#160;</div><div class="line"><a name="l01766"></a><span class="lineno"> 1766</span>&#160;                    <span class="comment">/* Now relaese the pool object */</span></div><div class="line"><a name="l01767"></a><span class="lineno"> 1767</span>&#160;                    _SlDrvReleasePoolObj(g_pCB-&gt;SocketTriggerSelect.Info.ObjPoolIdx);</div><div class="line"><a name="l01768"></a><span class="lineno"> 1768</span>&#160;</div><div class="line"><a name="l01769"></a><span class="lineno"> 1769</span>&#160;                    g_pCB-&gt;SocketTriggerSelect.Info.ObjPoolIdx = MAX_CONCURRENT_ACTIONS;</div><div class="line"><a name="l01770"></a><span class="lineno"> 1770</span>&#160;</div><div class="line"><a name="l01771"></a><span class="lineno"> 1771</span>&#160;                    <span class="comment">/* Reset the socket select trigger object */</span></div><div class="line"><a name="l01772"></a><span class="lineno"> 1772</span>&#160;                    g_pCB-&gt;SocketTriggerSelect.Info.State = SOCK_TRIGGER_READY;</div><div class="line"><a name="l01773"></a><span class="lineno"> 1773</span>&#160;</div><div class="line"><a name="l01774"></a><span class="lineno"> 1774</span>&#160;                    <span class="keywordflow">return</span> (_i16)g_pCB-&gt;SocketTriggerSelect.Resp.Status;</div><div class="line"><a name="l01775"></a><span class="lineno"> 1775</span>&#160;                }</div><div class="line"><a name="l01776"></a><span class="lineno"> 1776</span>&#160;            }</div><div class="line"><a name="l01777"></a><span class="lineno"> 1777</span>&#160;        }</div><div class="line"><a name="l01778"></a><span class="lineno"> 1778</span>&#160;    }</div><div class="line"><a name="l01779"></a><span class="lineno"> 1779</span>&#160;<span class="preprocessor">#endif</span></div><div class="line"><a name="l01780"></a><span class="lineno"> 1780</span>&#160;</div><div class="line"><a name="l01781"></a><span class="lineno"> 1781</span>&#160;    Msg.Cmd.Nfds          = (_u8)nfds;</div><div class="line"><a name="l01782"></a><span class="lineno"> 1782</span>&#160;    Msg.Cmd.ReadFdsCount  = 0;</div><div class="line"><a name="l01783"></a><span class="lineno"> 1783</span>&#160;    Msg.Cmd.WriteFdsCount = 0;</div><div class="line"><a name="l01784"></a><span class="lineno"> 1784</span>&#160;</div><div class="line"><a name="l01785"></a><span class="lineno"> 1785</span>&#160;    Msg.Cmd.ReadFds  = 0;</div><div class="line"><a name="l01786"></a><span class="lineno"> 1786</span>&#160;    Msg.Cmd.WriteFds = 0;</div><div class="line"><a name="l01787"></a><span class="lineno"> 1787</span>&#160;</div><div class="line"><a name="l01788"></a><span class="lineno"> 1788</span>&#160;</div><div class="line"><a name="l01789"></a><span class="lineno"> 1789</span>&#160;    <span class="keywordflow">if</span>( readsds )</div><div class="line"><a name="l01790"></a><span class="lineno"> 1790</span>&#160;    {</div><div class="line"><a name="l01791"></a><span class="lineno"> 1791</span>&#160;        Msg.Cmd.ReadFds = (_u16)readsds-&gt;fd_array[0];</div><div class="line"><a name="l01792"></a><span class="lineno"> 1792</span>&#160;    }</div><div class="line"><a name="l01793"></a><span class="lineno"> 1793</span>&#160;    <span class="keywordflow">if</span>( writesds )</div><div class="line"><a name="l01794"></a><span class="lineno"> 1794</span>&#160;    {</div><div class="line"><a name="l01795"></a><span class="lineno"> 1795</span>&#160;        Msg.Cmd.WriteFds = (_u16)writesds-&gt;fd_array[0];</div><div class="line"><a name="l01796"></a><span class="lineno"> 1796</span>&#160;    }</div><div class="line"><a name="l01797"></a><span class="lineno"> 1797</span>&#160;    <span class="keywordflow">if</span>( NULL == timeout )</div><div class="line"><a name="l01798"></a><span class="lineno"> 1798</span>&#160;    {</div><div class="line"><a name="l01799"></a><span class="lineno"> 1799</span>&#160;        Msg.Cmd.tv_sec = 0xffff;</div><div class="line"><a name="l01800"></a><span class="lineno"> 1800</span>&#160;        Msg.Cmd.tv_usec = 0xffff;</div><div class="line"><a name="l01801"></a><span class="lineno"> 1801</span>&#160;    }</div><div class="line"><a name="l01802"></a><span class="lineno"> 1802</span>&#160;    <span class="keywordflow">else</span></div><div class="line"><a name="l01803"></a><span class="lineno"> 1803</span>&#160;    {</div><div class="line"><a name="l01804"></a><span class="lineno"> 1804</span>&#160;        <span class="keywordflow">if</span>( 0xffff &lt;= timeout-&gt;tv_sec )</div><div class="line"><a name="l01805"></a><span class="lineno"> 1805</span>&#160;        {</div><div class="line"><a name="l01806"></a><span class="lineno"> 1806</span>&#160;            Msg.Cmd.tv_sec = 0xffff;</div><div class="line"><a name="l01807"></a><span class="lineno"> 1807</span>&#160;        }</div><div class="line"><a name="l01808"></a><span class="lineno"> 1808</span>&#160;        <span class="keywordflow">else</span></div><div class="line"><a name="l01809"></a><span class="lineno"> 1809</span>&#160;        {</div><div class="line"><a name="l01810"></a><span class="lineno"> 1810</span>&#160;            Msg.Cmd.tv_sec = (_u16)timeout-&gt;tv_sec;</div><div class="line"><a name="l01811"></a><span class="lineno"> 1811</span>&#160;        }</div><div class="line"><a name="l01812"></a><span class="lineno"> 1812</span>&#160;</div><div class="line"><a name="l01813"></a><span class="lineno"> 1813</span>&#160;        <span class="comment">/*  convert to milliseconds */</span></div><div class="line"><a name="l01814"></a><span class="lineno"> 1814</span>&#160;        timeout-&gt;tv_usec = timeout-&gt;tv_usec &gt;&gt; 10;</div><div class="line"><a name="l01815"></a><span class="lineno"> 1815</span>&#160;</div><div class="line"><a name="l01816"></a><span class="lineno"> 1816</span>&#160;        <span class="keywordflow">if</span>( 0xffff &lt;= timeout-&gt;tv_usec )</div><div class="line"><a name="l01817"></a><span class="lineno"> 1817</span>&#160;        {</div><div class="line"><a name="l01818"></a><span class="lineno"> 1818</span>&#160;            Msg.Cmd.tv_usec = 0xffff;</div><div class="line"><a name="l01819"></a><span class="lineno"> 1819</span>&#160;        }</div><div class="line"><a name="l01820"></a><span class="lineno"> 1820</span>&#160;        <span class="keywordflow">else</span></div><div class="line"><a name="l01821"></a><span class="lineno"> 1821</span>&#160;        {</div><div class="line"><a name="l01822"></a><span class="lineno"> 1822</span>&#160;            Msg.Cmd.tv_usec = (_u16)timeout-&gt;tv_usec;</div><div class="line"><a name="l01823"></a><span class="lineno"> 1823</span>&#160;        }</div><div class="line"><a name="l01824"></a><span class="lineno"> 1824</span>&#160;</div><div class="line"><a name="l01825"></a><span class="lineno"> 1825</span>&#160;    }</div><div class="line"><a name="l01826"></a><span class="lineno"> 1826</span>&#160;</div><div class="line"><a name="l01827"></a><span class="lineno"> 1827</span>&#160;    <span class="comment">/* Use Obj to issue the command, if not available try later */</span></div><div class="line"><a name="l01828"></a><span class="lineno"> 1828</span>&#160;    ObjIdx = _SlDrvProtectAsyncRespSetting((_u8*)&amp;AsyncRsp, SELECT_ID, SL_MAX_SOCKETS);</div><div class="line"><a name="l01829"></a><span class="lineno"> 1829</span>&#160;</div><div class="line"><a name="l01830"></a><span class="lineno"> 1830</span>&#160;    <span class="keywordflow">if</span> (MAX_CONCURRENT_ACTIONS == ObjIdx)</div><div class="line"><a name="l01831"></a><span class="lineno"> 1831</span>&#160;    {</div><div class="line"><a name="l01832"></a><span class="lineno"> 1832</span>&#160;        <span class="keywordflow">return</span> SL_POOL_IS_EMPTY;</div><div class="line"><a name="l01833"></a><span class="lineno"> 1833</span>&#160;    }</div><div class="line"><a name="l01834"></a><span class="lineno"> 1834</span>&#160;</div><div class="line"><a name="l01835"></a><span class="lineno"> 1835</span>&#160;    <span class="comment">/* send the command */</span></div><div class="line"><a name="l01836"></a><span class="lineno"> 1836</span>&#160;    VERIFY_RET_OK(_SlDrvCmdOp((<a class="code" href="struct___sl_cmd_ctrl__t.html">_SlCmdCtrl_t</a> *)&amp;_SlSelectCmdCtrl, &amp;Msg, NULL));</div><div class="line"><a name="l01837"></a><span class="lineno"> 1837</span>&#160;</div><div class="line"><a name="l01838"></a><span class="lineno"> 1838</span>&#160;    <span class="keywordflow">if</span>(SL_OS_RET_CODE_OK == (_i16)Msg.Rsp.status)</div><div class="line"><a name="l01839"></a><span class="lineno"> 1839</span>&#160;    {</div><div class="line"><a name="l01840"></a><span class="lineno"> 1840</span>&#160;        SL_DRV_SYNC_OBJ_WAIT_FOREVER(&amp;g_pCB-&gt;ObjPool[ObjIdx].SyncObj);</div><div class="line"><a name="l01841"></a><span class="lineno"> 1841</span>&#160;</div><div class="line"><a name="l01842"></a><span class="lineno"> 1842</span>&#160;        Msg.Rsp.status = (_i16)AsyncRsp.Status;</div><div class="line"><a name="l01843"></a><span class="lineno"> 1843</span>&#160;</div><div class="line"><a name="l01844"></a><span class="lineno"> 1844</span>&#160;        <span class="comment">/* this code handles the socket trigger mode case */</span></div><div class="line"><a name="l01845"></a><span class="lineno"> 1845</span>&#160;#<span class="keywordflow">if</span>((defined(SL_RUNTIME_EVENT_REGISTERATION) || defined(<a class="code" href="group___user_events.html#ga04243f2a6b6933fd551e475f6935fe65">slcb_SocketTriggerEventHandler</a>)))</div><div class="line"><a name="l01846"></a><span class="lineno"> 1846</span>&#160;        <span class="keywordflow">if</span>(1 == _SlIsEventRegistered(SL_EVENT_HDL_SOCKET_TRIGGER))</div><div class="line"><a name="l01847"></a><span class="lineno"> 1847</span>&#160;        {</div><div class="line"><a name="l01848"></a><span class="lineno"> 1848</span>&#160;            <span class="comment">/* if no data returned and we are in trigger mode,</span></div><div class="line"><a name="l01849"></a><span class="lineno"> 1849</span>&#160;<span class="comment">               send another select cmd but now with timeout infinite,</span></div><div class="line"><a name="l01850"></a><span class="lineno"> 1850</span>&#160;<span class="comment">               and return immediately with EAGAIN to the user */</span></div><div class="line"><a name="l01851"></a><span class="lineno"> 1851</span>&#160;            <span class="keywordflow">if</span> ((IsNonBlocking == TRUE) &amp;&amp; (AsyncRsp.Status == 0))</div><div class="line"><a name="l01852"></a><span class="lineno"> 1852</span>&#160;            {</div><div class="line"><a name="l01853"></a><span class="lineno"> 1853</span>&#160;                <span class="comment">/* set the select trigger-in-progress bit */</span></div><div class="line"><a name="l01854"></a><span class="lineno"> 1854</span>&#160;                g_pCB-&gt;SocketTriggerSelect.Info.State  = SOCK_TRIGGER_WAITING_FOR_RESP;</div><div class="line"><a name="l01855"></a><span class="lineno"> 1855</span>&#160;</div><div class="line"><a name="l01856"></a><span class="lineno"> 1856</span>&#160;                Msg.Cmd.tv_sec = 0xffff;</div><div class="line"><a name="l01857"></a><span class="lineno"> 1857</span>&#160;                Msg.Cmd.tv_usec = 0xffff;</div><div class="line"><a name="l01858"></a><span class="lineno"> 1858</span>&#160;</div><div class="line"><a name="l01859"></a><span class="lineno"> 1859</span>&#160;                <span class="comment">/* Release pool object and try to take another call */</span></div><div class="line"><a name="l01860"></a><span class="lineno"> 1860</span>&#160;                _SlDrvReleasePoolObj(ObjIdx);</div><div class="line"><a name="l01861"></a><span class="lineno"> 1861</span>&#160;</div><div class="line"><a name="l01862"></a><span class="lineno"> 1862</span>&#160;                <span class="comment">/* Use Obj to issue the command, if not available try later */</span></div><div class="line"><a name="l01863"></a><span class="lineno"> 1863</span>&#160;                ObjIdx = _SlDrvProtectAsyncRespSetting((_u8*)&amp;g_pCB-&gt;SocketTriggerSelect.Resp, SELECT_ID, SL_MAX_SOCKETS);</div><div class="line"><a name="l01864"></a><span class="lineno"> 1864</span>&#160;</div><div class="line"><a name="l01865"></a><span class="lineno"> 1865</span>&#160;                <span class="keywordflow">if</span> (MAX_CONCURRENT_ACTIONS == ObjIdx)</div><div class="line"><a name="l01866"></a><span class="lineno"> 1866</span>&#160;                {</div><div class="line"><a name="l01867"></a><span class="lineno"> 1867</span>&#160;                    <span class="keywordflow">return</span> SL_POOL_IS_EMPTY;</div><div class="line"><a name="l01868"></a><span class="lineno"> 1868</span>&#160;                }</div><div class="line"><a name="l01869"></a><span class="lineno"> 1869</span>&#160;</div><div class="line"><a name="l01870"></a><span class="lineno"> 1870</span>&#160;                <span class="comment">/* Save the pool index to be released only after the user read the response  */</span></div><div class="line"><a name="l01871"></a><span class="lineno"> 1871</span>&#160;                g_pCB-&gt;SocketTriggerSelect.Info.ObjPoolIdx = ObjIdx;</div><div class="line"><a name="l01872"></a><span class="lineno"> 1872</span>&#160;</div><div class="line"><a name="l01873"></a><span class="lineno"> 1873</span>&#160;                <span class="comment">/* send the command */</span></div><div class="line"><a name="l01874"></a><span class="lineno"> 1874</span>&#160;                VERIFY_RET_OK(_SlDrvCmdOp((<a class="code" href="struct___sl_cmd_ctrl__t.html">_SlCmdCtrl_t</a> *)&amp;_SlSelectCmdCtrl, &amp;Msg, NULL));</div><div class="line"><a name="l01875"></a><span class="lineno"> 1875</span>&#160;                <span class="keywordflow">return</span> SL_ERROR_BSD_EAGAIN;</div><div class="line"><a name="l01876"></a><span class="lineno"> 1876</span>&#160;</div><div class="line"><a name="l01877"></a><span class="lineno"> 1877</span>&#160;            }</div><div class="line"><a name="l01878"></a><span class="lineno"> 1878</span>&#160;        }</div><div class="line"><a name="l01879"></a><span class="lineno"> 1879</span>&#160;<span class="preprocessor">#endif</span></div><div class="line"><a name="l01880"></a><span class="lineno"> 1880</span>&#160;</div><div class="line"><a name="l01881"></a><span class="lineno"> 1881</span>&#160;        <span class="keywordflow">if</span>(  ((_i16)Msg.Rsp.status) &gt;= 0 )</div><div class="line"><a name="l01882"></a><span class="lineno"> 1882</span>&#160;        {</div><div class="line"><a name="l01883"></a><span class="lineno"> 1883</span>&#160;            <span class="keywordflow">if</span>( readsds )</div><div class="line"><a name="l01884"></a><span class="lineno"> 1884</span>&#160;            {</div><div class="line"><a name="l01885"></a><span class="lineno"> 1885</span>&#160;                readsds-&gt;fd_array[0]  = AsyncRsp.ReadFds;</div><div class="line"><a name="l01886"></a><span class="lineno"> 1886</span>&#160;            }</div><div class="line"><a name="l01887"></a><span class="lineno"> 1887</span>&#160;            <span class="keywordflow">if</span>( writesds )</div><div class="line"><a name="l01888"></a><span class="lineno"> 1888</span>&#160;            {</div><div class="line"><a name="l01889"></a><span class="lineno"> 1889</span>&#160;                writesds-&gt;fd_array[0] = AsyncRsp.WriteFds;</div><div class="line"><a name="l01890"></a><span class="lineno"> 1890</span>&#160;            }</div><div class="line"><a name="l01891"></a><span class="lineno"> 1891</span>&#160;        }</div><div class="line"><a name="l01892"></a><span class="lineno"> 1892</span>&#160;    }</div><div class="line"><a name="l01893"></a><span class="lineno"> 1893</span>&#160;</div><div class="line"><a name="l01894"></a><span class="lineno"> 1894</span>&#160;    _SlDrvReleasePoolObj(ObjIdx);</div><div class="line"><a name="l01895"></a><span class="lineno"> 1895</span>&#160;    <span class="keywordflow">return</span> (_i16)Msg.Rsp.status;</div><div class="line"><a name="l01896"></a><span class="lineno"> 1896</span>&#160;}</div><div class="ttc" id="group___user_events_html_ga04243f2a6b6933fd551e475f6935fe65"><div class="ttname"><a href="group___user_events.html#ga04243f2a6b6933fd551e475f6935fe65">slcb_SocketTriggerEventHandler</a></div><div class="ttdeci">void slcb_SocketTriggerEventHandler(SlSockTriggerEvent_t *pSlSockTriggerEvent)</div><div class="ttdoc">Socket trigger routine. This routine will notify the application that a netwrok activity has been com...</div></div>
<div class="ttc" id="struct___sl_cmd_ctrl__t_html"><div class="ttname"><a href="struct___sl_cmd_ctrl__t.html">_SlCmdCtrl_t</a></div><div class="ttdef"><b>Definition:</b> <a href="driver_8h_source.html#l00179">driver.h:179</a></div></div>
<div class="ttc" id="struct_sl_select_async_response__t_html"><div class="ttname"><a href="struct_sl_select_async_response__t.html">SlSelectAsyncResponse_t</a></div><div class="ttdef"><b>Definition:</b> <a href="protocol_8h_source.html#l00846">protocol.h:846</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="ga2fc8c293bbcb796217076329e1bac518"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2fc8c293bbcb796217076329e1bac518">&sect;&nbsp;</a></span>sl_Send()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">_i16 sl_Send </td>
          <td>(</td>
          <td class="paramtype">_i16&#160;</td>
          <td class="paramname"><em>sd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_i16&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_i16&#160;</td>
          <td class="paramname"><em>flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write data to TCP socket. </p>
<p>This function is used to transmit a message to another socket. Returns immediately after sending data to device. In case of TCP failure an async event SL_SOCKET_TX_FAILED_EVENT is going to be received.<br />
In case of a RAW socket (transceiver mode), extra 4 bytes should be reserved at the end of the frame data buffer for WLAN FCS</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">sd</td><td>Socket handle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">buf</td><td>Points to a buffer containing the message to be sent </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">len</td><td>Message size in bytes. Range: 1-1460 bytes </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">flags</td><td>Specifies the type of message transmission. On this version, this parameter is not supported for TCP. For transceiver mode, the SL_WLAN_RAW_RF_TX_PARAMS macro can be used to determine transmission parameters (channel,rate,tx_power,preamble)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Zero on success, or negative error code on failure</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group___socket.html#ga7ca76d181974c71673c3bf3fc1fedfdc" title="Write data to socket. ">sl_SendTo</a> </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Belongs to send_api </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd></dd></dl>
<dl class="section user"><dt>Example</dt><dd></dd></dl>
<ul>
<li>Sending data: <div class="fragment"><div class="line"><a class="code" href="group___socket.html#struct_sl_sock_addr_in__t">SlSockAddrIn_t</a>  Addr;</div><div class="line">_i16 AddrSize = <span class="keyword">sizeof</span>(<a class="code" href="group___socket.html#struct_sl_sock_addr_in__t">SlSockAddrIn_t</a>);</div><div class="line">_i16 SockID;</div><div class="line">_i16 Status;</div><div class="line">_i8 Buf[SEND_BUF_LEN];</div><div class="line"></div><div class="line">Addr.sin_family = SL_AF_INET;</div><div class="line">Addr.sin_port = <a class="code" href="group___socket.html#gadfb6f98e5c75a46050780e8afbae13bd">sl_Htons</a>(5001);</div><div class="line">Addr.sin_addr.s_addr = <a class="code" href="group___socket.html#ga712c2a31c2844b54c33ede3a9a148d61">sl_Htonl</a>(SL_IPV4_VAL(10,1,1,200));</div><div class="line"></div><div class="line">SockID = <a class="code" href="group___socket.html#gaa775fcb6d09bf35b9dac3e5eb8e8c997">sl_Socket</a>(SL_AF_INET,SL_SOCK_STREAM, 0);</div><div class="line">Status = <a class="code" href="group___socket.html#gad8b9db85493e84b19994840f4cff0ca0">sl_Connect</a>(SockID, (<a class="code" href="group___socket.html#struct_sl_sock_addr__t">SlSockAddr_t</a> *)&amp;Addr, AddrSize);</div><div class="line">Status = <a class="code" href="group___socket.html#ga2fc8c293bbcb796217076329e1bac518">sl_Send</a>(SockID, Buf, 1460, 0 );</div></div><!-- fragment --> </li>
</ul>

<p>Definition at line <a class="el" href="sl__socket_8c_source.html#l00594">594</a> of file <a class="el" href="sl__socket_8c_source.html">sl_socket.c</a>.</p>
<div class="fragment"><div class="line"><a name="l00595"></a><span class="lineno">  595</span>&#160;{</div><div class="line"><a name="l00596"></a><span class="lineno">  596</span>&#160;    _SlSendMsg_u  Msg;</div><div class="line"><a name="l00597"></a><span class="lineno">  597</span>&#160;    <a class="code" href="struct___sl_cmd_ext__t.html">_SlCmdExt_t</a>   CmdExt;</div><div class="line"><a name="l00598"></a><span class="lineno">  598</span>&#160;    _i16          RetVal;</div><div class="line"><a name="l00599"></a><span class="lineno">  599</span>&#160;    _u32          tempVal;</div><div class="line"><a name="l00600"></a><span class="lineno">  600</span>&#160;</div><div class="line"><a name="l00601"></a><span class="lineno">  601</span>&#160;    <span class="comment">/* verify that this api is allowed. if not allowed then</span></div><div class="line"><a name="l00602"></a><span class="lineno">  602</span>&#160;<span class="comment">    ignore the API execution and return immediately with an error */</span></div><div class="line"><a name="l00603"></a><span class="lineno">  603</span>&#160;    VERIFY_API_ALLOWED(SL_OPCODE_SILO_SOCKET);</div><div class="line"><a name="l00604"></a><span class="lineno">  604</span>&#160;</div><div class="line"><a name="l00605"></a><span class="lineno">  605</span>&#160;    _SlDrvResetCmdExt(&amp;CmdExt);</div><div class="line"><a name="l00606"></a><span class="lineno">  606</span>&#160;    CmdExt.TxPayload1Len = (_u16)Len;</div><div class="line"><a name="l00607"></a><span class="lineno">  607</span>&#160;    CmdExt.pTxPayload1 = (_u8 *)pBuf;</div><div class="line"><a name="l00608"></a><span class="lineno">  608</span>&#160;    </div><div class="line"><a name="l00609"></a><span class="lineno">  609</span>&#160;    <span class="comment">/* Only for RAW transceiver type socket, relay the flags parameter in the 2 bytes (4 byte aligned) before the actual payload */</span></div><div class="line"><a name="l00610"></a><span class="lineno">  610</span>&#160;    <span class="keywordflow">if</span> ((sd &amp; SL_SOCKET_PAYLOAD_TYPE_MASK) == SL_SOCKET_PAYLOAD_TYPE_RAW_TRANCEIVER)</div><div class="line"><a name="l00611"></a><span class="lineno">  611</span>&#160;    {</div><div class="line"><a name="l00612"></a><span class="lineno">  612</span>&#160;        tempVal = (_u32)flags;</div><div class="line"><a name="l00613"></a><span class="lineno">  613</span>&#160;        CmdExt.pRxPayload = (_u8 *)&amp;tempVal;</div><div class="line"><a name="l00614"></a><span class="lineno">  614</span>&#160;        CmdExt.RxPayloadLen = -4; <span class="comment">/* the (-) sign is used to mark the rx buff as output buff as well*/</span></div><div class="line"><a name="l00615"></a><span class="lineno">  615</span>&#160;    }</div><div class="line"><a name="l00616"></a><span class="lineno">  616</span>&#160;    <span class="keywordflow">else</span></div><div class="line"><a name="l00617"></a><span class="lineno">  617</span>&#160;    {</div><div class="line"><a name="l00618"></a><span class="lineno">  618</span>&#160;        CmdExt.pRxPayload = NULL;</div><div class="line"><a name="l00619"></a><span class="lineno">  619</span>&#160;        <span class="keywordflow">if</span> (Len &lt; 1)</div><div class="line"><a name="l00620"></a><span class="lineno">  620</span>&#160;        {</div><div class="line"><a name="l00621"></a><span class="lineno">  621</span>&#160;            <span class="comment">/* ignore */</span></div><div class="line"><a name="l00622"></a><span class="lineno">  622</span>&#160;            <span class="keywordflow">return</span> 0;</div><div class="line"><a name="l00623"></a><span class="lineno">  623</span>&#160;        }</div><div class="line"><a name="l00624"></a><span class="lineno">  624</span>&#160;    }</div><div class="line"><a name="l00625"></a><span class="lineno">  625</span>&#160;</div><div class="line"><a name="l00626"></a><span class="lineno">  626</span>&#160;    Msg.Cmd.StatusOrLen = Len;</div><div class="line"><a name="l00627"></a><span class="lineno">  627</span>&#160;    Msg.Cmd.Sd = (_u8)sd;</div><div class="line"><a name="l00628"></a><span class="lineno">  628</span>&#160;    Msg.Cmd.FamilyAndFlags |= flags &amp; 0x0F;</div><div class="line"><a name="l00629"></a><span class="lineno">  629</span>&#160;</div><div class="line"><a name="l00630"></a><span class="lineno">  630</span>&#160;    RetVal = _SlDrvDataWriteOp((_u8)sd, (<a class="code" href="struct___sl_cmd_ctrl__t.html">_SlCmdCtrl_t</a> *)&amp;_SlSendCmdCtrl, &amp;Msg, &amp;CmdExt);</div><div class="line"><a name="l00631"></a><span class="lineno">  631</span>&#160;    <span class="keywordflow">if</span>(SL_OS_RET_CODE_OK != RetVal)</div><div class="line"><a name="l00632"></a><span class="lineno">  632</span>&#160;    {</div><div class="line"><a name="l00633"></a><span class="lineno">  633</span>&#160;        <span class="keywordflow">return</span> RetVal;</div><div class="line"><a name="l00634"></a><span class="lineno">  634</span>&#160;    }</div><div class="line"><a name="l00635"></a><span class="lineno">  635</span>&#160;    </div><div class="line"><a name="l00636"></a><span class="lineno">  636</span>&#160;    <span class="keywordflow">return</span> (_i16)Len;</div><div class="line"><a name="l00637"></a><span class="lineno">  637</span>&#160;}</div><div class="ttc" id="struct___sl_cmd_ctrl__t_html"><div class="ttname"><a href="struct___sl_cmd_ctrl__t.html">_SlCmdCtrl_t</a></div><div class="ttdef"><b>Definition:</b> <a href="driver_8h_source.html#l00179">driver.h:179</a></div></div>
<div class="ttc" id="struct___sl_cmd_ext__t_html"><div class="ttname"><a href="struct___sl_cmd_ext__t.html">_SlCmdExt_t</a></div><div class="ttdef"><b>Definition:</b> <a href="driver_8h_source.html#l00186">driver.h:186</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="ga7ca76d181974c71673c3bf3fc1fedfdc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7ca76d181974c71673c3bf3fc1fedfdc">&sect;&nbsp;</a></span>sl_SendTo()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">_i16 sl_SendTo </td>
          <td>(</td>
          <td class="paramtype">_i16&#160;</td>
          <td class="paramname"><em>sd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_i16&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_i16&#160;</td>
          <td class="paramname"><em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group___socket.html#struct_sl_sock_addr__t">SlSockAddr_t</a> *&#160;</td>
          <td class="paramname"><em>to</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SlSocklen_t&#160;</td>
          <td class="paramname"><em>tolen</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write data to socket. </p>
<p>This function is used to transmit a message to another socket (connection less socket SOCK_DGRAM, SOCK_RAW).<br />
Returns immediately after sending data to device.<br />
In case of transmission failure an async event SL_SOCKET_TX_FAILED_EVENT is going to be received.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">sd</td><td>Socket handle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">buf</td><td>Points to a buffer containing the message to be sent </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">len</td><td>message size in bytes. Range: 1-1460 bytes </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">flags</td><td>Specifies the type of message transmission. On this version, this parameter is not supported </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">to</td><td>Pointer to an address structure indicating the destination address.<br />
 sockaddr:<br />
 - code for the address format. On this version only AF_INET is supported.<br />
 - socket address, the length depends on the code format </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">tolen</td><td>Destination address structure size</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Zero on success, or negative error code on failure</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group___socket.html#ga2fc8c293bbcb796217076329e1bac518" title="Write data to TCP socket. ">sl_Send</a> </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Belongs to send_api </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd></dd></dl>
<dl class="section user"><dt>Example</dt><dd></dd></dl>
<ul>
<li>Sending data: <div class="fragment"><div class="line"><a class="code" href="group___socket.html#struct_sl_sock_addr_in__t">SlSockAddrIn_t</a>  Addr;</div><div class="line">_i16 AddrSize = <span class="keyword">sizeof</span>(<a class="code" href="group___socket.html#struct_sl_sock_addr_in__t">SlSockAddrIn_t</a>);</div><div class="line">_i16 SockID;</div><div class="line">_i16 Status;</div><div class="line">_i8 Buf[SEND_BUF_LEN];</div><div class="line"></div><div class="line">Addr.sin_family = SL_AF_INET;</div><div class="line">Addr.sin_port = <a class="code" href="group___socket.html#gadfb6f98e5c75a46050780e8afbae13bd">sl_Htons</a>(5001);</div><div class="line">Addr.sin_addr.s_addr = <a class="code" href="group___socket.html#ga712c2a31c2844b54c33ede3a9a148d61">sl_Htonl</a>(SL_IPV4_VAL(10,1,1,200));</div><div class="line"></div><div class="line">SockID = <a class="code" href="group___socket.html#gaa775fcb6d09bf35b9dac3e5eb8e8c997">sl_Socket</a>(SL_AF_INET,SL_SOCK_DGRAM, 0);</div><div class="line">Status = <a class="code" href="group___socket.html#ga7ca76d181974c71673c3bf3fc1fedfdc">sl_SendTo</a>(SockID, Buf, 1472, 0, (<a class="code" href="group___socket.html#struct_sl_sock_addr__t">SlSockAddr_t</a> *)&amp;Addr, AddrSize);</div></div><!-- fragment --> </li>
</ul>

<p>Definition at line <a class="el" href="sl__socket_8c_source.html#l00288">288</a> of file <a class="el" href="sl__socket_8c_source.html">sl_socket.c</a>.</p>
<div class="fragment"><div class="line"><a name="l00289"></a><span class="lineno">  289</span>&#160;{</div><div class="line"><a name="l00290"></a><span class="lineno">  290</span>&#160;    _SlSendtoMsg_u   Msg;</div><div class="line"><a name="l00291"></a><span class="lineno">  291</span>&#160;    <a class="code" href="struct___sl_cmd_ctrl__t.html">_SlCmdCtrl_t</a>     CmdCtrl = {0, 0, 0};</div><div class="line"><a name="l00292"></a><span class="lineno">  292</span>&#160;    <a class="code" href="struct___sl_cmd_ext__t.html">_SlCmdExt_t</a>      CmdExt;</div><div class="line"><a name="l00293"></a><span class="lineno">  293</span>&#160;    _i16             RetVal;</div><div class="line"><a name="l00294"></a><span class="lineno">  294</span>&#160;</div><div class="line"><a name="l00295"></a><span class="lineno">  295</span>&#160;    <span class="comment">/* verify that this api is allowed. if not allowed then</span></div><div class="line"><a name="l00296"></a><span class="lineno">  296</span>&#160;<span class="comment">    ignore the API execution and return immediately with an error */</span></div><div class="line"><a name="l00297"></a><span class="lineno">  297</span>&#160;    VERIFY_API_ALLOWED(SL_OPCODE_SILO_SOCKET);</div><div class="line"><a name="l00298"></a><span class="lineno">  298</span>&#160;   <span class="comment">/* RAW transceiver use only sl_Send  */</span></div><div class="line"><a name="l00299"></a><span class="lineno">  299</span>&#160;    <span class="keywordflow">if</span> ((sd &amp; SL_SOCKET_PAYLOAD_TYPE_MASK) == SL_SOCKET_PAYLOAD_TYPE_RAW_TRANCEIVER)</div><div class="line"><a name="l00300"></a><span class="lineno">  300</span>&#160;    {</div><div class="line"><a name="l00301"></a><span class="lineno">  301</span>&#160;        <span class="keywordflow">return</span> SL_ERROR_BSD_SOC_ERROR;</div><div class="line"><a name="l00302"></a><span class="lineno">  302</span>&#160;    }</div><div class="line"><a name="l00303"></a><span class="lineno">  303</span>&#160;    <span class="keywordflow">else</span></div><div class="line"><a name="l00304"></a><span class="lineno">  304</span>&#160;    {</div><div class="line"><a name="l00305"></a><span class="lineno">  305</span>&#160;        <span class="keywordflow">if</span> (Len &lt; 1)</div><div class="line"><a name="l00306"></a><span class="lineno">  306</span>&#160;        {</div><div class="line"><a name="l00307"></a><span class="lineno">  307</span>&#160;            <span class="comment">/* ignore */</span></div><div class="line"><a name="l00308"></a><span class="lineno">  308</span>&#160;            <span class="keywordflow">return</span> 0;</div><div class="line"><a name="l00309"></a><span class="lineno">  309</span>&#160;        }</div><div class="line"><a name="l00310"></a><span class="lineno">  310</span>&#160;    }</div><div class="line"><a name="l00311"></a><span class="lineno">  311</span>&#160;</div><div class="line"><a name="l00312"></a><span class="lineno">  312</span>&#160;    _SlDrvResetCmdExt(&amp;CmdExt);</div><div class="line"><a name="l00313"></a><span class="lineno">  313</span>&#160;    CmdExt.TxPayload1Len = (_u16)Len;</div><div class="line"><a name="l00314"></a><span class="lineno">  314</span>&#160;    CmdExt.pTxPayload1 = (_u8 *)pBuf;</div><div class="line"><a name="l00315"></a><span class="lineno">  315</span>&#160;</div><div class="line"><a name="l00316"></a><span class="lineno">  316</span>&#160;    <span class="keywordflow">switch</span>(to-&gt;sa_family)</div><div class="line"><a name="l00317"></a><span class="lineno">  317</span>&#160;    {</div><div class="line"><a name="l00318"></a><span class="lineno">  318</span>&#160;        <span class="keywordflow">case</span> SL_AF_INET:</div><div class="line"><a name="l00319"></a><span class="lineno">  319</span>&#160;            CmdCtrl.Opcode = SL_OPCODE_SOCKET_SENDTO;</div><div class="line"><a name="l00320"></a><span class="lineno">  320</span>&#160;            CmdCtrl.TxDescLen = (_SlArgSize_t)<span class="keyword">sizeof</span>(<a class="code" href="struct_sl_socket_addr_i_pv4_command__t.html">SlSocketAddrIPv4Command_t</a>);</div><div class="line"><a name="l00321"></a><span class="lineno">  321</span>&#160;            <span class="keywordflow">break</span>;</div><div class="line"><a name="l00322"></a><span class="lineno">  322</span>&#160;<span class="preprocessor">#ifndef SL_TINY               </span></div><div class="line"><a name="l00323"></a><span class="lineno">  323</span>&#160;<span class="preprocessor">#ifdef SL_SUPPORT_IPV6</span></div><div class="line"><a name="l00324"></a><span class="lineno">  324</span>&#160;        <span class="keywordflow">case</span> SL_AF_INET6:</div><div class="line"><a name="l00325"></a><span class="lineno">  325</span>&#160;            CmdCtrl.Opcode = SL_OPCODE_SOCKET_SENDTO_V6;</div><div class="line"><a name="l00326"></a><span class="lineno">  326</span>&#160;            CmdCtrl.TxDescLen = (_SlArgSize_t)<span class="keyword">sizeof</span>(<a class="code" href="struct_sl_socket_addr_i_pv6_command__t.html">SlSocketAddrIPv6Command_t</a>);</div><div class="line"><a name="l00327"></a><span class="lineno">  327</span>&#160;            <span class="keywordflow">break</span>;</div><div class="line"><a name="l00328"></a><span class="lineno">  328</span>&#160;<span class="preprocessor">#endif</span></div><div class="line"><a name="l00329"></a><span class="lineno">  329</span>&#160;<span class="preprocessor">#endif</span></div><div class="line"><a name="l00330"></a><span class="lineno">  330</span>&#160;        <span class="keywordflow">case</span> SL_AF_RF:</div><div class="line"><a name="l00331"></a><span class="lineno">  331</span>&#160;        <span class="keywordflow">default</span>:</div><div class="line"><a name="l00332"></a><span class="lineno">  332</span>&#160;            <span class="keywordflow">return</span> SL_RET_CODE_INVALID_INPUT;</div><div class="line"><a name="l00333"></a><span class="lineno">  333</span>&#160;    }</div><div class="line"><a name="l00334"></a><span class="lineno">  334</span>&#160;</div><div class="line"><a name="l00335"></a><span class="lineno">  335</span>&#160;    Msg.Cmd.IpV4.LenOrPadding = Len;</div><div class="line"><a name="l00336"></a><span class="lineno">  336</span>&#160;    Msg.Cmd.IpV4.Sd = (_u8)sd;</div><div class="line"><a name="l00337"></a><span class="lineno">  337</span>&#160;    _SlSocketBuildAddress(to, &amp;Msg.Cmd);</div><div class="line"><a name="l00338"></a><span class="lineno">  338</span>&#160;    Msg.Cmd.IpV4.FamilyAndFlags |= flags &amp; 0x0F;</div><div class="line"><a name="l00339"></a><span class="lineno">  339</span>&#160;</div><div class="line"><a name="l00340"></a><span class="lineno">  340</span>&#160;    RetVal = _SlDrvDataWriteOp((_SlSd_t)sd, &amp;CmdCtrl, &amp;Msg, &amp;CmdExt);</div><div class="line"><a name="l00341"></a><span class="lineno">  341</span>&#160;    <span class="keywordflow">if</span>(SL_OS_RET_CODE_OK != RetVal)</div><div class="line"><a name="l00342"></a><span class="lineno">  342</span>&#160;    {</div><div class="line"><a name="l00343"></a><span class="lineno">  343</span>&#160;        <span class="keywordflow">return</span> RetVal;</div><div class="line"><a name="l00344"></a><span class="lineno">  344</span>&#160;    }</div><div class="line"><a name="l00345"></a><span class="lineno">  345</span>&#160;</div><div class="line"><a name="l00346"></a><span class="lineno">  346</span>&#160;    <span class="keywordflow">return</span> (_i16)Len;</div><div class="line"><a name="l00347"></a><span class="lineno">  347</span>&#160;}</div><div class="ttc" id="struct___sl_cmd_ctrl__t_html"><div class="ttname"><a href="struct___sl_cmd_ctrl__t.html">_SlCmdCtrl_t</a></div><div class="ttdef"><b>Definition:</b> <a href="driver_8h_source.html#l00179">driver.h:179</a></div></div>
<div class="ttc" id="struct___sl_cmd_ext__t_html"><div class="ttname"><a href="struct___sl_cmd_ext__t.html">_SlCmdExt_t</a></div><div class="ttdef"><b>Definition:</b> <a href="driver_8h_source.html#l00186">driver.h:186</a></div></div>
<div class="ttc" id="struct_sl_socket_addr_i_pv4_command__t_html"><div class="ttname"><a href="struct_sl_socket_addr_i_pv4_command__t.html">SlSocketAddrIPv4Command_t</a></div><div class="ttdef"><b>Definition:</b> <a href="protocol_8h_source.html#l00773">protocol.h:773</a></div></div>
<div class="ttc" id="struct_sl_socket_addr_i_pv6_command__t_html"><div class="ttname"><a href="struct_sl_socket_addr_i_pv6_command__t.html">SlSocketAddrIPv6Command_t</a></div><div class="ttdef"><b>Definition:</b> <a href="protocol_8h_source.html#l00792">protocol.h:792</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="ga6363ea2098e629c1a6e2bf80e731fb79"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6363ea2098e629c1a6e2bf80e731fb79">&sect;&nbsp;</a></span>sl_SetSockOpt()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">_i16 sl_SetSockOpt </td>
          <td>(</td>
          <td class="paramtype">_i16&#160;</td>
          <td class="paramname"><em>sd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_i16&#160;</td>
          <td class="paramname"><em>level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_i16&#160;</td>
          <td class="paramname"><em>optname</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>optval</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SlSocklen_t&#160;</td>
          <td class="paramname"><em>optlen</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set socket options-. </p>
<p>This function manipulate the options associated with a socket.<br />
Options may exist at multiple protocol levels; they are always present at the uppermost socket level.<br />
 When manipulating socket options the level at which the option resides and the name of the option must be specified. To manipulate options at the socket level, level is specified as SOL_SOCKET. To manipulate options at any other level the protocol number of the appropriate proto- col controlling the option is supplied. For example, to indicate that an option is to be interpreted by the TCP protocol, level should be set to the protocol number of TCP; <br />
 The parameters optval and optlen are used to access optval - ues for <a class="el" href="group___b_s_d___socket.html#gaafa5721213ca1bfb2c1ab1ea0f39bf5c" title="Set socket options-. ">setsockopt()</a>. For <a class="el" href="group___b_s_d___socket.html#ga37e0195dbaf69283dd8541c2ae631b82" title="Get socket options. ">getsockopt()</a> they identify a buffer in which the value for the requested option(s) are to be returned. For <a class="el" href="group___b_s_d___socket.html#ga37e0195dbaf69283dd8541c2ae631b82" title="Get socket options. ">getsockopt()</a>, optlen is a value-result parameter, initially containing the size of the buffer pointed to by option_value, and modified on return to indicate the actual size of the value returned. If no option value is to be supplied or returned, option_value may be NULL.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">sd</td><td>Socket handle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">level</td><td>Defines the protocol level for this option<ul>
<li><b>SL_SOL_SOCKET</b> Socket level configurations (L4, transport layer)</li>
<li><b>SL_IPPROTO_IP</b> IP level configurations (L3, network layer)</li>
<li><b>SL_SOL_PHY_OPT</b> Link level configurations (L2, link layer) </li>
</ul>
</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">optname</td><td>Defines the option name to interrogate<ul>
<li><b>SL_SOL_SOCKET</b></li>
<li><b>SL_SO_KEEPALIVE</b> <br />
 Enable/Disable periodic keep alive. Keeps TCP connections active by enabling the periodic transmission of messages <br />
 Timeout is 5 minutes.<br />
 Default: Enabled <br />
 This options takes <a class="el" href="group___socket.html#struct_sl_sock_keepalive__t">SlSockKeepalive_t</a> struct as parameter</li>
<li><b>SL_SO_KEEPALIVETIME</b> <br />
 Set keep alive timeout. Value is in seconds <br />
 Default: 5 minutes <br />
</li>
<li><b>SL_SO_RX_NO_IP_BOUNDARY</b> <br />
 Enable/Disable rx ip boundary. In connectionless socket (udp/raw), unread data is dropped (when recvfrom len parameter &lt; data size), Enable this option in order to read the left data on the next recvfrom iteration Default: Disabled, IP boundary kept, <br />
 This options takes <a class="el" href="group___socket.html#struct_sl_sock_rx_no_ip_boundary__t">SlSockRxNoIpBoundary_t</a> struct as parameter</li>
<li><b>SL_SO_RCVTIMEO</b> <br />
 Sets the timeout value that specifies the maximum amount of time an input function waits until it completes. <br />
 Default: No timeout <br />
 This options takes <a class="el" href="group___socket.html#struct_sl_timeval__t">SlTimeval_t</a> struct as parameter</li>
<li><b>SL_SO_RCVBUF</b> <br />
 Sets tcp max recv window size. <br />
 This options takes <a class="el" href="group___socket.html#struct_sl_sock_winsize__t">SlSockWinsize_t</a> struct as parameter</li>
<li><b>SL_SO_NONBLOCKING</b> <br />
 Sets socket to non-blocking operation Impacts: connect, accept, send, sendto, recv and recvfrom. <br />
 Default: Blocking. This options takes <a class="el" href="group___socket.html#struct_sl_sock_nonblocking__t">SlSockNonblocking_t</a> struct as parameter</li>
<li><b>SL_SO_SECMETHOD</b> <br />
 Sets method to tcp secured socket (SL_SEC_SOCKET) <br />
 Default: SL_SO_SEC_METHOD_SSLv3_TLSV1_2 <br />
 This options takes <a class="el" href="group___socket.html#struct_sl_sock_secure_method__t">SlSockSecureMethod_t</a> struct as parameter</li>
<li><b>SL_SO_SECURE_MASK</b> <br />
 Sets specific cipher to tcp secured socket (SL_SEC_SOCKET) <br />
 Default: "Best" cipher suitable to method <br />
 This options takes <a class="el" href="group___socket.html#struct_sl_sock_secure_mask__t">SlSockSecureMask_t</a> struct as parameter</li>
<li><b>SL_SO_SECURE_FILES_CA_FILE_NAME</b> <br />
 Map secured socket to CA file by name <br />
 This options takes <b>_u8</b> buffer as parameter</li>
<li><b>SL_SO_SECURE_FILES_PRIVATE_KEY_FILE_NAME</b> <br />
 Map secured socket to private key by name <br />
 This options takes <b>_u8</b> buffer as parameter</li>
<li><b>SL_SO_SECURE_FILES_CERTIFICATE_FILE_NAME</b> <br />
 Map secured socket to certificate file by name <br />
 This options takes <b>_u8</b> buffer as parameter</li>
<li><b>SL_SO_SECURE_FILES_DH_KEY_FILE_NAME</b> <br />
 Map secured socket to Diffie Hellman file by name <br />
 This options takes <b>_u8</b> buffer as parameter</li>
<li><b>SL_SO_CHANGE_CHANNEL</b> <br />
 Sets channel in transceiver mode. This options takes <b>_u32</b> as channel number parameter</li>
<li><b>SL_SO_SECURE_ALPN</b> <br />
 Sets the ALPN list. the parameter is a bit map consist of or of the following values - SL_SECURE_ALPN_H1 SL_SECURE_ALPN_H2 SL_SECURE_ALPN_H2C SL_SECURE_ALPN_H2_14 SL_SECURE_ALPN_H2_16 SL_SECURE_ALPN_FULL_LIST</li>
<li><b>SL_IPPROTO_IP</b></li>
<li><b>SL_IP_MULTICAST_TTL</b> <br />
 Set the time-to-live value of outgoing multicast packets for this socket. <br />
 This options takes <b>_u8</b> as parameter</li>
<li><b>SL_IP_ADD_MEMBERSHIP</b> <br />
 UDP socket, Join a multicast group. <br />
 This options takes <a class="el" href="group___socket.html#struct_sl_sock_ip_mreq__t">SlSockIpMreq_t</a> struct as parameter</li>
<li><b>SL_IP_DROP_MEMBERSHIP</b> <br />
 UDP socket, Leave a multicast group <br />
 This options takes <a class="el" href="group___socket.html#struct_sl_sock_ip_mreq__t">SlSockIpMreq_t</a> struct as parameter</li>
<li><b>SL_IP_RAW_RX_NO_HEADER</b> <br />
 Raw socket remove IP header from received data. <br />
 Default: data includes ip header <br />
 This options takes <b>_u32</b> as parameter</li>
<li><b>SL_IP_HDRINCL</b> <br />
 RAW socket only, the IPv4 layer generates an IP header when sending a packet unless <br />
 the IP_HDRINCL socket option is enabled on the socket. <br />
 When it is enabled, the packet must contain an IP header. <br />
 Default: disabled, IPv4 header generated by Network Stack <br />
 This options takes <b>_u32</b> as parameter</li>
<li><b>SL_IP_RAW_IPV6_HDRINCL</b> (inactive) <br />
 RAW socket only, the IPv6 layer generates an IP header when sending a packet unless <br />
 the IP_HDRINCL socket option is enabled on the socket. When it is enabled, the packet must contain an IP header <br />
 Default: disabled, IPv4 header generated by Network Stack <br />
 This options takes <b>_u32</b> as parameter</li>
<li><b>SL_SOL_PHY_OPT</b></li>
<li><b>SL_SO_PHY_RATE</b> <br />
 RAW socket, set WLAN PHY transmit rate <br />
 The values are based on SlWlanRateIndex_e <br />
 This options takes <b>_u32</b> as parameter</li>
<li><b>SL_SO_PHY_TX_POWER</b> <br />
 RAW socket, set WLAN PHY TX power <br />
 Valid rage is 1-15 <br />
 This options takes <b>_u32</b> as parameter</li>
<li><b>SL_SO_PHY_NUM_FRAMES_TO_TX</b> <br />
 RAW socket, set number of frames to transmit in transceiver mode. Default: 1 packet This options takes <b>_u32</b> as parameter</li>
<li><b>SL_SO_PHY_PREAMBLE</b> <br />
 RAW socket, set WLAN PHY preamble for Long/Short<br />
 This options takes <b>_u32</b> as parameter</li>
<li><b>SL_SO_PHY_TX_INHIBIT_THRESHOLD</b> <br />
 RAW socket, set WLAN Tx  Set CCA threshold. <br />
 The values are based on SlTxInhibitThreshold_e <br />
 This options takes <b>_u32</b> as parameter</li>
<li><b>SL_SO_PHY_TX_TIMEOUT</b> <br />
 RAW socket, set WLAN Tx  changes the TX timeout (lifetime) of transceiver frames. <br />
 Value in Ms, maximum value is 10ms <br />
 This options takes <b>_u32</b> as parameter</li>
<li><b>SL_SO_PHY_ALLOW_ACKS </b> <br />
 RAW socket, set WLAN Tx  Enable sending ACKs in transceiver mode <br />
 0 = disabled / 1 = enabled <br />
 This options takes <b>_u32</b> as parameter</li>
<li><b>SL_SO_LINGER</b> <br />
 Socket lingers on close pending remaining send/receive packetst<br />
</li>
<li><b>SL_SO_SECURE_EXT_CLIENT_CHLNG_RESP</b> <br />
 Set with no parameter to indicate that the client uses external signature using netapp requesrt.<br />
 needs netapp request handler<br />
</li>
<li><b>SL_SO_SECURE_DOMAIN_NAME_VERIFICATION </b><br />
 Set a domain name, to check in ssl client connection.</li>
</ul>
</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">optval</td><td>Specifies a value for the option </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">optlen</td><td>Specifies the length of the option value</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Zero on success, or negative error code on failure</dd></dl>
<dl class="section user"><dt>Persistent </dt><dd>All params are <b>Non- Persistent</b> </dd></dl>
<dl class="section see"><dt>See also</dt><dd>sl_getsockopt </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Belongs to basic_api </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd></dd></dl>
<dl class="section user"><dt>Examples</dt><dd></dd></dl>
<ul>
<li>SL_SO_KEEPALIVE (disable Keepalive): <div class="fragment"><div class="line"><a class="code" href="group___socket.html#struct_sl_sock_keepalive__t">SlSockKeepalive_t</a> enableOption;</div><div class="line">enableOption.KeepaliveEnabled = 0;</div><div class="line"><a class="code" href="group___socket.html#ga6363ea2098e629c1a6e2bf80e731fb79">sl_SetSockOpt</a>(SockID,SL_SOL_SOCKET,SL_SO_KEEPALIVE, (_u8 *)&amp;enableOption,<span class="keyword">sizeof</span>(enableOption));  </div></div><!-- fragment --> <br />
</li>
<li>SL_SO_KEEPALIVETIME (Set Keepalive timeout): <div class="fragment"><div class="line">_i16 Status;</div><div class="line">_u32 TimeOut = 120;</div><div class="line"><a class="code" href="group___socket.html#ga6363ea2098e629c1a6e2bf80e731fb79">sl_SetSockOpt</a>(Sd, SL_SOL_SOCKET, SL_SO_KEEPALIVETIME,( _u8*) &amp;TimeOut, <span class="keyword">sizeof</span>(TimeOut));</div></div><!-- fragment --> <br />
</li>
<li>SL_SO_RX_NO_IP_BOUNDARY (disable boundary): <div class="fragment"><div class="line"><a class="code" href="group___socket.html#struct_sl_sock_rx_no_ip_boundary__t">SlSockRxNoIpBoundary_t</a> enableOption;</div><div class="line">enableOption.RxIpNoBoundaryEnabled = 1;</div><div class="line"><a class="code" href="group___socket.html#ga6363ea2098e629c1a6e2bf80e731fb79">sl_SetSockOpt</a>(SockID,SL_SOL_SOCKET,SL_SO_RX_NO_IP_BOUNDARY, (_u8 *)&amp;enableOption,<span class="keyword">sizeof</span>(enableOption));  </div></div><!-- fragment --> <br />
</li>
<li>SL_SO_RCVTIMEO: <div class="fragment"><div class="line"><span class="keyword">struct </span><a class="code" href="group___socket.html#struct_sl_timeval__t">SlTimeval_t</a> timeVal;</div><div class="line">timeVal.tv_sec =  1;             <span class="comment">// Seconds</span></div><div class="line">timeVal.tv_usec = 0;             <span class="comment">// Microseconds. 10000 microseconds resolution</span></div><div class="line"><a class="code" href="group___socket.html#ga6363ea2098e629c1a6e2bf80e731fb79">sl_SetSockOpt</a>(SockID,SL_SOL_SOCKET,SL_SO_RCVTIMEO, (_u8 *)&amp;timeVal, <span class="keyword">sizeof</span>(timeVal));    <span class="comment">// Enable receive timeout </span></div></div><!-- fragment --> <br />
</li>
<li>SL_SO_RCVBUF: <div class="fragment"><div class="line"><a class="code" href="group___socket.html#struct_sl_sock_winsize__t">SlSockWinsize_t</a> size;</div><div class="line">size.Winsize = 3000;  <span class="comment">// bytes</span></div><div class="line"><a class="code" href="group___socket.html#ga6363ea2098e629c1a6e2bf80e731fb79">sl_SetSockOpt</a>(SockID,SL_SOL_SOCKET,SL_SO_RCVBUF, (_u8 *)&amp;size, <span class="keyword">sizeof</span>(size));</div></div><!-- fragment --> <br />
</li>
<li>SL_SO_NONBLOCKING: <div class="fragment"><div class="line"><a class="code" href="group___socket.html#struct_sl_sock_nonblocking__t">SlSockNonblocking_t</a> enableOption;</div><div class="line">enableOption.NonblockingEnabled = 1;</div><div class="line"><a class="code" href="group___socket.html#ga6363ea2098e629c1a6e2bf80e731fb79">sl_SetSockOpt</a>(SockID,SL_SOL_SOCKET,SL_SO_NONBLOCKING, (_u8 *)&amp;enableOption,<span class="keyword">sizeof</span>(enableOption)); <span class="comment">// Enable/disable nonblocking mode</span></div></div><!-- fragment --> <br />
</li>
<li>SL_SO_SECMETHOD: <div class="fragment"><div class="line"><a class="code" href="group___socket.html#struct_sl_sock_secure_method__t">SlSockSecureMethod_t</a> method;</div><div class="line">method.SecureMethod = SL_SO_SEC_METHOD_SSLV3;                                 <span class="comment">// security method we want to use</span></div><div class="line">SockID = <a class="code" href="group___socket.html#gaa775fcb6d09bf35b9dac3e5eb8e8c997">sl_Socket</a>(SL_AF_INET,SL_SOCK_STREAM, SL_SEC_SOCKET);</div><div class="line"><a class="code" href="group___socket.html#ga6363ea2098e629c1a6e2bf80e731fb79">sl_SetSockOpt</a>(SockID, SL_SOL_SOCKET, SL_SO_SECMETHOD, (_u8 *)&amp;method, <span class="keyword">sizeof</span>(method));</div></div><!-- fragment --> <br />
</li>
<li>SL_SO_SECURE_MASK: <div class="fragment"><div class="line"><a class="code" href="group___socket.html#struct_sl_sock_secure_mask__t">SlSockSecureMask_t</a> cipher;</div><div class="line">cipher.SecureMask = SL_SEC_MASK_SSL_RSA_WITH_RC4_128_SHA;                   <span class="comment">// cipher type</span></div><div class="line">SockID = <a class="code" href="group___socket.html#gaa775fcb6d09bf35b9dac3e5eb8e8c997">sl_Socket</a>(SL_AF_INET,SL_SOCK_STREAM, SL_SEC_SOCKET);</div><div class="line"><a class="code" href="group___socket.html#ga6363ea2098e629c1a6e2bf80e731fb79">sl_SetSockOpt</a>(SockID, SL_SOL_SOCKET, SL_SO_SECURE_MASK,(_u8 *)&amp;cipher, <span class="keyword">sizeof</span>(cipher));</div></div><!-- fragment --> <br />
</li>
<li>SL_SO_SECURE_FILES_CA_FILE_NAME: <div class="fragment"><div class="line"><a class="code" href="group___socket.html#ga6363ea2098e629c1a6e2bf80e731fb79">sl_SetSockOpt</a>(SockID,SL_SOL_SOCKET,SL_SO_SECURE_FILES_CA_FILE_NAME,<span class="stringliteral">&quot;exuifaxCaCert.der&quot;</span>,strlen(<span class="stringliteral">&quot;exuifaxCaCert.der&quot;</span>));</div></div><!-- fragment --> <br />
</li>
<li>SL_SO_SECURE_FILES_PRIVATE_KEY_FILE_NAME; <div class="fragment"><div class="line"><a class="code" href="group___socket.html#ga6363ea2098e629c1a6e2bf80e731fb79">sl_SetSockOpt</a>(SockID,SL_SOL_SOCKET,SL_SO_SECURE_FILES_PRIVATE_KEY_FILE_NAME,<span class="stringliteral">&quot;myPrivateKey.der&quot;</span>,strlen(<span class="stringliteral">&quot;myPrivateKey.der&quot;</span>));</div></div><!-- fragment --> <br />
</li>
<li>SL_SO_SECURE_FILES_CERTIFICATE_FILE_NAME: <div class="fragment"><div class="line"><a class="code" href="group___socket.html#ga6363ea2098e629c1a6e2bf80e731fb79">sl_SetSockOpt</a>(SockID,SL_SOL_SOCKET,SL_SO_SECURE_FILES_CERTIFICATE_FILE_NAME,<span class="stringliteral">&quot;myCertificate.der&quot;</span>,strlen(<span class="stringliteral">&quot;myCertificate.der&quot;</span>));</div></div><!-- fragment --> <br />
</li>
<li>SL_SO_SECURE_FILES_DH_KEY_FILE_NAME: <div class="fragment"><div class="line"><a class="code" href="group___socket.html#ga6363ea2098e629c1a6e2bf80e731fb79">sl_SetSockOpt</a>(SockID,SL_SOL_SOCKET,SL_SO_SECURE_FILES_DH_KEY_FILE_NAME,<span class="stringliteral">&quot;myDHinServerMode.der&quot;</span>,strlen(<span class="stringliteral">&quot;myDHinServerMode.der&quot;</span>));</div></div><!-- fragment --> <br />
</li>
<li>SL_IP_MULTICAST_TTL: <div class="fragment"><div class="line">_u8 ttl = 20;</div><div class="line"><a class="code" href="group___socket.html#ga6363ea2098e629c1a6e2bf80e731fb79">sl_SetSockOpt</a>(SockID, SL_IPPROTO_IP, SL_IP_MULTICAST_TTL, &amp;ttl, <span class="keyword">sizeof</span>(ttl));</div></div><!-- fragment --> <br />
</li>
<li>SL_IP_ADD_MEMBERSHIP: <div class="fragment"><div class="line"><a class="code" href="group___socket.html#struct_sl_sock_ip_mreq__t">SlSockIpMreq_t</a> mreq;</div><div class="line"><a class="code" href="group___socket.html#ga6363ea2098e629c1a6e2bf80e731fb79">sl_SetSockOpt</a>(SockID, SL_IPPROTO_IP, SL_IP_ADD_MEMBERSHIP, &amp;mreq, <span class="keyword">sizeof</span>(mreq));</div></div><!-- fragment --> <br />
</li>
<li>SL_IP_DROP_MEMBERSHIP: <div class="fragment"><div class="line"><a class="code" href="group___socket.html#struct_sl_sock_ip_mreq__t">SlSockIpMreq_t</a> mreq;</div><div class="line"><a class="code" href="group___socket.html#ga6363ea2098e629c1a6e2bf80e731fb79">sl_SetSockOpt</a>(SockID, SL_IPPROTO_IP, SL_IP_DROP_MEMBERSHIP, &amp;mreq, <span class="keyword">sizeof</span>(mreq));</div></div><!-- fragment --> <br />
</li>
<li>SL_SO_CHANGE_CHANNEL: <div class="fragment"><div class="line">_u32 newChannel = 6; <span class="comment">// range is 1-13</span></div><div class="line"><a class="code" href="group___socket.html#ga6363ea2098e629c1a6e2bf80e731fb79">sl_SetSockOpt</a>(SockID, SL_SOL_SOCKET, SL_SO_CHANGE_CHANNEL, &amp;newChannel, <span class="keyword">sizeof</span>(newChannel));  </div></div><!-- fragment --> <br />
</li>
<li>SL_SO_SECURE_ALPN: <div class="fragment"><div class="line"><a class="code" href="group___socket.html#struct_sl_sock_secure_a_l_p_n__t">SlSockSecureALPN_t</a> alpn;</div><div class="line">alpn.SecureALPN = SL_SECURE_ALPN_H2 | SL_SECURE_ALPN_H2_14;</div><div class="line"><a class="code" href="group___socket.html#ga6363ea2098e629c1a6e2bf80e731fb79">sl_SetSockOpt</a>(SockID, SL_SOL_SOCKET, SL_SO_SECURE_ALPN, &amp;alpn, <span class="keyword">sizeof</span>(<a class="code" href="group___socket.html#struct_sl_sock_secure_a_l_p_n__t">SlSockSecureALPN_t</a>));  </div></div><!-- fragment --> <br />
</li>
<li>SL_IP_RAW_RX_NO_HEADER: <div class="fragment"><div class="line">_u32 header = 1;  <span class="comment">// remove ip header</span></div><div class="line"><a class="code" href="group___socket.html#ga6363ea2098e629c1a6e2bf80e731fb79">sl_SetSockOpt</a>(SockID, SL_IPPROTO_IP, SL_IP_RAW_RX_NO_HEADER, &amp;header, <span class="keyword">sizeof</span>(header));</div></div><!-- fragment --> <br />
</li>
<li>SL_IP_HDRINCL: <div class="fragment"><div class="line">_u32 header = 1;</div><div class="line"><a class="code" href="group___socket.html#ga6363ea2098e629c1a6e2bf80e731fb79">sl_SetSockOpt</a>(SockID, SL_IPPROTO_IP, SL_IP_HDRINCL, &amp;header, <span class="keyword">sizeof</span>(header));</div></div><!-- fragment --> <br />
</li>
<li>SL_IP_RAW_IPV6_HDRINCL: <div class="fragment"><div class="line">_u32 header = 1;</div><div class="line"><a class="code" href="group___socket.html#ga6363ea2098e629c1a6e2bf80e731fb79">sl_SetSockOpt</a>(SockID, SL_IPPROTO_IP, SL_IP_RAW_IPV6_HDRINCL, &amp;header, <span class="keyword">sizeof</span>(header));</div></div><!-- fragment --> <br />
</li>
<li>SL_SO_PHY_RATE: <div class="fragment"><div class="line">_u32 rate = 6; <span class="comment">// see wlan.h SlWlanRateIndex_e for values</span></div><div class="line"><a class="code" href="group___socket.html#ga6363ea2098e629c1a6e2bf80e731fb79">sl_SetSockOpt</a>(SockID, SL_SOL_PHY_OPT, SL_SO_PHY_RATE, &amp;rate, <span class="keyword">sizeof</span>(rate));  </div></div><!-- fragment --> <br />
</li>
<li>SL_SO_PHY_TX_POWER: <div class="fragment"><div class="line">_u32 txpower = 1; <span class="comment">// valid range is 1-15</span></div><div class="line"><a class="code" href="group___socket.html#ga6363ea2098e629c1a6e2bf80e731fb79">sl_SetSockOpt</a>(SockID, SL_SOL_PHY_OPT, SL_SO_PHY_TX_POWER, &amp;txpower, <span class="keyword">sizeof</span>(txpower));</div></div><!-- fragment --> <br />
</li>
<li>SL_SO_PHY_NUM_FRAMES_TO_TX: <div class="fragment"><div class="line">_u32 numframes = 1;</div><div class="line"><a class="code" href="group___socket.html#ga6363ea2098e629c1a6e2bf80e731fb79">sl_SetSockOpt</a>(SockID, SL_SOL_PHY_OPT, SL_SO_PHY_NUM_FRAMES_TO_TX, &amp;numframes, <span class="keyword">sizeof</span>(numframes));</div></div><!-- fragment --> <br />
</li>
<li>SL_SO_PHY_PREAMBLE: <div class="fragment"><div class="line">_u32 preamble = 1;</div><div class="line"><a class="code" href="group___socket.html#ga6363ea2098e629c1a6e2bf80e731fb79">sl_SetSockOpt</a>(SockID, SL_SOL_PHY_OPT, SL_SO_PHY_PREAMBLE, &amp;preamble, <span class="keyword">sizeof</span>(preamble));</div></div><!-- fragment --> <br />
</li>
<li>SL_SO_PHY_TX_INHIBIT_THRESHOLD: <div class="fragment"><div class="line">_u32 thrshld = SL_TX_INHIBIT_THRESHOLD_MED;</div><div class="line"><a class="code" href="group___socket.html#ga6363ea2098e629c1a6e2bf80e731fb79">sl_SetSockOpt</a>(SockID, SL_SOL_PHY_OPT, SL_SO_PHY_TX_INHIBIT_THRESHOLD , &amp;thrshld, <span class="keyword">sizeof</span>(thrshld));</div></div><!-- fragment --> <br />
</li>
<li>SL_SO_PHY_TX_TIMEOUT: <div class="fragment"><div class="line">_u32 timeout = 50;</div><div class="line"><a class="code" href="group___socket.html#ga6363ea2098e629c1a6e2bf80e731fb79">sl_SetSockOpt</a>(SockID, SL_SOL_PHY_OPT, SL_SO_PHY_TX_TIMEOUT  , &amp;timeout, <span class="keyword">sizeof</span>(timeout));</div></div><!-- fragment --> <br />
</li>
<li>SL_SO_PHY_ALLOW_ACKS: <div class="fragment"><div class="line">_u32 acks = 1; <span class="comment">// 0 = disabled / 1 = enabled</span></div><div class="line"><a class="code" href="group___socket.html#ga6363ea2098e629c1a6e2bf80e731fb79">sl_SetSockOpt</a>(SockID, SL_SOL_PHY_OPT, SL_SO_PHY_ALLOW_ACKS, &amp;acks, <span class="keyword">sizeof</span>(acks));</div></div><!-- fragment --> <br />
</li>
<li>SL_SO_LINGER: <div class="fragment"><div class="line"><a class="code" href="group___socket.html#struct_sl_socklinger__t">SlSocklinger_t</a> linger;</div><div class="line">linger.l_onoff = 1;</div><div class="line">linger.l_linger = 10;</div><div class="line"><a class="code" href="group___socket.html#ga6363ea2098e629c1a6e2bf80e731fb79">sl_SetSockOpt</a>(SockID, SL_SOL_SOCKET, SL_SO_LINGER, &amp;linger, <span class="keyword">sizeof</span>(linger));</div></div><!-- fragment --> <br />
</li>
<li>SL_SO_SECURE_EXT_CLIENT_CHLNG_RESP: <div class="fragment"><div class="line"><span class="keywordtype">int</span> dummy;</div><div class="line"><a class="code" href="group___socket.html#ga6363ea2098e629c1a6e2bf80e731fb79">sl_SetSockOpt</a>(SockID, SL_SOL_SOCKET, SL_SO_SECURE_EXT_CLIENT_CHLNG_RESP, &amp;dummy, <span class="keyword">sizeof</span>(dummy));</div></div><!-- fragment --> <br />
</li>
<li>SL_SO_SECURE_DOMAIN_NAME_VERIFICATION: <div class="fragment"><div class="line"><a class="code" href="group___socket.html#ga6363ea2098e629c1a6e2bf80e731fb79">sl_SetSockOpt</a>(SockID,SL_SOL_SOCKET,SL_SO_SECURE_DOMAIN_NAME_VERIFICATION,<span class="stringliteral">&quot;www.google.co.il&quot;</span>,strlen(<span class="stringliteral">&quot;www.google.co.il&quot;</span>));</div></div><!-- fragment --> </li>
</ul>

<p>Definition at line <a class="el" href="sl__socket_8c_source.html#l00925">925</a> of file <a class="el" href="sl__socket_8c_source.html">sl_socket.c</a>.</p>
<div class="fragment"><div class="line"><a name="l00926"></a><span class="lineno">  926</span>&#160;{</div><div class="line"><a name="l00927"></a><span class="lineno">  927</span>&#160;    _SlSetSockOptMsg_u    Msg;</div><div class="line"><a name="l00928"></a><span class="lineno">  928</span>&#160;    <a class="code" href="struct___sl_cmd_ext__t.html">_SlCmdExt_t</a>           CmdExt;</div><div class="line"><a name="l00929"></a><span class="lineno">  929</span>&#160;</div><div class="line"><a name="l00930"></a><span class="lineno">  930</span>&#160;    <span class="comment">/* verify that this api is allowed. if not allowed then</span></div><div class="line"><a name="l00931"></a><span class="lineno">  931</span>&#160;<span class="comment">    ignore the API execution and return immediately with an error */</span></div><div class="line"><a name="l00932"></a><span class="lineno">  932</span>&#160;    VERIFY_API_ALLOWED(SL_OPCODE_SILO_SOCKET);</div><div class="line"><a name="l00933"></a><span class="lineno">  933</span>&#160;</div><div class="line"><a name="l00934"></a><span class="lineno">  934</span>&#160;    _SlDrvResetCmdExt(&amp;CmdExt);</div><div class="line"><a name="l00935"></a><span class="lineno">  935</span>&#160;    CmdExt.TxPayload1Len = optlen;</div><div class="line"><a name="l00936"></a><span class="lineno">  936</span>&#160;    CmdExt.pTxPayload1 = (_u8 *)optval;</div><div class="line"><a name="l00937"></a><span class="lineno">  937</span>&#160;</div><div class="line"><a name="l00938"></a><span class="lineno">  938</span>&#160;    Msg.Cmd.Sd = (_u8)sd;</div><div class="line"><a name="l00939"></a><span class="lineno">  939</span>&#160;    Msg.Cmd.Level = (_u8)level;</div><div class="line"><a name="l00940"></a><span class="lineno">  940</span>&#160;    Msg.Cmd.OptionLen = (_u8)optlen;</div><div class="line"><a name="l00941"></a><span class="lineno">  941</span>&#160;    Msg.Cmd.OptionName = (_u8)optname;</div><div class="line"><a name="l00942"></a><span class="lineno">  942</span>&#160;</div><div class="line"><a name="l00943"></a><span class="lineno">  943</span>&#160;    VERIFY_RET_OK(_SlDrvCmdOp((<a class="code" href="struct___sl_cmd_ctrl__t.html">_SlCmdCtrl_t</a> *)&amp;_SlSetSockOptCmdCtrl, &amp;Msg, &amp;CmdExt));</div><div class="line"><a name="l00944"></a><span class="lineno">  944</span>&#160;</div><div class="line"><a name="l00945"></a><span class="lineno">  945</span>&#160;    <span class="keywordflow">return</span> (_i16)Msg.Rsp.StatusOrLen;</div><div class="line"><a name="l00946"></a><span class="lineno">  946</span>&#160;}</div><div class="ttc" id="struct___sl_cmd_ctrl__t_html"><div class="ttname"><a href="struct___sl_cmd_ctrl__t.html">_SlCmdCtrl_t</a></div><div class="ttdef"><b>Definition:</b> <a href="driver_8h_source.html#l00179">driver.h:179</a></div></div>
<div class="ttc" id="struct___sl_cmd_ext__t_html"><div class="ttname"><a href="struct___sl_cmd_ext__t.html">_SlCmdExt_t</a></div><div class="ttdef"><b>Definition:</b> <a href="driver_8h_source.html#l00186">driver.h:186</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="gaa775fcb6d09bf35b9dac3e5eb8e8c997"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa775fcb6d09bf35b9dac3e5eb8e8c997">&sect;&nbsp;</a></span>sl_Socket()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">_i16 sl_Socket </td>
          <td>(</td>
          <td class="paramtype">_i16&#160;</td>
          <td class="paramname"><em>Domain</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_i16&#160;</td>
          <td class="paramname"><em>Type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_i16&#160;</td>
          <td class="paramname"><em>Protocol</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create an endpoint for communication. </p>
<p>The socket function creates a new socket of a certain socket type, identified by an integer number, and allocates system resources to it.<br />
This function is called by the application layer to obtain a socket handle.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">Domain</td><td>Specifies the protocol family of the created socket. For example:<ul>
<li>SL_AF_INET for network protocol IPv4</li>
<li>SL_AF_INET6 for network protocol IPv6</li>
<li>SL_AF_RF for starting transceiver mode. Notes:<ul>
<li>sending and receiving any packet overriding 802.11 header</li>
<li>for optimized power consumption the socket will be started in TX only mode until receive command is activated</li>
</ul>
</li>
</ul>
</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Type</td><td>specifies the communication semantic, one of:<ul>
<li>SL_SOCK_STREAM (reliable stream-oriented service or Stream Sockets)</li>
<li>SL_SOCK_DGRAM (datagram service or Datagram Sockets)</li>
<li>SL_SOCK_RAW (raw protocols atop the network layer)</li>
<li>when used with AF_RF:<ul>
<li>SL_SOCK_DGRAM - L2 socket</li>
<li>SL_SOCK_RAW - L1 socket - bypass WLAN CCA (Clear Channel Assessment)</li>
</ul>
</li>
</ul>
</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Protocol</td><td>specifies a particular transport to be used with the socket. <br />
 The most common are<ul>
<li>SL_IPPROTO_TCP</li>
<li>SL_IPPROTO_UDP The value 0 may be used to select a default protocol from the selected domain and type</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>On success, socket handle that is used for consequent socket operations. <br />
 A successful return code should be a positive number (int16)<br />
 On error, a negative (int16) value will be returned specifying the error code.<ul>
<li>SL_EAFNOSUPPORT - illegal domain parameter</li>
<li>SL_EPROTOTYPE - illegal type parameter</li>
<li>SL_EACCES - permission denied</li>
<li>SL_ENSOCK - exceeded maximal number of socket</li>
<li>SL_ENOMEM - memory allocation error</li>
<li>SL_EINVAL - error in socket configuration</li>
<li>SL_EPROTONOSUPPORT - illegal protocol parameter</li>
<li>SL_EOPNOTSUPP - illegal combination of protocol and type parameters</li>
</ul>
</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group___socket.html#gacc7971a6e41592c8ef90936b25495a8b" title="Gracefully close socket. ">sl_Close</a> </dd></dl>
<dl class="section note"><dt>Note</dt><dd>belongs to basic_api </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd></dd></dl>

<p>Definition at line <a class="el" href="sl__socket_8c_source.html#l00137">137</a> of file <a class="el" href="sl__socket_8c_source.html">sl_socket.c</a>.</p>
<div class="fragment"><div class="line"><a name="l00138"></a><span class="lineno">  138</span>&#160;{</div><div class="line"><a name="l00139"></a><span class="lineno">  139</span>&#160;    _SlSockSocketMsg_u  Msg;</div><div class="line"><a name="l00140"></a><span class="lineno">  140</span>&#160;</div><div class="line"><a name="l00141"></a><span class="lineno">  141</span>&#160;    Msg.Cmd.Domain       = (_u8)Domain;</div><div class="line"><a name="l00142"></a><span class="lineno">  142</span>&#160;    Msg.Cmd.Type         = (_u8)Type;</div><div class="line"><a name="l00143"></a><span class="lineno">  143</span>&#160;    Msg.Cmd.Protocol     = (_u8)Protocol;</div><div class="line"><a name="l00144"></a><span class="lineno">  144</span>&#160;</div><div class="line"><a name="l00145"></a><span class="lineno">  145</span>&#160;    <span class="comment">/* verify that this api is allowed. if not allowed then</span></div><div class="line"><a name="l00146"></a><span class="lineno">  146</span>&#160;<span class="comment">    ignore the API execution and return immediately with an error */</span></div><div class="line"><a name="l00147"></a><span class="lineno">  147</span>&#160;    VERIFY_API_ALLOWED(SL_OPCODE_SILO_SOCKET);</div><div class="line"><a name="l00148"></a><span class="lineno">  148</span>&#160;</div><div class="line"><a name="l00149"></a><span class="lineno">  149</span>&#160;    VERIFY_RET_OK(_SlDrvCmdOp((<a class="code" href="struct___sl_cmd_ctrl__t.html">_SlCmdCtrl_t</a> *)&amp;_SlSockSocketCmdCtrl, &amp;Msg, NULL));</div><div class="line"><a name="l00150"></a><span class="lineno">  150</span>&#160;</div><div class="line"><a name="l00151"></a><span class="lineno">  151</span>&#160;    <span class="keywordflow">if</span>( Msg.Rsp.StatusOrLen &lt; 0 )</div><div class="line"><a name="l00152"></a><span class="lineno">  152</span>&#160;    {</div><div class="line"><a name="l00153"></a><span class="lineno">  153</span>&#160;        <span class="keywordflow">return</span> ( Msg.Rsp.StatusOrLen);</div><div class="line"><a name="l00154"></a><span class="lineno">  154</span>&#160;    }</div><div class="line"><a name="l00155"></a><span class="lineno">  155</span>&#160;    <span class="keywordflow">else</span></div><div class="line"><a name="l00156"></a><span class="lineno">  156</span>&#160;    {</div><div class="line"><a name="l00157"></a><span class="lineno">  157</span>&#160;        <span class="keywordflow">return</span> (_i16)((_u8)Msg.Rsp.Sd);</div><div class="line"><a name="l00158"></a><span class="lineno">  158</span>&#160;    }</div><div class="line"><a name="l00159"></a><span class="lineno">  159</span>&#160;}</div><div class="ttc" id="struct___sl_cmd_ctrl__t_html"><div class="ttname"><a href="struct___sl_cmd_ctrl__t.html">_SlCmdCtrl_t</a></div><div class="ttdef"><b>Definition:</b> <a href="driver_8h_source.html#l00179">driver.h:179</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="ga9275c1dadaba20e46381343800d0127b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9275c1dadaba20e46381343800d0127b">&sect;&nbsp;</a></span>sl_StartTLS()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">_i16 sl_StartTLS </td>
          <td>(</td>
          <td class="paramtype">_i16&#160;</td>
          <td class="paramname"><em>sd</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initiate TLS connection on a socket. </p>
<p>Function Initiate TLS connection on the socket referred to by the socket descriptor sd. This function will works on blocking mode until the TLS handshake success or fails.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">sd</td><td>Socket descriptor (handle)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Zero on success, or negative error code on failure</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group___socket.html#gaa775fcb6d09bf35b9dac3e5eb8e8c997" title="Create an endpoint for communication. ">sl_Socket</a> </dd></dl>
<dl class="section note"><dt>Note</dt><dd>belongs to client_side </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd></dd></dl>

<p>Definition at line <a class="el" href="sl__socket_8c_source.html#l01906">1906</a> of file <a class="el" href="sl__socket_8c_source.html">sl_socket.c</a>.</p>
<div class="fragment"><div class="line"><a name="l01907"></a><span class="lineno"> 1907</span>&#160;{</div><div class="line"><a name="l01908"></a><span class="lineno"> 1908</span>&#160;    _SlReturnVal_t       RetVal;</div><div class="line"><a name="l01909"></a><span class="lineno"> 1909</span>&#160;    <a class="code" href="group___socket.html#struct_sl_socket_async_event__t">SlSocketAsyncEvent_t</a> AsyncRsp;</div><div class="line"><a name="l01910"></a><span class="lineno"> 1910</span>&#160;    _u32                 tempValue;</div><div class="line"><a name="l01911"></a><span class="lineno"> 1911</span>&#160;    _u8 ObjIdx = MAX_CONCURRENT_ACTIONS;</div><div class="line"><a name="l01912"></a><span class="lineno"> 1912</span>&#160;</div><div class="line"><a name="l01913"></a><span class="lineno"> 1913</span>&#160;    <span class="comment">/* verify that this api is allowed. if not allowed then</span></div><div class="line"><a name="l01914"></a><span class="lineno"> 1914</span>&#160;<span class="comment">       ignore the API execution and return immediately with an error */</span></div><div class="line"><a name="l01915"></a><span class="lineno"> 1915</span>&#160;    VERIFY_API_ALLOWED(SL_OPCODE_SILO_SOCKET);</div><div class="line"><a name="l01916"></a><span class="lineno"> 1916</span>&#160;    _SlDrvMemZero(&amp;AsyncRsp, <span class="keyword">sizeof</span>(<a class="code" href="group___socket.html#struct_sl_socket_async_event__t">SlSocketAsyncEvent_t</a>));</div><div class="line"><a name="l01917"></a><span class="lineno"> 1917</span>&#160;</div><div class="line"><a name="l01918"></a><span class="lineno"> 1918</span>&#160;    ObjIdx = _SlDrvProtectAsyncRespSetting((_u8*)&amp;AsyncRsp, START_TLS_ID, (_u8)(sd  &amp; SL_BSD_SOCKET_ID_MASK));</div><div class="line"><a name="l01919"></a><span class="lineno"> 1919</span>&#160;</div><div class="line"><a name="l01920"></a><span class="lineno"> 1920</span>&#160;    <span class="keywordflow">if</span> (MAX_CONCURRENT_ACTIONS == ObjIdx)</div><div class="line"><a name="l01921"></a><span class="lineno"> 1921</span>&#160;    {</div><div class="line"><a name="l01922"></a><span class="lineno"> 1922</span>&#160;        <span class="keywordflow">return</span> SL_POOL_IS_EMPTY;</div><div class="line"><a name="l01923"></a><span class="lineno"> 1923</span>&#160;    }</div><div class="line"><a name="l01924"></a><span class="lineno"> 1924</span>&#160;</div><div class="line"><a name="l01925"></a><span class="lineno"> 1925</span>&#160;    <span class="comment">/* send Start TLS to sl_SetSockOpt */</span></div><div class="line"><a name="l01926"></a><span class="lineno"> 1926</span>&#160;    RetVal = <a class="code" href="group___socket.html#ga6363ea2098e629c1a6e2bf80e731fb79">sl_SetSockOpt</a>(sd, SL_SOL_SOCKET, SL_SO_STARTTLS, &amp;tempValue, <span class="keyword">sizeof</span>(tempValue));</div><div class="line"><a name="l01927"></a><span class="lineno"> 1927</span>&#160;</div><div class="line"><a name="l01928"></a><span class="lineno"> 1928</span>&#160;    <span class="keywordflow">if</span>(SL_RET_CODE_OK == RetVal)</div><div class="line"><a name="l01929"></a><span class="lineno"> 1929</span>&#160;    {</div><div class="line"><a name="l01930"></a><span class="lineno"> 1930</span>&#160;        <span class="comment">/* wait for async and get Data Read parameters */</span></div><div class="line"><a name="l01931"></a><span class="lineno"> 1931</span>&#160;        SL_DRV_SYNC_OBJ_WAIT_FOREVER(&amp;g_pCB-&gt;ObjPool[ObjIdx].SyncObj);</div><div class="line"><a name="l01932"></a><span class="lineno"> 1932</span>&#160;</div><div class="line"><a name="l01933"></a><span class="lineno"> 1933</span>&#160;        VERIFY_PROTOCOL(AsyncRsp.Sd == (_u8)sd);</div><div class="line"><a name="l01934"></a><span class="lineno"> 1934</span>&#160;</div><div class="line"><a name="l01935"></a><span class="lineno"> 1935</span>&#160;        <span class="keywordflow">if</span> (SL_SSL_NOTIFICATION_CONNECTED_SECURED == AsyncRsp.Type)</div><div class="line"><a name="l01936"></a><span class="lineno"> 1936</span>&#160;        {</div><div class="line"><a name="l01937"></a><span class="lineno"> 1937</span>&#160;            RetVal = SL_RET_CODE_OK;</div><div class="line"><a name="l01938"></a><span class="lineno"> 1938</span>&#160;        }</div><div class="line"><a name="l01939"></a><span class="lineno"> 1939</span>&#160;        <span class="keywordflow">else</span></div><div class="line"><a name="l01940"></a><span class="lineno"> 1940</span>&#160;        {</div><div class="line"><a name="l01941"></a><span class="lineno"> 1941</span>&#160;            RetVal = AsyncRsp.Val;</div><div class="line"><a name="l01942"></a><span class="lineno"> 1942</span>&#160;        }</div><div class="line"><a name="l01943"></a><span class="lineno"> 1943</span>&#160;    }</div><div class="line"><a name="l01944"></a><span class="lineno"> 1944</span>&#160;</div><div class="line"><a name="l01945"></a><span class="lineno"> 1945</span>&#160;    _SlDrvReleasePoolObj(ObjIdx);</div><div class="line"><a name="l01946"></a><span class="lineno"> 1946</span>&#160;    <span class="keywordflow">return</span> RetVal;</div><div class="line"><a name="l01947"></a><span class="lineno"> 1947</span>&#160;}</div><div class="ttc" id="group___socket_html_ga6363ea2098e629c1a6e2bf80e731fb79"><div class="ttname"><a href="group___socket.html#ga6363ea2098e629c1a6e2bf80e731fb79">sl_SetSockOpt</a></div><div class="ttdeci">_i16 sl_SetSockOpt(_i16 sd, _i16 level, _i16 optname, const void *optval, SlSocklen_t optlen)</div><div class="ttdoc">Set socket options-. </div><div class="ttdef"><b>Definition:</b> <a href="sl__socket_8c_source.html#l00925">sl_socket.c:925</a></div></div>
<div class="ttc" id="group___socket_html_struct_sl_socket_async_event__t"><div class="ttname"><a href="group___socket.html#struct_sl_socket_async_event__t">SlSocketAsyncEvent_t</a></div><div class="ttdef"><b>Definition:</b> <a href="sl__socket_8h_source.html#l00269">sl_socket.h:269</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="gafc0cdc3f19064c810f4d5f723384502d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafc0cdc3f19064c810f4d5f723384502d">&sect;&nbsp;</a></span>SlNetIfWifi_accept()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int16_t SlNetIfWifi_accept </td>
          <td>(</td>
          <td class="paramtype">int16_t&#160;</td>
          <td class="paramname"><em>sd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>sdContext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SlNetSock_Addr_t *&#160;</td>
          <td class="paramname"><em>addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SlNetSocklen_t *&#160;</td>
          <td class="paramname"><em>addrlen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void **&#160;</td>
          <td class="paramname"><em>acceptedSdContext</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Accept a connection on a socket. </p>
<p>The SlNetIfWifi_accept function is used with connection-based socket types (SOCK_STREAM).<br />
It extracts the first connection request on the queue of pending connections, creates a new connected socket, and returns a new file descriptor referring to that socket.<br />
The newly created socket is not in the listening state. The original socket sd is unaffected by this call. <br />
The argument sd is a socket that has been created with <a class="el" href="group___socket.html#ga727dd5a1c20faa5d718cb5a2724b0981" title="Create an endpoint for communication. ">SlNetIfWifi_socket()</a>, bound to a local address with <a class="el" href="group___socket.html#gad86c6b5d5ecb41afcafa1026b2bd542b" title="Assign a name to a socket. ">SlNetIfWifi_bind()</a>, and is listening for connections after a <a class="el" href="group___socket.html#ga911c4ed3bb7039b3274ecd09f7df6e04" title="Listen for connections on a socket. ">SlNetIfWifi_listen()</a>. <br />
 The argument <em><b>addr</b></em> is a pointer to a sockaddr structure. This structure is filled in with the address of the peer socket, as known to the communications layer. <br />
 The exact format of the address returned addr is determined by the socket's address family. <br />
The <b><em>addrlen</em> argument</b> is a value-result argument: it should initially contain the size of the structure pointed to by addr, on return it will contain the actual length (in bytes) of the address returned.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">sd</td><td>Socket descriptor (handle) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">sdContext</td><td>May store socket data if implemented in the SlNetIfWifi_socket function. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">addr</td><td>The argument addr is a pointer to a sockaddr structure. This structure is filled in with the address of the peer socket, as known to the communications layer. The exact format of the address returned addr is determined by the socket's address<br />
 sockaddr:<br />
 - code for the address format.<br />
 - socket address, the length depends on the code format </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">addrlen</td><td>The addrlen argument is a value-result argument: it should initially contain the size of the structure pointed to by addr </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">flags</td><td>Specifies socket descriptor flags. <br />
 The available flags are:<ul>
<li>SLNETSOCK_SEC_START_SECURITY_SESSION_ONLY</li>
<li>SLNETSOCK_SEC_BIND_CONTEXT_ONLY Note: This flags can be used in order to start security session if needed </li>
</ul>
</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">acceptedSdContext</td><td>Allocate and store data for the new socket if needed in other to use it in other slnetwifi socket functions</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>On success, a socket descriptor.<br />
 On a non-blocking accept a possible negative value is SLNETERR_BSD_EAGAIN.<br />
 On failure, negative error code.<br />
 SLNETERR_BSD_ENOMEM may be return in case there are no resources in the system In this case try again later or increase MAX_CONCURRENT_ACTIONS</dd></dl>
<dl class="section see"><dt>See also</dt><dd>SlNetIfWifi_Socket SlNetIfWifi_Bind SlNetIfWifi_Listen </dd></dl>
<dl class="section note"><dt>Note</dt><dd></dd></dl>
<dl class="section warning"><dt>Warning</dt><dd></dd></dl>

<p>Definition at line <a class="el" href="slnetifwifi_8c_source.html#l00150">150</a> of file <a class="el" href="slnetifwifi_8c_source.html">slnetifwifi.c</a>.</p>
<div class="fragment"><div class="line"><a name="l00151"></a><span class="lineno">  151</span>&#160;{</div><div class="line"><a name="l00152"></a><span class="lineno">  152</span>&#160;    <span class="keywordflow">return</span> <a class="code" href="group___socket.html#ga72085bf8fae027f8fe31a0eb99a6808b">sl_Accept</a>(sd, (<a class="code" href="group___socket.html#struct_sl_sock_addr__t">SlSockAddr_t</a> *)addr, addrlen);</div><div class="line"><a name="l00153"></a><span class="lineno">  153</span>&#160;}</div><div class="ttc" id="group___socket_html_struct_sl_sock_addr__t"><div class="ttname"><a href="group___socket.html#struct_sl_sock_addr__t">SlSockAddr_t</a></div><div class="ttdef"><b>Definition:</b> <a href="sl__socket_8h_source.html#l00387">sl_socket.h:387</a></div></div>
<div class="ttc" id="group___socket_html_ga72085bf8fae027f8fe31a0eb99a6808b"><div class="ttname"><a href="group___socket.html#ga72085bf8fae027f8fe31a0eb99a6808b">sl_Accept</a></div><div class="ttdeci">_i16 sl_Accept(_i16 sd, SlSockAddr_t *addr, SlSocklen_t *addrlen)</div><div class="ttdoc">Accept a connection on a socket. </div><div class="ttdef"><b>Definition:</b> <a href="sl__socket_8c_source.html#l00692">sl_socket.c:692</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="gad86c6b5d5ecb41afcafa1026b2bd542b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad86c6b5d5ecb41afcafa1026b2bd542b">&sect;&nbsp;</a></span>SlNetIfWifi_bind()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t SlNetIfWifi_bind </td>
          <td>(</td>
          <td class="paramtype">int16_t&#160;</td>
          <td class="paramname"><em>sd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>sdContext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const SlNetSock_Addr_t *&#160;</td>
          <td class="paramname"><em>addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int16_t&#160;</td>
          <td class="paramname"><em>addrlen</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Assign a name to a socket. </p>
<p>This SlNetIfWifi_bind function gives the socket the local address addr. addr is addrlen bytes long. <br />
 Traditionally, this is called When a socket is created with socket, it exists in a name space (address family) but has no name assigned. <br />
It is necessary to assign a local address before a SOCK_STREAM socket may receive connections.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">sd</td><td>Socket descriptor (handle) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">sdContext</td><td>May store socket data if implemented in the SlNetIfWifi_socket function. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">addr</td><td>Specifies the destination addrs<br />
 sockaddr:<br />
 - code for the address format.<br />
 - socket address, the length depends on the code format </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">addrlen</td><td>Contains the size of the structure pointed to by addr</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Zero on success, or negative error code on failure</dd></dl>
<dl class="section see"><dt>See also</dt><dd>SlNetIfWifi_Socket <a class="el" href="group___socket.html#gafc0cdc3f19064c810f4d5f723384502d" title="Accept a connection on a socket. ">SlNetIfWifi_accept</a> SlNetIfWifi_Listen </dd></dl>
<dl class="section note"><dt>Note</dt><dd></dd></dl>
<dl class="section warning"><dt>Warning</dt><dd></dd></dl>

<p>Definition at line <a class="el" href="slnetifwifi_8c_source.html#l00161">161</a> of file <a class="el" href="slnetifwifi_8c_source.html">slnetifwifi.c</a>.</p>
<div class="fragment"><div class="line"><a name="l00162"></a><span class="lineno">  162</span>&#160;{</div><div class="line"><a name="l00163"></a><span class="lineno">  163</span>&#160;    <span class="keywordflow">return</span> <a class="code" href="group___socket.html#gadcb0c4792127dceb1feb3e9b87ab2094">sl_Bind</a>(sd, (<span class="keyword">const</span> <a class="code" href="group___socket.html#struct_sl_sock_addr__t">SlSockAddr_t</a> *)addr, addrlen);</div><div class="line"><a name="l00164"></a><span class="lineno">  164</span>&#160;}</div><div class="ttc" id="group___socket_html_gadcb0c4792127dceb1feb3e9b87ab2094"><div class="ttname"><a href="group___socket.html#gadcb0c4792127dceb1feb3e9b87ab2094">sl_Bind</a></div><div class="ttdeci">_i16 sl_Bind(_i16 sd, const SlSockAddr_t *addr, _i16 addrlen)</div><div class="ttdoc">Assign a name to a socket. </div><div class="ttdef"><b>Definition:</b> <a href="sl__socket_8c_source.html#l00240">sl_socket.c:240</a></div></div>
<div class="ttc" id="group___socket_html_struct_sl_sock_addr__t"><div class="ttname"><a href="group___socket.html#struct_sl_sock_addr__t">SlSockAddr_t</a></div><div class="ttdef"><b>Definition:</b> <a href="sl__socket_8h_source.html#l00387">sl_socket.h:387</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="ga6fef019848f9a4f730b065237dbd875a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6fef019848f9a4f730b065237dbd875a">&sect;&nbsp;</a></span>SlNetIfWifi_close()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t SlNetIfWifi_close </td>
          <td>(</td>
          <td class="paramtype">int16_t&#160;</td>
          <td class="paramname"><em>sd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>sdContext</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gracefully close socket. </p>
<p>The SlNetIfWifi_close function causes the system to release resources allocated to a socket. <br />
In case of TCP, the connection is terminated.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">sd</td><td>Socket descriptor (handle), received in SlNetIfWifi_socket </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">sdContext</td><td>May store socket data if implemented in the SlNetIfWifi_socket function.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Zero on success, or negative error code on failure</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group___socket.html#ga727dd5a1c20faa5d718cb5a2724b0981" title="Create an endpoint for communication. ">SlNetIfWifi_socket</a> </dd></dl>
<dl class="section note"><dt>Note</dt><dd></dd></dl>
<dl class="section warning"><dt>Warning</dt><dd></dd></dl>

<p>Definition at line <a class="el" href="slnetifwifi_8c_source.html#l00138">138</a> of file <a class="el" href="slnetifwifi_8c_source.html">slnetifwifi.c</a>.</p>
<div class="fragment"><div class="line"><a name="l00139"></a><span class="lineno">  139</span>&#160;{</div><div class="line"><a name="l00140"></a><span class="lineno">  140</span>&#160;    <span class="comment">/* Close socket and return the return value of the function                */</span></div><div class="line"><a name="l00141"></a><span class="lineno">  141</span>&#160;    <span class="keywordflow">return</span> <a class="code" href="group___socket.html#gacc7971a6e41592c8ef90936b25495a8b">sl_Close</a>(sd);</div><div class="line"><a name="l00142"></a><span class="lineno">  142</span>&#160;}</div><div class="ttc" id="group___socket_html_gacc7971a6e41592c8ef90936b25495a8b"><div class="ttname"><a href="group___socket.html#gacc7971a6e41592c8ef90936b25495a8b">sl_Close</a></div><div class="ttdeci">_i16 sl_Close(_i16 sd)</div><div class="ttdoc">Gracefully close socket. </div><div class="ttdef"><b>Definition:</b> <a href="sl__socket_8c_source.html#l00180">sl_socket.c:180</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="gadfedf7a7ca8571caa534535169830980"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadfedf7a7ca8571caa534535169830980">&sect;&nbsp;</a></span>SlNetIfWifi_connect()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t SlNetIfWifi_connect </td>
          <td>(</td>
          <td class="paramtype">int16_t&#160;</td>
          <td class="paramname"><em>sd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>sdContext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const SlNetSock_Addr_t *&#160;</td>
          <td class="paramname"><em>addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SlNetSocklen_t&#160;</td>
          <td class="paramname"><em>addrlen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initiate a connection on a socket. </p>
<p>Function connects the socket referred to by the socket descriptor sd, to the address specified by addr. <br />
 The addrlen argument specifies the size of addr. <br />
 The format of the address in addr is determined by the address space of the socket. <br />
 If it is of type SLNETSOCK_SOCK_DGRAM, this call specifies the peer with which the socket is to be associated; this address is that to which datagrams are to be sent, and the only address from which datagrams are to be received. <br />
 If the socket is of type SLNETSOCK_SOCK_STREAM, this call attempts to make a connection to another socket. <br />
 The other socket is specified by address, which is an address in the communications space of the socket.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">sd</td><td>Socket descriptor (handle) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">sdContext</td><td>May store socket data if implemented in the SlNetIfWifi_socket function. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">addr</td><td>Specifies the destination addr<br />
 sockaddr:<br />
 - code for the address format.<br />
 - socket address, the length depends on the code format </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">addrlen</td><td>Contains the size of the structure pointed to by addr </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">flags</td><td>Specifies socket descriptor flags. <br />
 The available flags are:<ul>
<li>SLNETSOCK_SEC_START_SECURITY_SESSION_ONLY</li>
<li>SLNETSOCK_SEC_BIND_CONTEXT_ONLY Note: This flags can be used in order to start security session if needed</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>On success, a socket descriptor (handle).<br />
 On a non-blocking connect a possible negative value is NETSCOK_EALREADY. On failure, negative value.<br />
 NETSCOK_POOL_IS_EMPTY may be return in case there are no resources in the system In this case try again later or increase MAX_CONCURRENT_ACTIONS</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group___socket.html#ga727dd5a1c20faa5d718cb5a2724b0981" title="Create an endpoint for communication. ">SlNetIfWifi_socket</a> </dd></dl>
<dl class="section note"><dt>Note</dt><dd></dd></dl>
<dl class="section warning"><dt>Warning</dt><dd></dd></dl>

<p>Definition at line <a class="el" href="slnetifwifi_8c_source.html#l00183">183</a> of file <a class="el" href="slnetifwifi_8c_source.html">slnetifwifi.c</a>.</p>
<div class="fragment"><div class="line"><a name="l00184"></a><span class="lineno">  184</span>&#160;{</div><div class="line"><a name="l00185"></a><span class="lineno">  185</span>&#160;    <span class="keywordflow">return</span> <a class="code" href="group___socket.html#gad8b9db85493e84b19994840f4cff0ca0">sl_Connect</a>(sd, (<span class="keyword">const</span> <a class="code" href="group___socket.html#struct_sl_sock_addr__t">SlSockAddr_t</a> *)addr, addrlen);</div><div class="line"><a name="l00186"></a><span class="lineno">  186</span>&#160;}</div><div class="ttc" id="group___socket_html_struct_sl_sock_addr__t"><div class="ttname"><a href="group___socket.html#struct_sl_sock_addr__t">SlSockAddr_t</a></div><div class="ttdef"><b>Definition:</b> <a href="sl__socket_8h_source.html#l00387">sl_socket.h:387</a></div></div>
<div class="ttc" id="group___socket_html_gad8b9db85493e84b19994840f4cff0ca0"><div class="ttname"><a href="group___socket.html#gad8b9db85493e84b19994840f4cff0ca0">sl_Connect</a></div><div class="ttdeci">_i16 sl_Connect(_i16 sd, const SlSockAddr_t *addr, _i16 addrlen)</div><div class="ttdoc">Initiate a connection on a socket. </div><div class="ttdef"><b>Definition:</b> <a href="sl__socket_8c_source.html#l00456">sl_socket.c:456</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="ga1f773f78ee46e8edc089397d9f013ff0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1f773f78ee46e8edc089397d9f013ff0">&sect;&nbsp;</a></span>SlNetIfWifi_CreateContext()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t SlNetIfWifi_CreateContext </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>ifID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>ifName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void **&#160;</td>
          <td class="paramname"><em>ifContext</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocate and store interface data. </p>
<p>The SlNetIfWifi_CreateContext function stores interface related data.<br />
 </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ifContext</td><td>Allocate and store interface data if needed. Can be used in all slnetwifi interface functions</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Zero on success, or negative error code on failure.</dd></dl>
<dl class="section see"><dt>See also</dt><dd></dd></dl>
<dl class="section note"><dt>Note</dt><dd></dd></dl>
<dl class="section warning"><dt>Warning</dt><dd></dd></dl>
<dl class="section user"><dt>Examples</dt><dd></dd></dl>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> *ifContext;</div><div class="line">connection_status = <a class="code" href="group___socket.html#ga1f773f78ee46e8edc089397d9f013ff0">SlNetIfWifi_CreateContext</a>(&amp;context);</div></div><!-- fragment --><p> <br />
 </p>

<p>Definition at line <a class="el" href="slnetifwifi_8c_source.html#l00437">437</a> of file <a class="el" href="slnetifwifi_8c_source.html">slnetifwifi.c</a>.</p>
<div class="fragment"><div class="line"><a name="l00438"></a><span class="lineno">  438</span>&#160;{</div><div class="line"><a name="l00439"></a><span class="lineno">  439</span>&#160;    <span class="keywordflow">return</span> SLNETERR_RET_CODE_OK;</div><div class="line"><a name="l00440"></a><span class="lineno">  440</span>&#160;}</div></div><!-- fragment -->
</div>
</div>
<a id="gae6fe2a9ee49eea4f1c3f177c92f5cb44"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae6fe2a9ee49eea4f1c3f177c92f5cb44">&sect;&nbsp;</a></span>SlNetIfWifi_getConnectionStatus()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t SlNetIfWifi_getConnectionStatus </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>ifContext</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get interface connection status. </p>
<p>The SlNetIfWifi_getConnectionStatus function gets the connection status of the interface (connected Or disconnected).<br />
 </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ifContext</td><td>Stores interface data if CreateContext function supported and implemented. Can be used in all SlNetIf_Config_t functions</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Connection status of the interface on success, or negative error code on failure</dd></dl>
<dl class="section see"><dt>See also</dt><dd></dd></dl>
<dl class="section note"><dt>Note</dt><dd></dd></dl>
<dl class="section warning"><dt>Warning</dt><dd></dd></dl>
<dl class="section user"><dt>Examples</dt><dd></dd></dl>
<div class="fragment"><div class="line">int16_t connection_status</div><div class="line">connection_status = <a class="code" href="group___socket.html#gae6fe2a9ee49eea4f1c3f177c92f5cb44">SlNetIfWifi_getConnectionStatus</a>();</div></div><!-- fragment --><p> <br />
 </p>

<p>Definition at line <a class="el" href="slnetifwifi_8c_source.html#l00363">363</a> of file <a class="el" href="slnetifwifi_8c_source.html">slnetifwifi.c</a>.</p>
<div class="fragment"><div class="line"><a name="l00364"></a><span class="lineno">  364</span>&#160;{</div><div class="line"><a name="l00365"></a><span class="lineno">  365</span>&#160;    <a class="code" href="group___wlan.html#struct_sl_wlan_conn_status_param__t">SlWlanConnStatusParam_t</a> connectionParams;</div><div class="line"><a name="l00366"></a><span class="lineno">  366</span>&#160;    uint16_t                Opt    = 0;</div><div class="line"><a name="l00367"></a><span class="lineno">  367</span>&#160;    int32_t                 retVal = 0;</div><div class="line"><a name="l00368"></a><span class="lineno">  368</span>&#160;    uint16_t                Size   = 0;</div><div class="line"><a name="l00369"></a><span class="lineno">  369</span>&#160;</div><div class="line"><a name="l00370"></a><span class="lineno">  370</span>&#160;    memset(&amp;connectionParams, 0, <span class="keyword">sizeof</span>(<a class="code" href="group___wlan.html#struct_sl_wlan_conn_status_param__t">SlWlanConnStatusParam_t</a>));</div><div class="line"><a name="l00371"></a><span class="lineno">  371</span>&#160;</div><div class="line"><a name="l00372"></a><span class="lineno">  372</span>&#160;    retVal = <a class="code" href="group___wlan.html#gae085496a64690e1d90de834ec571a409">sl_WlanGet</a>(SL_WLAN_CONNECTION_INFO, &amp;Opt, &amp;Size, (uint8_t *)&amp;connectionParams);</div><div class="line"><a name="l00373"></a><span class="lineno">  373</span>&#160;</div><div class="line"><a name="l00374"></a><span class="lineno">  374</span>&#160;    <span class="comment">/* Check if the function returned an error                               */</span></div><div class="line"><a name="l00375"></a><span class="lineno">  375</span>&#160;    <span class="keywordflow">if</span> (retVal &lt; SLNETERR_RET_CODE_OK)</div><div class="line"><a name="l00376"></a><span class="lineno">  376</span>&#160;    {</div><div class="line"><a name="l00377"></a><span class="lineno">  377</span>&#160;        <span class="comment">/* Return error code                                                 */</span></div><div class="line"><a name="l00378"></a><span class="lineno">  378</span>&#160;        <span class="keywordflow">return</span> retVal;</div><div class="line"><a name="l00379"></a><span class="lineno">  379</span>&#160;    }</div><div class="line"><a name="l00380"></a><span class="lineno">  380</span>&#160;    <span class="keywordflow">return</span> connectionParams.ConnStatus;</div><div class="line"><a name="l00381"></a><span class="lineno">  381</span>&#160;}</div><div class="ttc" id="group___wlan_html_gae085496a64690e1d90de834ec571a409"><div class="ttname"><a href="group___wlan.html#gae085496a64690e1d90de834ec571a409">sl_WlanGet</a></div><div class="ttdeci">_i16 sl_WlanGet(const _u16 ConfigId, _u16 *pConfigOpt, _u16 *pConfigLen, _u8 *pValues)</div><div class="ttdoc">Getting WLAN configurations. </div><div class="ttdef"><b>Definition:</b> <a href="wlan_8c_source.html#l00925">wlan.c:925</a></div></div>
<div class="ttc" id="group___wlan_html_struct_sl_wlan_conn_status_param__t"><div class="ttname"><a href="group___wlan.html#struct_sl_wlan_conn_status_param__t">SlWlanConnStatusParam_t</a></div><div class="ttdef"><b>Definition:</b> <a href="wlan_8h_source.html#l00689">wlan.h:689</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="ga9e2ff1207f1a794d56c34dad84cb1f07"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9e2ff1207f1a794d56c34dad84cb1f07">&sect;&nbsp;</a></span>SlNetIfWifi_getHostByName()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t SlNetIfWifi_getHostByName </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>ifContext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint16_t&#160;</td>
          <td class="paramname"><em>nameLen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>ipAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t *&#160;</td>
          <td class="paramname"><em>ipAddrLen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t&#160;</td>
          <td class="paramname"><em>family</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get host IP by name<br />
Obtain the IP Address of machine on network, by machine name. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ifContext</td><td>Stores interface data if CreateContext function supported and implemented. Can be used in all SlNetIf_Config_t functions </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ifBitmap</td><td>Specifies the interfaces which the host ip needs to be retrieved from (according to the priority until one of them will return an answer).<br />
 The values of the interface identifiers is defined with the prefix SLNETIF_ID_ which defined in slnetif.h </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">name</td><td>Host name </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nameLen</td><td>Name length </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">ipAddr</td><td>This parameter is filled in with host IP addresses. In case that host name is not resolved, out_ip_addr is zero. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">ipAddrLen</td><td>Holds the size of the ipAddr array, when function successful, the ipAddrLen parameter will be updated with the number of the IP addresses found. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">family</td><td>Protocol family</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Zero on success, or negative on failure.<br />
 SLNETUTIL_POOL_IS_EMPTY may be return in case there are no resources in the system<br />
 In this case try again later or increase MAX_CONCURRENT_ACTIONS Possible DNS error codes:<ul>
<li>SLNETUTIL_DNS_QUERY_NO_RESPONSE</li>
<li>SLNETUTIL_DNS_NO_SERVER</li>
<li>SLNETUTIL_DNS_QUERY_FAILED</li>
<li>SLNETUTIL_DNS_MALFORMED_PACKET</li>
<li>SLNETUTIL_DNS_MISMATCHED_RESPONSE</li>
</ul>
</dd></dl>
<dl class="section see"><dt>See also</dt><dd></dd></dl>
<dl class="section note"><dt>Note</dt><dd>Only one sl_NetAppDnsGetHostByName can be handled at a time.<br />
 Calling this API while the same command is called from another thread, may result in one of the two scenarios:<ol type="1">
<li>The command will wait (internal) until the previous command finish, and then be executed.</li>
<li>There are not enough resources and POOL_IS_EMPTY error will return.<br />
 In this case, MAX_CONCURRENT_ACTIONS can be increased (result in memory increase) or try again later to issue the command. </li>
</ol>
</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>In case an IP address in a string format is set as input, without any prefix (e.g. "1.2.3.4") the device will not try to access the DNS and it will return the input address on the 'out_ip_addr' field </dd></dl>
<dl class="section user"><dt>Example</dt><dd><ul>
<li>Getting host by name: <div class="fragment"><div class="line">uint16_t DestIPListSize = 1;</div><div class="line">uint32_t DestIP[1];</div><div class="line">uint32_t ifID;</div><div class="line">int16_t  SockId;</div><div class="line">SlNetSock_AddrIn_t LocalAddr; <span class="comment">//address of the server to connect to</span></div><div class="line">int32_t LocalAddrSize;</div><div class="line"></div><div class="line"><a class="code" href="group___socket.html#ga9e2ff1207f1a794d56c34dad84cb1f07">SlNetIfWifi_getHostByName</a>(0, <span class="stringliteral">&quot;www.google.com&quot;</span>, strlen(<span class="stringliteral">&quot;www.google.com&quot;</span>), (uint32_t *)DestIP, &amp;DestIPListSize, SLNETSOCK_PF_INET);</div><div class="line"></div><div class="line">LocalAddr.sin_family = SLNETSOCK_AF_INET;</div><div class="line">LocalAddr.sin_addr.s_addr = SlNetUtil_htonl(DestIP[0]);</div><div class="line">LocalAddr.sin_port = SlNetUtil_htons(80);</div><div class="line">LocalAddrSize = <span class="keyword">sizeof</span>(SlNetSock_AddrIn_t);</div><div class="line"></div><div class="line">SockId = <a class="code" href="group___socket.html#ga727dd5a1c20faa5d718cb5a2724b0981">SlNetIfWifi_socket</a>(SLNETSOCK_AF_INET, SLNETSOCK_SOCK_STREAM, ifID, 0);</div><div class="line"></div><div class="line"><span class="keywordflow">if</span> (SockId &gt;= 0)</div><div class="line">{</div><div class="line">    status = <a class="code" href="group___socket.html#gadfedf7a7ca8571caa534535169830980">SlNetIfWifi_connect</a>(SockId, (SlNetSock_Addr_t *) &amp;LocalAddr, LocalAddrSize);</div><div class="line">}</div></div><!-- fragment --> </li>
</ul>
</dd></dl>

<p>Definition at line <a class="el" href="slnetifwifi_8c_source.html#l00326">326</a> of file <a class="el" href="slnetifwifi_8c_source.html">slnetifwifi.c</a>.</p>
<div class="fragment"><div class="line"><a name="l00327"></a><span class="lineno">  327</span>&#160;{</div><div class="line"><a name="l00328"></a><span class="lineno">  328</span>&#160;    int32_t  retVal = SLNETERR_RET_CODE_OK;</div><div class="line"><a name="l00329"></a><span class="lineno">  329</span>&#160;    </div><div class="line"><a name="l00330"></a><span class="lineno">  330</span>&#160;    <span class="comment">/* sl_NetAppDnsGetHostByName can receive only one ipAddr variable, so</span></div><div class="line"><a name="l00331"></a><span class="lineno">  331</span>&#160;<span class="comment">       only the first slot of the array will be used and the ipAddrLen will</span></div><div class="line"><a name="l00332"></a><span class="lineno">  332</span>&#160;<span class="comment">       be updated to 1 when function is successfully                         */</span></div><div class="line"><a name="l00333"></a><span class="lineno">  333</span>&#160;    retVal = <a class="code" href="group___net_app.html#ga627fbeda3eea582e2f16de61d5d315f6">sl_NetAppDnsGetHostByName</a>((<span class="keywordtype">signed</span> <span class="keywordtype">char</span> *)name, nameLen, (_u32 *)ipAddr, family);</div><div class="line"><a name="l00334"></a><span class="lineno">  334</span>&#160;    </div><div class="line"><a name="l00335"></a><span class="lineno">  335</span>&#160;    <span class="keywordflow">if</span> (retVal == SLNETERR_RET_CODE_OK)</div><div class="line"><a name="l00336"></a><span class="lineno">  336</span>&#160;    {</div><div class="line"><a name="l00337"></a><span class="lineno">  337</span>&#160;        *ipAddrLen = 1;</div><div class="line"><a name="l00338"></a><span class="lineno">  338</span>&#160;    }</div><div class="line"><a name="l00339"></a><span class="lineno">  339</span>&#160;    </div><div class="line"><a name="l00340"></a><span class="lineno">  340</span>&#160;    <span class="keywordflow">return</span> retVal;</div><div class="line"><a name="l00341"></a><span class="lineno">  341</span>&#160;    </div><div class="line"><a name="l00342"></a><span class="lineno">  342</span>&#160;    </div><div class="line"><a name="l00343"></a><span class="lineno">  343</span>&#160;}</div><div class="ttc" id="group___net_app_html_ga627fbeda3eea582e2f16de61d5d315f6"><div class="ttname"><a href="group___net_app.html#ga627fbeda3eea582e2f16de61d5d315f6">sl_NetAppDnsGetHostByName</a></div><div class="ttdeci">_i16 sl_NetAppDnsGetHostByName(_i8 *pHostName, const _u16 NameLen, _u32 *OutIpAddr, const _u8 Family)</div><div class="ttdoc">Get host IP by name Obtain the IP Address of machine on network, by machine name. ...</div><div class="ttdef"><b>Definition:</b> <a href="netapp_8c_source.html#l00810">netapp.c:810</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="ga837e7844a3cd20cf93fb955673b78cf7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga837e7844a3cd20cf93fb955673b78cf7">&sect;&nbsp;</a></span>SlNetIfWifi_getIPAddr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t SlNetIfWifi_getIPAddr </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>ifContext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SlNetIfAddressType_e&#160;</td>
          <td class="paramname"><em>addrType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t *&#160;</td>
          <td class="paramname"><em>addrConfig</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>ipAddr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get IP Address of specific interface. </p>
<p>The SlNetIfWifi_getIPAddr function retrieve the IP address of a specific interface according to the Address Type, IPv4, IPv6 LOCAL or IPv6 GLOBAL.<br />
 <br />
 </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ifContext</td><td>Stores interface data if CreateContext function supported and implemented. Can be used in all SlNetIf_Config_t functions </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ifID</td><td>Specifies the interface which its connection state needs to be retrieved.<br />
 The values of the interface identifier is defined with the prefix SLNETIF_ID_ which defined in slnetif.h </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">addrType</td><td>Address type:<ul>
<li>SLNETIF_IPV4_ADDR</li>
<li>SLNETIF_IPV6_ADDR_LOCAL</li>
<li>SLNETIF_IPV6_ADDR_GLOBAL </li>
</ul>
</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">addrConfig</td><td>Address config:<ul>
<li>SLNETIF_ADDR_CFG_UNKNOWN</li>
<li>SLNETIF_ADDR_CFG_DHCP</li>
<li>SLNETIF_ADDR_CFG_DHCP_LLA</li>
<li>SLNETIF_ADDR_CFG_STATIC</li>
<li>SLNETIF_ADDR_CFG_STATELESS</li>
<li>SLNETIF_ADDR_CFG_STATEFUL </li>
</ul>
</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">ipAddr</td><td>IP Address according to the Address Type</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Zero on success, or negative error code on failure</dd></dl>
<dl class="section see"><dt>See also</dt><dd>SlNetIfAddressType_e </dd></dl>
<dl class="section note"><dt>Note</dt><dd></dd></dl>
<dl class="section warning"><dt>Warning</dt><dd></dd></dl>
<dl class="section user"><dt>Examples</dt><dd></dd></dl>
<div class="fragment"><div class="line">SlNetSock_In6Addr_t IPAdd;</div><div class="line">uint16_t addressConfig = 0;</div><div class="line"><a class="code" href="group___socket.html#ga837e7844a3cd20cf93fb955673b78cf7">SlNetIfWifi_getIPAddr</a>(SLNETIF_ID_1 ,SLNETIF_IPV6_ADDR_LOCAL ,&amp;addressConfig ,(uint8_t *)ipAddr);</div></div><!-- fragment --><p> <br />
 </p>

<p>Definition at line <a class="el" href="slnetifwifi_8c_source.html#l00351">351</a> of file <a class="el" href="slnetifwifi_8c_source.html">slnetifwifi.c</a>.</p>
<div class="fragment"><div class="line"><a name="l00352"></a><span class="lineno">  352</span>&#160;{</div><div class="line"><a name="l00353"></a><span class="lineno">  353</span>&#160;    uint16_t ipAddrLen = <span class="keyword">sizeof</span>(ipAddr);</div><div class="line"><a name="l00354"></a><span class="lineno">  354</span>&#160;    <span class="keywordflow">return</span> <a class="code" href="group___net_cfg.html#ga66d2a54ee5de35b7abae50f5254c7258">sl_NetCfgGet</a>(addrType, addrConfig, &amp;ipAddrLen, (<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *)ipAddr);</div><div class="line"><a name="l00355"></a><span class="lineno">  355</span>&#160;}</div><div class="ttc" id="group___net_cfg_html_ga66d2a54ee5de35b7abae50f5254c7258"><div class="ttname"><a href="group___net_cfg.html#ga66d2a54ee5de35b7abae50f5254c7258">sl_NetCfgGet</a></div><div class="ttdeci">_i16 sl_NetCfgGet(const _u16 ConfigId, _u16 *pConfigOpt, _u16 *pConfigLen, _u8 *pValues)</div><div class="ttdoc">Getting network configurations. </div><div class="ttdef"><b>Definition:</b> <a href="netcfg_8c_source.html#l00104">netcfg.c:104</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="ga591a5867e6f7a446a8f2cd66b612cfb3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga591a5867e6f7a446a8f2cd66b612cfb3">&sect;&nbsp;</a></span>SlNetIfWifi_getSockName()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t SlNetIfWifi_getSockName </td>
          <td>(</td>
          <td class="paramtype">int16_t&#160;</td>
          <td class="paramname"><em>sd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>sdContext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SlNetSock_Addr_t *&#160;</td>
          <td class="paramname"><em>addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SlNetSocklen_t *&#160;</td>
          <td class="paramname"><em>addrlen</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get local address info by socket descriptor<br />
Returns the local address info of the socket descriptor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">sd</td><td>Socket descriptor (handle) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">sdContext</td><td>May store socket data if implemented in the SlNetIfWifi_socket function. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">addr</td><td>The argument addr is a pointer to a SlNetSock_Addr_t structure. This structure is filled in with the address of the peer socket, as known to the communications layer. The exact format of the address returned addr is determined by the socket's address<br />
 SlNetSock_Addr_t:<br />
 - code for the address format.<br />
 - socket address, the length depends on the code format </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">addrlen</td><td>The addrlen argument is a value-result argument: it should initially contain the size of the structure pointed to by addr</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Zero on success, or negative on failure.<br />
</dd></dl>
<dl class="section see"><dt>See also</dt><dd>SlNetSock_create SlNetSock_bind </dd></dl>
<dl class="section note"><dt>Note</dt><dd>If the provided buffer is too small the returned address will be truncated and the addrlen will contain the actual size of the socket address </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd></dd></dl>

<p>Definition at line <a class="el" href="slnetifwifi_8c_source.html#l00195">195</a> of file <a class="el" href="slnetifwifi_8c_source.html">slnetifwifi.c</a>.</p>
<div class="fragment"><div class="line"><a name="l00196"></a><span class="lineno">  196</span>&#160;{</div><div class="line"><a name="l00197"></a><span class="lineno">  197</span>&#160;<span class="comment">// Not implemented in NWP</span></div><div class="line"><a name="l00198"></a><span class="lineno">  198</span>&#160;    <span class="keywordflow">return</span> SLNETERR_INVALPARAM;</div><div class="line"><a name="l00199"></a><span class="lineno">  199</span>&#160;}</div></div><!-- fragment -->
</div>
</div>
<a id="ga9fc02898bc65c0a0c55de78355436682"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9fc02898bc65c0a0c55de78355436682">&sect;&nbsp;</a></span>SlNetIfWifi_getSockOpt()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t SlNetIfWifi_getSockOpt </td>
          <td>(</td>
          <td class="paramtype">int16_t&#160;</td>
          <td class="paramname"><em>sd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>sdContext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int16_t&#160;</td>
          <td class="paramname"><em>level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int16_t&#160;</td>
          <td class="paramname"><em>optname</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>optval</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SlNetSocklen_t *&#160;</td>
          <td class="paramname"><em>optlen</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get socket options. </p>
<p>The SlNetIfWifi_getSockOpt function gets the options associated with a socket. Options may exist at multiple protocol levels; they are always present at the uppermost socket level.<br />
 The parameters optval and optlen identify a buffer in which the value for the requested option(s) are to be returned. optlen is a value-result parameter, initially containing the size of the buffer pointed to by option_value, and modified on return to indicate the actual size of the value returned. If no option value is to be supplied or returned, option_value may be NULL.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">sd</td><td>Socket descriptor (handle) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">sdContext</td><td>May store socket data if implemented in the SlNetIfWifi_socket function. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">level</td><td>Defines the protocol level for this option </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">optname</td><td>defines the option name to interrogate </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">optval</td><td>Specifies a value for the option </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">optlen</td><td>Specifies the length of the option value</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Zero on success, or negative error code on failure </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group___socket.html#gaa88290743d74f108aab46844aee496f8" title="Set socket options-. ">SlNetIfWifi_setSockOpt</a> </dd></dl>
<dl class="section note"><dt>Note</dt><dd></dd></dl>
<dl class="section warning"><dt>Warning</dt><dd></dd></dl>

<p>Definition at line <a class="el" href="slnetifwifi_8c_source.html#l00229">229</a> of file <a class="el" href="slnetifwifi_8c_source.html">slnetifwifi.c</a>.</p>
<div class="fragment"><div class="line"><a name="l00230"></a><span class="lineno">  230</span>&#160;{</div><div class="line"><a name="l00231"></a><span class="lineno">  231</span>&#160;    <span class="keywordflow">return</span> <a class="code" href="group___socket.html#ga77d6029b0c39df5541b0b0d6484591b4">sl_GetSockOpt</a>(sd, level, optname, optval, optlen);</div><div class="line"><a name="l00232"></a><span class="lineno">  232</span>&#160;}</div><div class="ttc" id="group___socket_html_ga77d6029b0c39df5541b0b0d6484591b4"><div class="ttname"><a href="group___socket.html#ga77d6029b0c39df5541b0b0d6484591b4">sl_GetSockOpt</a></div><div class="ttdeci">_i16 sl_GetSockOpt(_i16 sd, _i16 level, _i16 optname, void *optval, SlSocklen_t *optlen)</div><div class="ttdoc">Get socket options. </div><div class="ttdef"><b>Definition:</b> <a href="sl__socket_8c_source.html#l00968">sl_socket.c:968</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="ga911c4ed3bb7039b3274ecd09f7df6e04"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga911c4ed3bb7039b3274ecd09f7df6e04">&sect;&nbsp;</a></span>SlNetIfWifi_listen()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t SlNetIfWifi_listen </td>
          <td>(</td>
          <td class="paramtype">int16_t&#160;</td>
          <td class="paramname"><em>sd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>sdContext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int16_t&#160;</td>
          <td class="paramname"><em>backlog</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Listen for connections on a socket. </p>
<p>The willingness to accept incoming connections and a queue limit for incoming connections are specified with <a class="el" href="group___socket.html#ga911c4ed3bb7039b3274ecd09f7df6e04" title="Listen for connections on a socket. ">SlNetIfWifi_listen()</a>, and then the connections are accepted with <a class="el" href="group___socket.html#gafc0cdc3f19064c810f4d5f723384502d" title="Accept a connection on a socket. ">SlNetIfWifi_accept()</a>. <br />
The <a class="el" href="group___socket.html#ga911c4ed3bb7039b3274ecd09f7df6e04" title="Listen for connections on a socket. ">SlNetIfWifi_listen()</a> call applies only to sockets of type SOCK_STREAM The backlog parameter defines the maximum length the queue of pending connections may grow to.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">sd</td><td>Socket descriptor (handle) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">sdContext</td><td>May store socket data if implemented in the SlNetIfWifi_socket function. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">backlog</td><td>Specifies the listen queue depth.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Zero on success, or negative error code on failure</dd></dl>
<dl class="section see"><dt>See also</dt><dd>SlNetIfWifi_Socket <a class="el" href="group___socket.html#gafc0cdc3f19064c810f4d5f723384502d" title="Accept a connection on a socket. ">SlNetIfWifi_accept</a> <a class="el" href="group___socket.html#gad86c6b5d5ecb41afcafa1026b2bd542b" title="Assign a name to a socket. ">SlNetIfWifi_bind</a> </dd></dl>
<dl class="section note"><dt>Note</dt><dd></dd></dl>
<dl class="section warning"><dt>Warning</dt><dd></dd></dl>

<p>Definition at line <a class="el" href="slnetifwifi_8c_source.html#l00172">172</a> of file <a class="el" href="slnetifwifi_8c_source.html">slnetifwifi.c</a>.</p>
<div class="fragment"><div class="line"><a name="l00173"></a><span class="lineno">  173</span>&#160;{</div><div class="line"><a name="l00174"></a><span class="lineno">  174</span>&#160;    <span class="keywordflow">return</span> <a class="code" href="group___socket.html#ga7d864d86f8dd7296774072db021a69e7">sl_Listen</a>(sd, backlog);</div><div class="line"><a name="l00175"></a><span class="lineno">  175</span>&#160;}</div><div class="ttc" id="group___socket_html_ga7d864d86f8dd7296774072db021a69e7"><div class="ttname"><a href="group___socket.html#ga7d864d86f8dd7296774072db021a69e7">sl_Listen</a></div><div class="ttdeci">_i16 sl_Listen(_i16 sd, _i16 backlog)</div><div class="ttdoc">Listen for connections on a socket. </div><div class="ttdef"><b>Definition:</b> <a href="sl__socket_8c_source.html#l00658">sl_socket.c:658</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="gaf1220dc47c33ac6f39eee4e3d4be5343"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf1220dc47c33ac6f39eee4e3d4be5343">&sect;&nbsp;</a></span>SlNetIfWifi_loadSecObj()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t SlNetIfWifi_loadSecObj </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>ifContext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>objType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>objName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int16_t&#160;</td>
          <td class="paramname"><em>objNameLen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>objBuff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int16_t&#160;</td>
          <td class="paramname"><em>objBuffLen</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Load secured buffer to the network stack. </p>
<p>The SlNetSock_secLoadObj function loads buffer/files into the inputted network stack for future usage of the socket SSL/TLS connection. This option is relevant for network stacks with file system and also for network stacks that lack file system that can store the secured files.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ifContext</td><td>Stores interface data if CreateContext function supported and implemented. Can be used in all SlNetIf_Config_t functions </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">objType</td><td>Specifies the security object type which could be one of the following:<br />
<ul>
<li>SLNETIF_SEC_OBJ_TYPE_RSA_PRIVATE_KEY</li>
<li>SLNETIF_SEC_OBJ_TYPE_CERTIFICATE</li>
<li>SLNETIF_SEC_OBJ_TYPE_DH_KEY </li>
</ul>
</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">objName</td><td>Specifies the name/input identifier of the secured buffer loaded for file systems - this can be the file name for plain text buffer loading this can be the name of the object </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">objNameLen</td><td>Specifies the buffer name length to be loaded.<br />
</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">objBuff</td><td>Specifies the pointer to the secured buffer to be loaded.<br />
</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">objBuffLen</td><td>Specifies the buffer length to be loaded.<br />
 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>On success, buffer type handler index to be used when attaching the secured buffer to a socket.<br />
 A successful return code should be a positive number (int16)<br />
 On error, a negative value will be returned specifying the error code.<ul>
<li>SLNETERR_STATUS_ERROR - load operation failed</li>
</ul>
</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group___socket.html#gaa88290743d74f108aab46844aee496f8" title="Set socket options-. ">SlNetIfWifi_setSockOpt</a> </dd></dl>
<dl class="section note"><dt>Note</dt><dd></dd></dl>
<dl class="section warning"><dt>Warning</dt><dd></dd></dl>

<p>Definition at line <a class="el" href="slnetifwifi_8c_source.html#l00389">389</a> of file <a class="el" href="slnetifwifi_8c_source.html">slnetifwifi.c</a>.</p>
<div class="fragment"><div class="line"><a name="l00390"></a><span class="lineno">  390</span>&#160;{</div><div class="line"><a name="l00391"></a><span class="lineno">  391</span>&#160;    <span class="keywordtype">char</span>     *deviceFileName   = objName;</div><div class="line"><a name="l00392"></a><span class="lineno">  392</span>&#160;    int32_t   DeviceFileHandle = -1;</div><div class="line"><a name="l00393"></a><span class="lineno">  393</span>&#160;    int32_t   retVal;                <span class="comment">//negative retVal is an error</span></div><div class="line"><a name="l00394"></a><span class="lineno">  394</span>&#160;    uint32_t  Offset           = 0;</div><div class="line"><a name="l00395"></a><span class="lineno">  395</span>&#160;    uint32_t  MasterToken      = 0;</div><div class="line"><a name="l00396"></a><span class="lineno">  396</span>&#160;    int32_t   OpenFlags        = 0;</div><div class="line"><a name="l00397"></a><span class="lineno">  397</span>&#160;</div><div class="line"><a name="l00398"></a><span class="lineno">  398</span>&#160;    <span class="comment">/* Check if the inputs exists                                        */</span></div><div class="line"><a name="l00399"></a><span class="lineno">  399</span>&#160;    <span class="keywordflow">if</span> ( (NULL == objName) || (NULL == objBuff) )</div><div class="line"><a name="l00400"></a><span class="lineno">  400</span>&#160;    {</div><div class="line"><a name="l00401"></a><span class="lineno">  401</span>&#160;        <span class="comment">/* input not valid, return error code                            */</span></div><div class="line"><a name="l00402"></a><span class="lineno">  402</span>&#160;        <span class="keywordflow">return</span> SLNETERR_RET_CODE_INVALID_INPUT;</div><div class="line"><a name="l00403"></a><span class="lineno">  403</span>&#160;    }</div><div class="line"><a name="l00404"></a><span class="lineno">  404</span>&#160;</div><div class="line"><a name="l00405"></a><span class="lineno">  405</span>&#160;    <span class="comment">/* Create a file and write data. The file is secured, without</span></div><div class="line"><a name="l00406"></a><span class="lineno">  406</span>&#160;<span class="comment">       signature and with a fail safe commit                             */</span></div><div class="line"><a name="l00407"></a><span class="lineno">  407</span>&#160;    OpenFlags = SL_FS_CREATE;</div><div class="line"><a name="l00408"></a><span class="lineno">  408</span>&#160;    OpenFlags |= SL_FS_OVERWRITE;</div><div class="line"><a name="l00409"></a><span class="lineno">  409</span>&#160;    OpenFlags |= SL_FS_CREATE_SECURE;</div><div class="line"><a name="l00410"></a><span class="lineno">  410</span>&#160;    OpenFlags |= SL_FS_CREATE_NOSIGNATURE;</div><div class="line"><a name="l00411"></a><span class="lineno">  411</span>&#160;    OpenFlags |= SL_FS_CREATE_FAILSAFE;</div><div class="line"><a name="l00412"></a><span class="lineno">  412</span>&#160;</div><div class="line"><a name="l00413"></a><span class="lineno">  413</span>&#160;    <span class="comment">/* Create a secure file if not exists and open it for write.         */</span></div><div class="line"><a name="l00414"></a><span class="lineno">  414</span>&#160;    DeviceFileHandle =  <a class="code" href="group___file_system.html#ga16186e069ba1bcdc6eef2ab589a42a78">sl_FsOpen</a>((<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *)deviceFileName, OpenFlags | SL_FS_CREATE_MAX_SIZE( objBuffLen ), (<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> *)&amp;MasterToken);</div><div class="line"><a name="l00415"></a><span class="lineno">  415</span>&#160;</div><div class="line"><a name="l00416"></a><span class="lineno">  416</span>&#160;    <span class="comment">/* Check if file created successfully                                */</span></div><div class="line"><a name="l00417"></a><span class="lineno">  417</span>&#160;    <span class="keywordflow">if</span> ( DeviceFileHandle &lt; SLNETERR_RET_CODE_OK )</div><div class="line"><a name="l00418"></a><span class="lineno">  418</span>&#160;    {</div><div class="line"><a name="l00419"></a><span class="lineno">  419</span>&#160;        <span class="keywordflow">return</span> DeviceFileHandle;</div><div class="line"><a name="l00420"></a><span class="lineno">  420</span>&#160;    }</div><div class="line"><a name="l00421"></a><span class="lineno">  421</span>&#160;</div><div class="line"><a name="l00422"></a><span class="lineno">  422</span>&#160;    Offset = 0;</div><div class="line"><a name="l00423"></a><span class="lineno">  423</span>&#160;    <span class="comment">/* Write the buffer to the new file                                  */</span></div><div class="line"><a name="l00424"></a><span class="lineno">  424</span>&#160;    retVal = <a class="code" href="group___file_system.html#ga23d68a0f564436b6ef08325b1a159e85">sl_FsWrite</a>(DeviceFileHandle, Offset, (<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *)objBuff, objBuffLen);</div><div class="line"><a name="l00425"></a><span class="lineno">  425</span>&#160;</div><div class="line"><a name="l00426"></a><span class="lineno">  426</span>&#160;    <span class="comment">/* Close the file                                                    */</span></div><div class="line"><a name="l00427"></a><span class="lineno">  427</span>&#160;    retVal = <a class="code" href="group___file_system.html#ga12caded07ff4c66e5b6e73a36009072d">sl_FsClose</a>(DeviceFileHandle, NULL, NULL , 0);</div><div class="line"><a name="l00428"></a><span class="lineno">  428</span>&#160;</div><div class="line"><a name="l00429"></a><span class="lineno">  429</span>&#160;    <span class="keywordflow">return</span> retVal;</div><div class="line"><a name="l00430"></a><span class="lineno">  430</span>&#160;}</div><div class="ttc" id="group___file_system_html_ga16186e069ba1bcdc6eef2ab589a42a78"><div class="ttname"><a href="group___file_system.html#ga16186e069ba1bcdc6eef2ab589a42a78">sl_FsOpen</a></div><div class="ttdeci">_i32 sl_FsOpen(const _u8 *pFileName, const _u32 AccessModeAndMaxSize, _u32 *pToken)</div><div class="ttdoc">open file for read or write from/to storage device </div><div class="ttdef"><b>Definition:</b> <a href="fs_8c_source.html#l00163">fs.c:163</a></div></div>
<div class="ttc" id="group___file_system_html_ga12caded07ff4c66e5b6e73a36009072d"><div class="ttname"><a href="group___file_system.html#ga12caded07ff4c66e5b6e73a36009072d">sl_FsClose</a></div><div class="ttdeci">_i16 sl_FsClose(const _i32 FileHdl, const _u8 *pCeritificateFileName, const _u8 *pSignature, const _u32 SignatureLen)</div><div class="ttdoc">Close file in storage device. </div><div class="ttdef"><b>Definition:</b> <a href="fs_8c_source.html#l00256">fs.c:256</a></div></div>
<div class="ttc" id="group___file_system_html_ga23d68a0f564436b6ef08325b1a159e85"><div class="ttname"><a href="group___file_system.html#ga23d68a0f564436b6ef08325b1a159e85">sl_FsWrite</a></div><div class="ttdeci">_i32 sl_FsWrite(const _i32 FileHdl, _u32 Offset, _u8 *pData, _u32 Len)</div><div class="ttdoc">Write block of data to a file in storage device. </div><div class="ttdef"><b>Definition:</b> <a href="fs_8c_source.html#l00385">fs.c:385</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="gabfa0d07de48de4a955bb39263e865adc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabfa0d07de48de4a955bb39263e865adc">&sect;&nbsp;</a></span>SlNetIfWifi_recv()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t SlNetIfWifi_recv </td>
          <td>(</td>
          <td class="paramtype">int16_t&#160;</td>
          <td class="paramname"><em>sd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>sdContext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read data from TCP socket. </p>
<p>The SlNetIfWifi_recv function receives a message from a connection-mode socket</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">sd</td><td>Socket descriptor (handle) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">sdContext</td><td>May store socket data if implemented in the SlNetIfWifi_socket function. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">buf</td><td>Points to the buffer where the message should be stored. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">len</td><td>Specifies the length in bytes of the buffer pointed to by the buffer argument. Range: 1-16000 bytes </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">flags</td><td>Upper 8 bits specifies the security flags Lower 24 bits specifies the type of message reception. On this version, the lower 24 bits are not supported</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Return the number of bytes received, or a negative value if an error occurred.<br />
 Using a non-blocking recv a possible negative value is SLNETERR_BSD_EAGAIN.<br />
 SLNETERR_BSD_ENOMEM may be return in case there are no resources in the system In this case try again later or increase MAX_CONCURRENT_ACTIONS</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group___socket.html#gafe9672d3c7813b7f414fb57421f92063" title="Read data from socket. ">SlNetIfWifi_recvFrom</a> </dd></dl>
<dl class="section note"><dt>Note</dt><dd></dd></dl>
<dl class="section warning"><dt>Warning</dt><dd></dd></dl>
<dl class="section user"><dt>Examples</dt><dd></dd></dl>
<ul>
<li>Receiving data using TCP socket: <div class="fragment"><div class="line">SlNetSock_AddrIn_t  Addr;</div><div class="line">SlNetSock_AddrIn_t  LocalAddr;</div><div class="line">int16_t AddrSize = <span class="keyword">sizeof</span>(SlNetSock_AddrIn_t);</div><div class="line">int16_t SockID, newSockID;</div><div class="line">int16_t Status;</div><div class="line">int8_t Buf[RECV_BUF_LEN];</div><div class="line"></div><div class="line">LocalAddr.sin_family = SLNETSOCK_AF_INET;</div><div class="line">LocalAddr.sin_port = SlNetSock_htons(5001);</div><div class="line">LocalAddr.sin_addr.s_addr = 0;</div><div class="line"></div><div class="line">Addr.sin_family = SLNETSOCK_AF_INET;</div><div class="line">Addr.sin_port = SlNetSock_htons(5001);</div><div class="line">Addr.sin_addr.s_addr = SlNetSock_htonl(SLNETSOCK_IPV4_VAL(10,1,1,200));</div><div class="line"></div><div class="line">SockID = <a class="code" href="group___socket.html#ga727dd5a1c20faa5d718cb5a2724b0981">SlNetIfWifi_socket</a>(SLNETSOCK_AF_INET, SLNETSOCK_SOCK_STREAM, 0, 0, 0);</div><div class="line">Status = <a class="code" href="group___socket.html#gad86c6b5d5ecb41afcafa1026b2bd542b">SlNetIfWifi_bind</a>(SockID, (SlNetSock_Addr_t *)&amp;LocalAddr, AddrSize);</div><div class="line">Status = <a class="code" href="group___socket.html#ga911c4ed3bb7039b3274ecd09f7df6e04">SlNetIfWifi_listen</a>(SockID, 0);</div><div class="line">newSockID = <a class="code" href="group___socket.html#gafc0cdc3f19064c810f4d5f723384502d">SlNetIfWifi_accept</a>(SockID, (SlNetSock_Addr_t*)&amp;Addr, (SlNetSocklen_t*) &amp;AddrSize);</div><div class="line">Status = <a class="code" href="group___socket.html#gabfa0d07de48de4a955bb39263e865adc">SlNetIfWifi_recv</a>(newSockID, Buf, 1460, 0);</div></div><!-- fragment --> <br />
</li>
<li>Rx transceiver mode using a raw socket: <div class="fragment"><div class="line">int8_t buffer[1536];</div><div class="line">int16_t sd;</div><div class="line">uint16_t size;</div><div class="line">SlNetSock_TransceiverRxOverHead_t *transHeader;</div><div class="line">sd = <a class="code" href="group___socket.html#ga727dd5a1c20faa5d718cb5a2724b0981">SlNetIfWifi_socket</a>(SLNETSOCK_AF_RF, SLNETSOCK_SOCK_RAW, 11, 0, 0); <span class="comment">// channel 11</span></div><div class="line"><span class="keywordflow">while</span>(1)</div><div class="line">{</div><div class="line">    size = <a class="code" href="group___socket.html#gabfa0d07de48de4a955bb39263e865adc">SlNetIfWifi_recv</a>(sd,buffer,1536,0);</div><div class="line">    transHeader = (SlNetSock_TransceiverRxOverHead_t *)buffer;</div><div class="line">    printf(<span class="stringliteral">&quot;RSSI is %d frame type is 0x%x size %d\n&quot;</span>,transHeader-&gt;rssi,buffer[<span class="keyword">sizeof</span>(SlNetSock_TransceiverRxOverHead_t)],size);</div><div class="line">}</div></div><!-- fragment --> </li>
</ul>

<p>Definition at line <a class="el" href="slnetifwifi_8c_source.html#l00240">240</a> of file <a class="el" href="slnetifwifi_8c_source.html">slnetifwifi.c</a>.</p>
<div class="fragment"><div class="line"><a name="l00241"></a><span class="lineno">  241</span>&#160;{</div><div class="line"><a name="l00242"></a><span class="lineno">  242</span>&#160;    DISABLE_SEC_BITS_FROM_INPUT_FLAGS(flags);</div><div class="line"><a name="l00243"></a><span class="lineno">  243</span>&#160;    <span class="keywordflow">return</span> <a class="code" href="group___socket.html#ga26a0eacfbab2629e7f3daa0ad0080255">sl_Recv</a>(sd, buf, len, flags);</div><div class="line"><a name="l00244"></a><span class="lineno">  244</span>&#160;}</div><div class="ttc" id="group___socket_html_ga26a0eacfbab2629e7f3daa0ad0080255"><div class="ttname"><a href="group___socket.html#ga26a0eacfbab2629e7f3daa0ad0080255">sl_Recv</a></div><div class="ttdeci">_i16 sl_Recv(_i16 sd, void *buf, _i16 len, _i16 flags)</div><div class="ttdoc">Read data from TCP socket. </div><div class="ttdef"><b>Definition:</b> <a href="sl__socket_8c_source.html#l00874">sl_socket.c:874</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="gafe9672d3c7813b7f414fb57421f92063"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafe9672d3c7813b7f414fb57421f92063">&sect;&nbsp;</a></span>SlNetIfWifi_recvFrom()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t SlNetIfWifi_recvFrom </td>
          <td>(</td>
          <td class="paramtype">int16_t&#160;</td>
          <td class="paramname"><em>sd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>sdContext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SlNetSock_Addr_t *&#160;</td>
          <td class="paramname"><em>from</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SlNetSocklen_t *&#160;</td>
          <td class="paramname"><em>fromlen</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read data from socket. </p>
<p>SlNetIfWifi_recvFrom function receives a message from a connection-mode or connectionless-mode socket</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">sd</td><td>Socket descriptor (handle) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">sdContext</td><td>May store socket data if implemented in the SlNetIfWifi_socket function. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">buf</td><td>Points to the buffer where the message should be stored. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">len</td><td>Specifies the length in bytes of the buffer pointed to by the buffer argument. Range: 1-16000 bytes </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">flags</td><td>Upper 8 bits specifies the security flags Lower 24 bits specifies the type of message reception. On this version, the lower 24 bits are not supported </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">from</td><td>Pointer to an address structure indicating the source address.<br />
 sockaddr:<br />
 - code for the address format.<br />
 - socket address, the length depends on the code format </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">fromlen</td><td>Source address structure size. This parameter MUST be set to the size of the structure pointed to by addr.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Return the number of bytes received, or a negative value if an error occurred.<br />
 Using a non-blocking recv a possible negative value is SLNETERR_BSD_EAGAIN. SLNETSOCK_RET_CODE_INVALID_INPUT (-2) will be returned if fromlen has incorrect length. <br />
 SLNETERR_BSD_ENOMEM may be return in case there are no resources in the system In this case try again later or increase MAX_CONCURRENT_ACTIONS</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group___socket.html#gabfa0d07de48de4a955bb39263e865adc" title="Read data from TCP socket. ">SlNetIfWifi_recv</a> </dd></dl>
<dl class="section note"><dt>Note</dt><dd></dd></dl>
<dl class="section warning"><dt>Warning</dt><dd></dd></dl>
<dl class="section user"><dt>Example</dt><dd></dd></dl>
<ul>
<li>Receiving data: <div class="fragment"><div class="line">SlNetSock_AddrIn_t  Addr;</div><div class="line">SlNetSock_AddrIn_t  LocalAddr;</div><div class="line">int16_t AddrSize = <span class="keyword">sizeof</span>(SlNetSock_AddrIn_t);</div><div class="line">int16_t SockID;</div><div class="line">int16_t Status;</div><div class="line">int8_t Buf[RECV_BUF_LEN];</div><div class="line"></div><div class="line">LocalAddr.sin_family = SLNETSOCK_AF_INET;</div><div class="line">LocalAddr.sin_port = SlNetSock_htons(5001);</div><div class="line">LocalAddr.sin_addr.s_addr = 0;</div><div class="line"></div><div class="line">SockID = <a class="code" href="group___socket.html#ga727dd5a1c20faa5d718cb5a2724b0981">SlNetIfWifi_socket</a>(SLNETSOCK_AF_INET, SLNETSOCK_SOCK_DGRAM, 0, 0, 0);</div><div class="line">Status = <a class="code" href="group___socket.html#gad86c6b5d5ecb41afcafa1026b2bd542b">SlNetIfWifi_bind</a>(SockID, (SlNetSock_Addr_t *)&amp;LocalAddr, AddrSize);</div><div class="line">Status = <a class="code" href="group___socket.html#gafe9672d3c7813b7f414fb57421f92063">SlNetIfWifi_recvFrom</a>(SockID, Buf, 1472, 0, (SlNetSock_Addr_t *)&amp;Addr, (SlNetSocklen_t*)&amp;AddrSize);</div></div><!-- fragment --> </li>
</ul>

<p>Definition at line <a class="el" href="slnetifwifi_8c_source.html#l00252">252</a> of file <a class="el" href="slnetifwifi_8c_source.html">slnetifwifi.c</a>.</p>
<div class="fragment"><div class="line"><a name="l00253"></a><span class="lineno">  253</span>&#160;{</div><div class="line"><a name="l00254"></a><span class="lineno">  254</span>&#160;    DISABLE_SEC_BITS_FROM_INPUT_FLAGS(flags);</div><div class="line"><a name="l00255"></a><span class="lineno">  255</span>&#160;    <span class="keywordflow">return</span> <a class="code" href="group___socket.html#ga02f8b2eb34db39069a1385d4fce80eea">sl_RecvFrom</a>(sd, buf, len, flags, (<a class="code" href="group___socket.html#struct_sl_sock_addr__t">SlSockAddr_t</a> *)from, fromlen);</div><div class="line"><a name="l00256"></a><span class="lineno">  256</span>&#160;}</div><div class="ttc" id="group___socket_html_struct_sl_sock_addr__t"><div class="ttname"><a href="group___socket.html#struct_sl_sock_addr__t">SlSockAddr_t</a></div><div class="ttdef"><b>Definition:</b> <a href="sl__socket_8h_source.html#l00387">sl_socket.h:387</a></div></div>
<div class="ttc" id="group___socket_html_ga02f8b2eb34db39069a1385d4fce80eea"><div class="ttname"><a href="group___socket.html#ga02f8b2eb34db39069a1385d4fce80eea">sl_RecvFrom</a></div><div class="ttdeci">_i16 sl_RecvFrom(_i16 sd, void *buf, _i16 len, _i16 flags, SlSockAddr_t *from, SlSocklen_t *fromlen)</div><div class="ttdoc">Read data from socket. </div><div class="ttdef"><b>Definition:</b> <a href="sl__socket_8c_source.html#l00367">sl_socket.c:367</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="ga599feb994650b8842573eebc9e65eaea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga599feb994650b8842573eebc9e65eaea">&sect;&nbsp;</a></span>SlNetIfWifi_select()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t SlNetIfWifi_select </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>ifContext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int16_t&#160;</td>
          <td class="paramname"><em>nfds</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SlNetSock_SdSet_t *&#160;</td>
          <td class="paramname"><em>readsds</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SlNetSock_SdSet_t *&#160;</td>
          <td class="paramname"><em>writesds</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SlNetSock_SdSet_t *&#160;</td>
          <td class="paramname"><em>exceptsds</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SlNetSock_Timeval_t *&#160;</td>
          <td class="paramname"><em>timeout</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Monitor socket activity. </p>
<p>SlNetIfWifi_send allow a program to monitor multiple file descriptors, waiting until one or more of the file descriptors become "ready" for some class of I/O operation. If trigger mode is enabled the active sdset is the one that retrieved in the first triggered call. To enable the trigger mode, an handler must be statically registered to the slcb_SocketTriggerEventHandler (<a class="el" href="user_8h_source.html">user.h</a>)</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ifContext</td><td>Stores interface data if CreateContext function supported and implemented. Can be used in all SlNetIf_Config_t functions </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nsds</td><td>The highest-numbered file descriptor in any of the three sets, plus 1. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">readsds</td><td>Socket descriptors list for read monitoring and accept monitoring </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">writesds</td><td>Socket descriptors list for connect monitoring only, write monitoring is not supported </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">exceptsds</td><td>Socket descriptors list for exception monitoring, not supported. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">timeout</td><td>Is an upper bound on the amount of time elapsed before <a class="el" href="group___socket.html#ga7c6f32b5a1821e1ee95d1c30453022d3" title="Write data to TCP socket. ">SlNetIfWifi_send()</a> returns. Null or above 0xffff seconds means infinity timeout. The minimum timeout is 10 milliseconds, less than 10 milliseconds will be set automatically to 10 milliseconds. Max microseconds supported is 0xfffc00. In trigger mode the timeout fields must be set to zero.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>On success, <a class="el" href="group___socket.html#ga7c6f32b5a1821e1ee95d1c30453022d3" title="Write data to TCP socket. ">SlNetIfWifi_send()</a> returns the number of file descriptors contained in the three returned descriptor sets (that is, the total number of bits that are set in readsds, writesds, exceptsds) which may be zero if the timeout expires before anything interesting happens.<br />
 On error, a negative value is returned. readsds - return the sockets on which Read request will return without delay with valid data.<br />
 writesds - return the sockets on which Write request will return without delay.<br />
 exceptsds - return the sockets closed recently. <br />
 SLNETERR_BSD_ENOMEM may be return in case there are no resources in the system In this case try again later or increase MAX_CONCURRENT_ACTIONS</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group___socket.html#ga727dd5a1c20faa5d718cb5a2724b0981" title="Create an endpoint for communication. ">SlNetIfWifi_socket</a> </dd></dl>
<dl class="section note"><dt>Note</dt><dd>If the timeout value set to less than 10ms it will automatically set to 10ms to prevent overload of the system<br />
 Only one SlNetIfWifi_send can be handled at a time. <b>Calling</b> this API while the same command is called from another thread, may result in one of the following scenarios:<ol type="1">
<li>The command will wait (internal) until the previous command finish, and then be executed.</li>
<li>There are not enough resources and SLNETERR_BSD_ENOMEM error will return. In this case, MAX_CONCURRENT_ACTIONS can be increased (result in memory increase) or try again later to issue the command.</li>
<li>In case there is already a triggered SlNetIfWifi_send in progress, the following call will return with SLNETSOCK_RET_CODE_SOCKET_SELECT_IN_PROGRESS_ERROR.</li>
</ol>
</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd></dd></dl>

<p>Definition at line <a class="el" href="slnetifwifi_8c_source.html#l00207">207</a> of file <a class="el" href="slnetifwifi_8c_source.html">slnetifwifi.c</a>.</p>
<div class="fragment"><div class="line"><a name="l00208"></a><span class="lineno">  208</span>&#160;{</div><div class="line"><a name="l00209"></a><span class="lineno">  209</span>&#160;    <span class="keywordflow">return</span> <a class="code" href="group___socket.html#ga97747fea9f469feeb7272b76e4fe9a0e">sl_Select</a>(nfds, (<a class="code" href="group___socket.html#struct_sl_fd_set__t">SlFdSet_t</a> *)readsds, (<a class="code" href="group___socket.html#struct_sl_fd_set__t">SlFdSet_t</a> *)writesds, (<a class="code" href="group___socket.html#struct_sl_fd_set__t">SlFdSet_t</a> *)exceptsds, (<span class="keyword">struct</span> <a class="code" href="group___socket.html#struct_sl_timeval__t">SlTimeval_t</a> *)timeout);</div><div class="line"><a name="l00210"></a><span class="lineno">  210</span>&#160;}</div><div class="ttc" id="group___socket_html_ga97747fea9f469feeb7272b76e4fe9a0e"><div class="ttname"><a href="group___socket.html#ga97747fea9f469feeb7272b76e4fe9a0e">sl_Select</a></div><div class="ttdeci">_i16 sl_Select(_i16 nfds, SlFdSet_t *readsds, SlFdSet_t *writesds, SlFdSet_t *exceptsds, struct SlTimeval_t *timeout)</div><div class="ttdoc">Monitor socket activity. </div><div class="ttdef"><b>Definition:</b> <a href="sl__socket_8c_source.html#l01707">sl_socket.c:1707</a></div></div>
<div class="ttc" id="group___socket_html_struct_sl_timeval__t"><div class="ttname"><a href="group___socket.html#struct_sl_timeval__t">SlTimeval_t</a></div><div class="ttdef"><b>Definition:</b> <a href="sl__socket_8h_source.html#l00378">sl_socket.h:378</a></div></div>
<div class="ttc" id="group___socket_html_struct_sl_fd_set__t"><div class="ttname"><a href="group___socket.html#struct_sl_fd_set__t">SlFdSet_t</a></div><div class="ttdef"><b>Definition:</b> <a href="sl__socket_8h_source.html#l00417">sl_socket.h:417</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="ga7c6f32b5a1821e1ee95d1c30453022d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7c6f32b5a1821e1ee95d1c30453022d3">&sect;&nbsp;</a></span>SlNetIfWifi_send()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t SlNetIfWifi_send </td>
          <td>(</td>
          <td class="paramtype">int16_t&#160;</td>
          <td class="paramname"><em>sd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>sdContext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write data to TCP socket. </p>
<p>The SlNetIfWifi_send function is used to transmit a message to another socket. Returns immediately after sending data to device. In case of TCP failure an async event SLNETSOCK_SOCKET_TX_FAILED_EVENT is going to be received.<br />
In case of a RAW socket (transceiver mode), extra 4 bytes should be reserved at the end of the frame data buffer for WLAN FCS</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">sd</td><td>Socket descriptor (handle) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">sdContext</td><td>May store socket data if implemented in the SlNetIfWifi_socket function. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">buf</td><td>Points to a buffer containing the message to be sent </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">len</td><td>Message size in bytes. Range: 1-1460 bytes </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">flags</td><td>Upper 8 bits specifies the security flags Lower 24 bits specifies the type of message reception. On this version, the lower 24 bits are not supported for TCP. For transceiver mode, the SLNETSOCK_WLAN_RAW_RF_TX_PARAMS macro can be used to determine transmission parameters (channel,rate,tx_power,preamble)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Zero on success, or negative error code on failure</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group___socket.html#ga547e0e6febe3702cd5ba758c0d0b3d01" title="Write data to socket. ">SlNetIfWifi_sendTo</a> </dd></dl>
<dl class="section note"><dt>Note</dt><dd></dd></dl>
<dl class="section warning"><dt>Warning</dt><dd></dd></dl>
<dl class="section user"><dt>Example</dt><dd></dd></dl>
<ul>
<li>Sending data: <div class="fragment"><div class="line">SlNetSock_AddrIn_t  Addr;</div><div class="line">int16_t AddrSize = <span class="keyword">sizeof</span>(SlNetSock_AddrIn_t);</div><div class="line">int16_t SockID;</div><div class="line">int16_t Status;</div><div class="line">int8_t Buf[SEND_BUF_LEN];</div><div class="line"></div><div class="line">Addr.sin_family = SLNETSOCK_AF_INET;</div><div class="line">Addr.sin_port = SlNetSock_htons(5001);</div><div class="line">Addr.sin_addr.s_addr = SlNetSock_htonl(SLNETSOCK_IPV4_VAL(10,1,1,200));</div><div class="line"></div><div class="line">SockID = <a class="code" href="group___socket.html#ga727dd5a1c20faa5d718cb5a2724b0981">SlNetIfWifi_socket</a>(SLNETSOCK_AF_INET, SLNETSOCK_SOCK_STREAM, 0, 0, 0);</div><div class="line">Status = <a class="code" href="group___socket.html#gadfedf7a7ca8571caa534535169830980">SlNetIfWifi_connect</a>(SockID, (SlNetSock_Addr_t *)&amp;Addr, AddrSize);</div><div class="line">Status = <a class="code" href="group___socket.html#ga7c6f32b5a1821e1ee95d1c30453022d3">SlNetIfWifi_send</a>(SockID, Buf, 1460, 0 );</div></div><!-- fragment --> </li>
</ul>

<p>Definition at line <a class="el" href="slnetifwifi_8c_source.html#l00264">264</a> of file <a class="el" href="slnetifwifi_8c_source.html">slnetifwifi.c</a>.</p>
<div class="fragment"><div class="line"><a name="l00265"></a><span class="lineno">  265</span>&#160;{</div><div class="line"><a name="l00266"></a><span class="lineno">  266</span>&#160;    DISABLE_SEC_BITS_FROM_INPUT_FLAGS(flags);</div><div class="line"><a name="l00267"></a><span class="lineno">  267</span>&#160;    <span class="keywordflow">return</span> <a class="code" href="group___socket.html#ga2fc8c293bbcb796217076329e1bac518">sl_Send</a>(sd, buf, len, flags);</div><div class="line"><a name="l00268"></a><span class="lineno">  268</span>&#160;}</div><div class="ttc" id="group___socket_html_ga2fc8c293bbcb796217076329e1bac518"><div class="ttname"><a href="group___socket.html#ga2fc8c293bbcb796217076329e1bac518">sl_Send</a></div><div class="ttdeci">_i16 sl_Send(_i16 sd, const void *buf, _i16 len, _i16 flags)</div><div class="ttdoc">Write data to TCP socket. </div><div class="ttdef"><b>Definition:</b> <a href="sl__socket_8c_source.html#l00594">sl_socket.c:594</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="ga547e0e6febe3702cd5ba758c0d0b3d01"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga547e0e6febe3702cd5ba758c0d0b3d01">&sect;&nbsp;</a></span>SlNetIfWifi_sendTo()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t SlNetIfWifi_sendTo </td>
          <td>(</td>
          <td class="paramtype">int16_t&#160;</td>
          <td class="paramname"><em>sd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>sdContext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const SlNetSock_Addr_t *&#160;</td>
          <td class="paramname"><em>to</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SlNetSocklen_t&#160;</td>
          <td class="paramname"><em>tolen</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write data to socket. </p>
<p>The SlNetIfWifi_sendTo function is used to transmit a message on a connectionless socket (connection less socket SLNETSOCK_SOCK_DGRAM, SLNETSOCK_SOCK_RAW).<br />
Returns immediately after sending data to device.<br />
In case of transmission failure an async event SLNETSOCK_SOCKET_TX_FAILED_EVENT is going to be received.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">sd</td><td>Socket descriptor (handle) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">sdContext</td><td>May store socket data if implemented in the SlNetIfWifi_socket function. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">buf</td><td>Points to a buffer containing the message to be sent </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">len</td><td>message size in bytes. Range: 1-1460 bytes </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">flags</td><td>Upper 8 bits specifies the security flags Lower 24 bits specifies the type of message reception. On this version, the lower 24 bits are not supported </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">to</td><td>Pointer to an address structure indicating the destination address.<br />
 sockaddr:<br />
 - code for the address format.<br />
 - socket address, the length depends on the code format </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">tolen</td><td>Destination address structure size</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Zero on success, or negative error code on failure</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group___socket.html#ga7c6f32b5a1821e1ee95d1c30453022d3" title="Write data to TCP socket. ">SlNetIfWifi_send</a> </dd></dl>
<dl class="section note"><dt>Note</dt><dd></dd></dl>
<dl class="section warning"><dt>Warning</dt><dd></dd></dl>
<dl class="section user"><dt>Example</dt><dd></dd></dl>
<ul>
<li>Sending data: <div class="fragment"><div class="line">SlNetSock_AddrIn_t  Addr;</div><div class="line">int16_t AddrSize = <span class="keyword">sizeof</span>(SlNetSock_AddrIn_t);</div><div class="line">int16_t SockID;</div><div class="line">int16_t Status;</div><div class="line">int8_t Buf[SEND_BUF_LEN];</div><div class="line"></div><div class="line">Addr.sin_family = SLNETSOCK_AF_INET;</div><div class="line">Addr.sin_port = SlNetSock_htons(5001);</div><div class="line">Addr.sin_addr.s_addr = SlNetSock_htonl(SLNETSOCK_IPV4_VAL(10,1,1,200));</div><div class="line"></div><div class="line">SockID = <a class="code" href="group___socket.html#ga727dd5a1c20faa5d718cb5a2724b0981">SlNetIfWifi_socket</a>(SLNETSOCK_AF_INET, SLNETSOCK_SOCK_DGRAM, 0, 0, 0);</div><div class="line">Status = <a class="code" href="group___socket.html#ga547e0e6febe3702cd5ba758c0d0b3d01">SlNetIfWifi_sendTo</a>(SockID, Buf, 1472, 0, (SlNetSock_Addr_t *)&amp;Addr, AddrSize);</div></div><!-- fragment --> </li>
</ul>

<p>Definition at line <a class="el" href="slnetifwifi_8c_source.html#l00276">276</a> of file <a class="el" href="slnetifwifi_8c_source.html">slnetifwifi.c</a>.</p>
<div class="fragment"><div class="line"><a name="l00277"></a><span class="lineno">  277</span>&#160;{</div><div class="line"><a name="l00278"></a><span class="lineno">  278</span>&#160;    DISABLE_SEC_BITS_FROM_INPUT_FLAGS(flags);</div><div class="line"><a name="l00279"></a><span class="lineno">  279</span>&#160;    <span class="keywordflow">return</span> <a class="code" href="group___socket.html#ga7ca76d181974c71673c3bf3fc1fedfdc">sl_SendTo</a>(sd, buf, len, flags, (<span class="keyword">const</span> <a class="code" href="group___socket.html#struct_sl_sock_addr__t">SlSockAddr_t</a> *)to, tolen);</div><div class="line"><a name="l00280"></a><span class="lineno">  280</span>&#160;}</div><div class="ttc" id="group___socket_html_struct_sl_sock_addr__t"><div class="ttname"><a href="group___socket.html#struct_sl_sock_addr__t">SlSockAddr_t</a></div><div class="ttdef"><b>Definition:</b> <a href="sl__socket_8h_source.html#l00387">sl_socket.h:387</a></div></div>
<div class="ttc" id="group___socket_html_ga7ca76d181974c71673c3bf3fc1fedfdc"><div class="ttname"><a href="group___socket.html#ga7ca76d181974c71673c3bf3fc1fedfdc">sl_SendTo</a></div><div class="ttdeci">_i16 sl_SendTo(_i16 sd, const void *buf, _i16 len, _i16 flags, const SlSockAddr_t *to, SlSocklen_t tolen)</div><div class="ttdoc">Write data to socket. </div><div class="ttdef"><b>Definition:</b> <a href="sl__socket_8c_source.html#l00288">sl_socket.c:288</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="gaa88290743d74f108aab46844aee496f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa88290743d74f108aab46844aee496f8">&sect;&nbsp;</a></span>SlNetIfWifi_setSockOpt()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t SlNetIfWifi_setSockOpt </td>
          <td>(</td>
          <td class="paramtype">int16_t&#160;</td>
          <td class="paramname"><em>sd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>sdContext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int16_t&#160;</td>
          <td class="paramname"><em>level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int16_t&#160;</td>
          <td class="paramname"><em>optname</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>optval</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SlNetSocklen_t&#160;</td>
          <td class="paramname"><em>optlen</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set socket options-. </p>
<p>The SlNetIfWifi_setSockOpt function manipulate the options associated with a socket.<br />
Options may exist at multiple protocol levels; they are always present at the uppermost socket level.<br />
 When manipulating socket options the level at which the option resides and the name of the option must be specified. To manipulate options at the socket level, level is specified as SOL_SOCKET. To manipulate options at any other level the protocol number of the appropriate protocol controlling the option is supplied. For example, to indicate that an option is to be interpreted by the TCP protocol, level should be set to the protocol number of TCP; <br />
 The parameters optval and optlen are used to access opt_values for <a class="el" href="group___socket.html#gaa88290743d74f108aab46844aee496f8" title="Set socket options-. ">SlNetIfWifi_setSockOpt()</a>. For <a class="el" href="group___socket.html#ga9fc02898bc65c0a0c55de78355436682" title="Get socket options. ">SlNetIfWifi_getSockOpt()</a> they identify a buffer in which the value for the requested option(s) are to be returned. For <a class="el" href="group___socket.html#ga9fc02898bc65c0a0c55de78355436682" title="Get socket options. ">SlNetIfWifi_getSockOpt()</a>, optlen is a value-result parameter, initially containing the size of the buffer pointed to by option_value, and modified on return to indicate the actual size of the value returned. If no option value is to be supplied or returned, option_value may be NULL.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">sd</td><td>Socket descriptor (handle) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">sdContext</td><td>May store socket data if implemented in the SlNetIfWifi_socket function. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">level</td><td>Defines the protocol level for this option<ul>
<li><b>SLNETSOCK_LVL_SOCKET</b> Socket level configurations (L4, transport layer)</li>
<li><b>SLNETSOCK_LVL_IP</b> IP level configurations (L3, network layer)</li>
<li><b>SLNETSOCK_LVL_PHY</b> Link level configurations (L2, link layer) </li>
</ul>
</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">optname</td><td>Defines the option name to interrogate<ul>
<li><b>SLNETSOCK_LVL_SOCKET</b><ul>
<li><b>SLNETSOCK_OPSOCK_RCV_BUF</b> <br />
 Sets tcp max recv window size. <br />
 This options takes SlNetSock_Winsize_t struct as parameter</li>
<li><b>SLNETSOCK_OPSOCK_RCV_TIMEO</b> <br />
 Sets the timeout value that specifies the maximum amount of time an input function waits until it completes. <br />
 Default: No timeout <br />
 This options takes SlNetSock_Timeval_t struct as parameter</li>
<li><b>SLNETSOCK_OPSOCK_KEEPALIVE</b> <br />
 Enable or Disable periodic keep alive. Keeps TCP connections active by enabling the periodic transmission of messages <br />
 Timeout is 5 minutes.<br />
 Default: Enabled <br />
 This options takes SlNetSock_Keepalive_t struct as parameter</li>
<li><b>SLNETSOCK_OPSOCK_KEEPALIVE_TIME</b> <br />
 Set keep alive timeout. Value is in seconds <br />
 Default: 5 minutes <br />
</li>
<li><b>SLNETSOCK_OPSOCK_LINGER</b> <br />
 Socket lingers on close pending remaining send/receive packets<br />
</li>
<li><b>SLNETSOCK_OPSOCK_NON_BLOCKING</b> <br />
 Sets socket to non-blocking operation Impacts: connect, accept, send, sendto, recv and recvfrom. <br />
 Default: Blocking. This options takes SlNetSock_Nonblocking_t struct as parameter</li>
<li><b>SLNETSOCK_OPSOCK_NON_IP_BOUNDARY</b> <br />
 Enable or Disable rx ip boundary. In connectionless socket (udp/raw), unread data is dropped (when SlNetIfWifi_recvfrom len parameter &lt; data size), Enable this option in order to read the left data on the next SlNetIfWifi_recvfrom iteration Default: Disabled, IP boundary kept, <br />
 This options takes SlNetSock_NonIpBoundary_t struct as parameter</li>
</ul>
</li>
<li><b>SLNETSOCK_LVL_IP</b><ul>
<li><b>SLNETSOCK_OPIP_MULTICAST_TTL</b> <br />
 Set the time-to-live value of outgoing multicast packets for this socket. <br />
 This options takes <b>uint8_t</b> as parameter</li>
<li><b>SLNETSOCK_OPIP_ADD_MEMBERSHIP</b> <br />
 UDP socket, Join a multicast group. <br />
 This options takes SlNetSock_IpMreq_t struct as parameter</li>
<li><b>SLNETSOCK_OPIP_DROP_MEMBERSHIP</b> <br />
 UDP socket, Leave a multicast group <br />
 This options takes SlNetSock_IpMreq_t struct as parameter</li>
<li><b>SLNETSOCK_OPIP_HDRINCL</b> <br />
 RAW socket only, the IPv4 layer generates an IP header when sending a packet unless <br />
 the IP_HDRINCL socket option is enabled on the socket. <br />
 When it is enabled, the packet must contain an IP header. <br />
 Default: disabled, IPv4 header generated by Network Stack <br />
 This options takes <b>uint32_t</b> as parameter</li>
<li><b>SLNETSOCK_OPIP_RAW_RX_NO_HEADER</b> <br />
 Raw socket remove IP header from received data. <br />
 Default: data includes ip header <br />
 This options takes <b>uint32_t</b> as parameter</li>
<li><b>SLNETSOCK_OPIP_RAW_IPV6_HDRINCL</b> (inactive) <br />
 RAW socket only, the IPv6 layer generates an IP header when sending a packet unless <br />
 the IP_HDRINCL socket option is enabled on the socket. When it is enabled, the packet must contain an IP header <br />
 Default: disabled, IPv4 header generated by Network Stack <br />
 This options takes <b>uint32_t</b> as parameter</li>
</ul>
</li>
<li><b>SLNETSOCK_LVL_PHY</b><ul>
<li><b>SLNETSOCK_OPPHY_CHANNEL</b> <br />
 Sets channel in transceiver mode. This options takes <b>uint32_t</b> as channel number parameter</li>
<li><b>SLNETSOCK_OPPHY_RATE</b> <br />
 RAW socket, set WLAN PHY transmit rate <br />
 The values are based on SlWlanRateIndex_e <br />
 This options takes <b>uint32_t</b> as parameter</li>
<li><b>SLNETSOCK_OPPHY_TX_POWER</b> <br />
 RAW socket, set WLAN PHY TX power <br />
 Valid rage is 1-15 <br />
 This options takes <b>uint32_t</b> as parameter</li>
<li><b>SLNETSOCK_OPPHY_NUM_FRAMES_TO_TX</b> <br />
 RAW socket, set number of frames to transmit in transceiver mode. Default: 1 packet This options takes <b>uint32_t</b> as parameter</li>
<li><b>SLNETSOCK_OPPHY_PREAMBLE</b> <br />
 RAW socket, set WLAN PHY preamble for Long/Short<br />
 This options takes <b>uint32_t</b> as parameter</li>
<li><b>SLNETSOCK_OPPHY_TX_INHIBIT_THRESHOLD</b> <br />
 RAW socket, set WLAN Tx - Set CCA threshold. <br />
 The values are based on SlNetSockTxInhibitThreshold_e <br />
 This options takes <b>uint32_t</b> as parameter</li>
<li><b>SLNETSOCK_OPPHY_TX_TIMEOUT</b> <br />
 RAW socket, set WLAN Tx - changes the TX timeout (lifetime) of transceiver frames. <br />
 Value in Ms, maximum value is 10ms <br />
 This options takes <b>uint32_t</b> as parameter</li>
<li><b>SLNETSOCK_OPPHY_ALLOW_ACKS </b> <br />
 RAW socket, set WLAN Tx - Enable or Disable sending ACKs in transceiver mode <br />
 0 = disabled / 1 = enabled <br />
 This options takes <b>uint32_t</b> as parameter</li>
</ul>
</li>
</ul>
</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">optval</td><td>Specifies a value for the option </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">optlen</td><td>Specifies the length of the option value</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Zero on success, or negative error code on failure</dd></dl>
<dl class="section user"><dt>Persistent</dt><dd>All params are <b>Non- Persistent</b> </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group___socket.html#ga9fc02898bc65c0a0c55de78355436682" title="Get socket options. ">SlNetIfWifi_getSockOpt</a> </dd></dl>
<dl class="section note"><dt>Note</dt><dd></dd></dl>
<dl class="section warning"><dt>Warning</dt><dd></dd></dl>
<dl class="section user"><dt>Examples</dt><dd></dd></dl>
<ul>
<li>SLNETSOCK_OPSOCK_RCV_BUF: <div class="fragment"><div class="line">SlNetSock_Winsize_t size;</div><div class="line">size.winsize = 3000; <span class="comment">// bytes</span></div><div class="line"><a class="code" href="group___socket.html#gaa88290743d74f108aab46844aee496f8">SlNetIfWifi_setSockOpt</a>(SockID, sdContext, SLNETSOCK_LVL_SOCKET, SLNETSOCK_OPSOCK_RCV_BUF, (uint8_t *)&amp;size, <span class="keyword">sizeof</span>(size));</div></div><!-- fragment --> <br />
</li>
<li>SLNETSOCK_OPSOCK_RCV_TIMEO: <div class="fragment"><div class="line"><span class="keyword">struct </span>SlNetSock_Timeval_t timeVal;</div><div class="line">timeVal.tv_sec =  1; <span class="comment">// Seconds</span></div><div class="line">timeVal.tv_usec = 0; <span class="comment">// Microseconds. 10000 microseconds resolution</span></div><div class="line"><a class="code" href="group___socket.html#gaa88290743d74f108aab46844aee496f8">SlNetIfWifi_setSockOpt</a>(SockID, sdContext, SLNETSOCK_LVL_SOCKET, SLNETSOCK_OPSOCK_RCV_TIMEO, (uint8_t *)&amp;timeVal, <span class="keyword">sizeof</span>(timeVal)); <span class="comment">// Enable receive timeout</span></div></div><!-- fragment --> <br />
</li>
<li>SLNETSOCK_OPSOCK_KEEPALIVE: //disable Keepalive <div class="fragment"><div class="line">SlNetSock_Keepalive_t enableOption;</div><div class="line">enableOption.keepaliveEnabled = 0;</div><div class="line"><a class="code" href="group___socket.html#gaa88290743d74f108aab46844aee496f8">SlNetIfWifi_setSockOpt</a>(SockID, sdContext, SLNETSOCK_LVL_SOCKET, SLNETSOCK_OPSOCK_KEEPALIVE, (uint8_t *)&amp;enableOption, <span class="keyword">sizeof</span>(enableOption));</div></div><!-- fragment --> <br />
</li>
<li>SLNETSOCK_OPSOCK_KEEPALIVE_TIME: //Set Keepalive timeout <div class="fragment"><div class="line">int16_t Status;</div><div class="line">uint32_t TimeOut = 120;</div><div class="line"><a class="code" href="group___socket.html#gaa88290743d74f108aab46844aee496f8">SlNetIfWifi_setSockOpt</a>(Sd, sdContext, SLNETSOCK_LVL_SOCKET, SLNETSOCK_OPSOCK_KEEPALIVE_TIME, (uint8_t *)&amp;TimeOut, <span class="keyword">sizeof</span>(TimeOut));</div></div><!-- fragment --> <br />
</li>
<li>SLNETSOCK_OPSOCK_NON_BLOCKING: //Enable or disable nonblocking mode <div class="fragment"><div class="line">SlNetSock_Nonblocking_t enableOption;</div><div class="line">enableOption.nonBlockingEnabled = 1;</div><div class="line"><a class="code" href="group___socket.html#gaa88290743d74f108aab46844aee496f8">SlNetIfWifi_setSockOpt</a>(SockID, sdContext, SLNETSOCK_LVL_SOCKET, SLNETSOCK_OPSOCK_NON_BLOCKING, (uint8_t *)&amp;enableOption, <span class="keyword">sizeof</span>(enableOption));</div></div><!-- fragment --> <br />
</li>
<li>SLNETSOCK_OPSOCK_NON_IP_BOUNDARY: //disable boundary <div class="fragment"><div class="line">SlNetSock_NonIpBoundary_t enableOption;</div><div class="line">enableOption.nonIpBoundaryEnabled = 1;</div><div class="line"><a class="code" href="group___socket.html#gaa88290743d74f108aab46844aee496f8">SlNetIfWifi_setSockOpt</a>(SockID, sdContext, SLNETSOCK_LVL_SOCKET, SLNETSOCK_OPSOCK_NON_IP_BOUNDARY, (uint8_t *)&amp;enableOption, <span class="keyword">sizeof</span>(enableOption));</div></div><!-- fragment --> <br />
</li>
<li>SLNETSOCK_OPSOCK_LINGER: <div class="fragment"><div class="line">SlNetSock_linger_t linger;</div><div class="line">linger.l_onoff = 1;</div><div class="line">linger.l_linger = 10;</div><div class="line"><a class="code" href="group___socket.html#gaa88290743d74f108aab46844aee496f8">SlNetIfWifi_setSockOpt</a>(SockID, sdContext, SLNETSOCK_LVL_SOCKET, SLNETSOCK_OPSOCK_LINGER, &amp;linger, <span class="keyword">sizeof</span>(linger));</div></div><!-- fragment --> <br />
</li>
<li>SLNETSOCK_OPIP_MULTICAST_TTL: <div class="fragment"><div class="line">uint8_t ttl = 20;</div><div class="line"><a class="code" href="group___socket.html#gaa88290743d74f108aab46844aee496f8">SlNetIfWifi_setSockOpt</a>(SockID, sdContext, SLNETSOCK_LVL_IP, SLNETSOCK_OPIP_MULTICAST_TTL, &amp;ttl, <span class="keyword">sizeof</span>(ttl));</div></div><!-- fragment --> <br />
</li>
<li>SLNETSOCK_OPIP_ADD_MEMBERSHIP: <div class="fragment"><div class="line">SlNetSock_IpMreq_t mreq;</div><div class="line"><a class="code" href="group___socket.html#gaa88290743d74f108aab46844aee496f8">SlNetIfWifi_setSockOpt</a>(SockID, sdContext, SLNETSOCK_LVL_IP, SLNETSOCK_OPIP_ADD_MEMBERSHIP, &amp;mreq, <span class="keyword">sizeof</span>(mreq));</div></div><!-- fragment --> <br />
</li>
<li>SLNETSOCK_OPIP_DROP_MEMBERSHIP: <div class="fragment"><div class="line">SlNetSock_IpMreq_t mreq;</div><div class="line"><a class="code" href="group___socket.html#gaa88290743d74f108aab46844aee496f8">SlNetIfWifi_setSockOpt</a>(SockID, sdContext, SLNETSOCK_LVL_IP, SLNETSOCK_OPIP_DROP_MEMBERSHIP, &amp;mreq, <span class="keyword">sizeof</span>(mreq));</div></div><!-- fragment --> <br />
</li>
<li>SLNETSOCK_OPIP_RAW_RX_NO_HEADER: <div class="fragment"><div class="line">uint32_t header = 1;  <span class="comment">// remove ip header</span></div><div class="line"><a class="code" href="group___socket.html#gaa88290743d74f108aab46844aee496f8">SlNetIfWifi_setSockOpt</a>(SockID, sdContext, SLNETSOCK_LVL_IP, SLNETSOCK_OPIP_RAW_RX_NO_HEADER, &amp;header, <span class="keyword">sizeof</span>(header));</div></div><!-- fragment --> <br />
</li>
<li>SLNETSOCK_OPIP_HDRINCL: <div class="fragment"><div class="line">uint32_t header = 1;</div><div class="line"><a class="code" href="group___socket.html#gaa88290743d74f108aab46844aee496f8">SlNetIfWifi_setSockOpt</a>(SockID, sdContext, SLNETSOCK_LVL_IP, SLNETSOCK_OPIP_HDRINCL, &amp;header, <span class="keyword">sizeof</span>(header));</div></div><!-- fragment --> <br />
</li>
<li>SLNETSOCK_OPIP_RAW_IPV6_HDRINCL: <div class="fragment"><div class="line">uint32_t header = 1;</div><div class="line"><a class="code" href="group___socket.html#gaa88290743d74f108aab46844aee496f8">SlNetIfWifi_setSockOpt</a>(SockID, sdContext, SLNETSOCK_LVL_IP, SLNETSOCK_OPIP_RAW_IPV6_HDRINCL, &amp;header, <span class="keyword">sizeof</span>(header));</div></div><!-- fragment --> <br />
</li>
<li>SLNETSOCK_OPPHY_CHANNEL: <div class="fragment"><div class="line">uint32_t newChannel = 6; <span class="comment">// range is 1-13</span></div><div class="line"><a class="code" href="group___socket.html#gaa88290743d74f108aab46844aee496f8">SlNetIfWifi_setSockOpt</a>(SockID, sdContext, SLNETSOCK_LVL_SOCKET, SLNETSOCK_OPPHY_CHANNEL, &amp;newChannel, <span class="keyword">sizeof</span>(newChannel));</div></div><!-- fragment --> <br />
</li>
<li>SLNETSOCK_OPPHY_RATE: <div class="fragment"><div class="line">uint32_t rate = 6; <span class="comment">// see wlan.h SlWlanRateIndex_e for values</span></div><div class="line"><a class="code" href="group___socket.html#gaa88290743d74f108aab46844aee496f8">SlNetIfWifi_setSockOpt</a>(SockID, sdContext, SLNETSOCK_LVL_PHY, SLNETSOCK_OPPHY_RATE, &amp;rate, <span class="keyword">sizeof</span>(rate));</div></div><!-- fragment --> <br />
</li>
<li>SLNETSOCK_OPPHY_TX_POWER: <div class="fragment"><div class="line">uint32_t txpower = 1; <span class="comment">// valid range is 1-15</span></div><div class="line"><a class="code" href="group___socket.html#gaa88290743d74f108aab46844aee496f8">SlNetIfWifi_setSockOpt</a>(SockID, sdContext, SLNETSOCK_LVL_PHY, SLNETSOCK_OPPHY_TX_POWER, &amp;txpower, <span class="keyword">sizeof</span>(txpower));</div></div><!-- fragment --> <br />
</li>
<li>SLNETSOCK_OPPHY_NUM_FRAMES_TO_TX: <div class="fragment"><div class="line">uint32_t numframes = 1;</div><div class="line"><a class="code" href="group___socket.html#gaa88290743d74f108aab46844aee496f8">SlNetIfWifi_setSockOpt</a>(SockID, sdContext, SLNETSOCK_LVL_PHY, SLNETSOCK_OPPHY_NUM_FRAMES_TO_TX, &amp;numframes, <span class="keyword">sizeof</span>(numframes));</div></div><!-- fragment --> <br />
</li>
<li>SLNETSOCK_OPPHY_PREAMBLE: <div class="fragment"><div class="line">uint32_t preamble = 1;</div><div class="line"><a class="code" href="group___socket.html#gaa88290743d74f108aab46844aee496f8">SlNetIfWifi_setSockOpt</a>(SockID, sdContext, SLNETSOCK_LVL_PHY, SLNETSOCK_OPPHY_PREAMBLE, &amp;preamble, <span class="keyword">sizeof</span>(preamble));</div></div><!-- fragment --> <br />
</li>
<li>SLNETSOCK_OPPHY_TX_INHIBIT_THRESHOLD: <div class="fragment"><div class="line">uint32_t thrshld = SLNETSOCK_TX_INHIBIT_THRESHOLD_MED;</div><div class="line"><a class="code" href="group___socket.html#gaa88290743d74f108aab46844aee496f8">SlNetIfWifi_setSockOpt</a>(SockID, sdContext, SLNETSOCK_LVL_PHY, SLNETSOCK_OPPHY_TX_INHIBIT_THRESHOLD , &amp;thrshld, <span class="keyword">sizeof</span>(thrshld));</div></div><!-- fragment --> <br />
</li>
<li>SLNETSOCK_OPPHY_TX_TIMEOUT: <div class="fragment"><div class="line">uint32_t timeout = 50;</div><div class="line"><a class="code" href="group___socket.html#gaa88290743d74f108aab46844aee496f8">SlNetIfWifi_setSockOpt</a>(SockID, sdContext, SLNETSOCK_LVL_PHY, SLNETSOCK_OPPHY_TX_TIMEOUT  , &amp;timeout, <span class="keyword">sizeof</span>(timeout));</div></div><!-- fragment --> <br />
</li>
<li>SLNETSOCK_OPPHY_ALLOW_ACKS: <div class="fragment"><div class="line">uint32_t acks = 1; <span class="comment">// 0 = disabled / 1 = enabled</span></div><div class="line"><a class="code" href="group___socket.html#gaa88290743d74f108aab46844aee496f8">SlNetIfWifi_setSockOpt</a>(SockID, sdContext, SLNETSOCK_LVL_PHY, SLNETSOCK_OPPHY_ALLOW_ACKS, &amp;acks, <span class="keyword">sizeof</span>(acks));</div></div><!-- fragment --> <br />
 </li>
</ul>

<p>Definition at line <a class="el" href="slnetifwifi_8c_source.html#l00218">218</a> of file <a class="el" href="slnetifwifi_8c_source.html">slnetifwifi.c</a>.</p>
<div class="fragment"><div class="line"><a name="l00219"></a><span class="lineno">  219</span>&#160;{</div><div class="line"><a name="l00220"></a><span class="lineno">  220</span>&#160;    <span class="keywordflow">return</span> <a class="code" href="group___socket.html#ga6363ea2098e629c1a6e2bf80e731fb79">sl_SetSockOpt</a>(sd, level, optname, optval, optlen);</div><div class="line"><a name="l00221"></a><span class="lineno">  221</span>&#160;}</div><div class="ttc" id="group___socket_html_ga6363ea2098e629c1a6e2bf80e731fb79"><div class="ttname"><a href="group___socket.html#ga6363ea2098e629c1a6e2bf80e731fb79">sl_SetSockOpt</a></div><div class="ttdeci">_i16 sl_SetSockOpt(_i16 sd, _i16 level, _i16 optname, const void *optval, SlSocklen_t optlen)</div><div class="ttdoc">Set socket options-. </div><div class="ttdef"><b>Definition:</b> <a href="sl__socket_8c_source.html#l00925">sl_socket.c:925</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="ga727dd5a1c20faa5d718cb5a2724b0981"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga727dd5a1c20faa5d718cb5a2724b0981">&sect;&nbsp;</a></span>SlNetIfWifi_socket()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int16_t SlNetIfWifi_socket </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>ifContext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int16_t&#160;</td>
          <td class="paramname"><em>Domain</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int16_t&#160;</td>
          <td class="paramname"><em>Type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int16_t&#160;</td>
          <td class="paramname"><em>Protocol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void **&#160;</td>
          <td class="paramname"><em>sdContext</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create an endpoint for communication. </p>
<p>The SlNetIfWifi_socket function creates a new socket of a certain socket type, identified by an integer number, and allocates system resources to it.<br />
This function is called by the application layer to obtain a socket descriptor (handle).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ifContext</td><td>Stores interface data if CreateContext function supported and implemented. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">domain</td><td>Specifies the protocol family of the created socket. For example:<ul>
<li>SLNETSOCK_AF_INET for network protocol IPv4</li>
<li>SLNETSOCK_AF_INET6 for network protocol IPv6</li>
<li>SLNETSOCK_AF_RF for starting transceiver mode. Notes:<ul>
<li>sending and receiving any packet overriding 802.11 header</li>
<li>for optimized power consumption the socket will be started in TX only mode until receive command is activated </li>
</ul>
</li>
</ul>
</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">type</td><td>Specifies the socket type, which determines the semantics of communication over the socket. The socket types supported by the system are implementation-dependent. Possible socket types include:<ul>
<li>SLNETSOCK_SOCK_STREAM (reliable stream-oriented service or Stream Sockets)</li>
<li>SLNETSOCK_SOCK_DGRAM (datagram service or Datagram Sockets)</li>
<li>SLNETSOCK_SOCK_RAW (raw protocols atop the network layer)</li>
<li>when used with AF_RF:<ul>
<li>SLNETSOCK_SOCK_RX_MTR</li>
<li>SLNETSOCK_SOCK_MAC_WITH_CCA</li>
<li>SLNETSOCK_SOCK_MAC_WITH_NO_CCA</li>
<li>SLNETSOCK_SOCK_BRIDGE</li>
<li>SLNETSOCK_SOCK_ROUTER </li>
</ul>
</li>
</ul>
</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">protocol</td><td>Specifies a particular transport to be used with the socket.<br />
 The most common are<ul>
<li>SLNETSOCK_PROTO_TCP</li>
<li>SLNETSOCK_PROTO_UDP</li>
<li>SLNETSOCK_PROTO_RAW</li>
<li>SLNETSOCK_PROTO_SECURE The value 0 may be used to select a default protocol from the selected domain and type </li>
</ul>
</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">sdContext</td><td>Allocate and store socket data if needed for using in other slnetwifi socket functions</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>On success, socket descriptor (handle) that is used for consequent socket operations. <br />
 A successful return code should be a positive number (int16)<br />
 On error, a negative value will be returned specifying the error code.<ul>
<li>SLNETERR_BSD_EAFNOSUPPORT - illegal domain parameter</li>
<li>SLNETERR_BSD_EPROTOTYPE - illegal type parameter</li>
<li>SLNETERR_BSD_EACCES - permission denied</li>
<li>SLNETERR_BSD_ENSOCK - exceeded maximal number of socket</li>
<li>SLNETERR_BSD_ENOMEM - memory allocation error</li>
<li>SLNETERR_BSD_EINVAL - error in socket configuration</li>
<li>SLNETERR_BSD_EPROTONOSUPPORT - illegal protocol parameter</li>
<li>SLNETERR_BSD_EOPNOTSUPP - illegal combination of protocol and type parameters</li>
</ul>
</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group___socket.html#ga727dd5a1c20faa5d718cb5a2724b0981" title="Create an endpoint for communication. ">SlNetIfWifi_socket</a> </dd></dl>
<dl class="section note"><dt>Note</dt><dd></dd></dl>
<dl class="section warning"><dt>Warning</dt><dd></dd></dl>

<p>Definition at line <a class="el" href="slnetifwifi_8c_source.html#l00125">125</a> of file <a class="el" href="slnetifwifi_8c_source.html">slnetifwifi.c</a>.</p>
<div class="fragment"><div class="line"><a name="l00126"></a><span class="lineno">  126</span>&#160;{</div><div class="line"><a name="l00127"></a><span class="lineno">  127</span>&#160;    <span class="comment">/* Create socket and return the return value of the function             */</span></div><div class="line"><a name="l00128"></a><span class="lineno">  128</span>&#160;    int16_t mappedSocketType = socketType[Type - 1];</div><div class="line"><a name="l00129"></a><span class="lineno">  129</span>&#160;    <span class="keywordflow">return</span> (<a class="code" href="group___socket.html#gaa775fcb6d09bf35b9dac3e5eb8e8c997">sl_Socket</a>(Domain, mappedSocketType, Protocol));</div><div class="line"><a name="l00130"></a><span class="lineno">  130</span>&#160;}</div><div class="ttc" id="group___socket_html_gaa775fcb6d09bf35b9dac3e5eb8e8c997"><div class="ttname"><a href="group___socket.html#gaa775fcb6d09bf35b9dac3e5eb8e8c997">sl_Socket</a></div><div class="ttdeci">_i16 sl_Socket(_i16 Domain, _i16 Type, _i16 Protocol)</div><div class="ttdoc">Create an endpoint for communication. </div><div class="ttdef"><b>Definition:</b> <a href="sl__socket_8c_source.html#l00137">sl_socket.c:137</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="gacd8c0e81a019e8170d2d2b7ef571271a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacd8c0e81a019e8170d2d2b7ef571271a">&sect;&nbsp;</a></span>SlNetIfWifi_sockstartSec()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t SlNetIfWifi_sockstartSec </td>
          <td>(</td>
          <td class="paramtype">int16_t&#160;</td>
          <td class="paramname"><em>sd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>sdContext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SlNetSockSecAttrib_t *&#160;</td>
          <td class="paramname"><em>secAttrib</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Start a security session on an opened socket. </p>
<p>The SlNetIfWifi_sockstartSec function is used start a security session on an opened socket. If the security handle is NULL the session would be started with the default security settings.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">sd</td><td>Socket descriptor (handle) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">sdContext</td><td>May store socket data if implemented in the SlNetIfWifi_socket function. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">secAttrib</td><td>Secure attribute handle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">flags</td><td>Specifies flags. <br />
 The available flags are:<ul>
<li>SLNETSOCK_SEC_START_SECURITY_SESSION_ONLY</li>
<li>SLNETSOCK_SEC_BIND_CONTEXT_ONLY</li>
<li>SLNETSOCK_SEC_IS_SERVER</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Zero on success, or negative error code on failure</dd></dl>
<dl class="section see"><dt>See also</dt><dd></dd></dl>
<dl class="section note"><dt>Note</dt><dd></dd></dl>
<dl class="section warning"><dt>Warning</dt><dd></dd></dl>
<dl class="section user"><dt>Example</dt><dd></dd></dl>
<ul>
<li>start security session on an opened socket: <div class="fragment"></div><!-- fragment --> </li>
</ul>

<p>Definition at line <a class="el" href="slnetifwifi_8c_source.html#l00288">288</a> of file <a class="el" href="slnetifwifi_8c_source.html">slnetifwifi.c</a>.</p>
<div class="fragment"><div class="line"><a name="l00289"></a><span class="lineno">  289</span>&#160;{</div><div class="line"><a name="l00290"></a><span class="lineno">  290</span>&#160;    SlNetSock_SecAttribNode_t *tempSecAttrib = *secAttrib;</div><div class="line"><a name="l00291"></a><span class="lineno">  291</span>&#160;    int32_t                   retVal         = SLNETERR_RET_CODE_OK;</div><div class="line"><a name="l00292"></a><span class="lineno">  292</span>&#160;</div><div class="line"><a name="l00293"></a><span class="lineno">  293</span>&#160;    <span class="keywordflow">if</span> ( 0 != (flags &amp; SLNETSOCK_SEC_BIND_CONTEXT_ONLY)  )</div><div class="line"><a name="l00294"></a><span class="lineno">  294</span>&#160;    {</div><div class="line"><a name="l00295"></a><span class="lineno">  295</span>&#160;        <span class="comment">/* run over all attributes and set them                              */</span></div><div class="line"><a name="l00296"></a><span class="lineno">  296</span>&#160;        <span class="keywordflow">while</span> (NULL != tempSecAttrib)</div><div class="line"><a name="l00297"></a><span class="lineno">  297</span>&#160;        {</div><div class="line"><a name="l00298"></a><span class="lineno">  298</span>&#160;            <span class="keywordflow">if</span> ( tempSecAttrib-&gt;attribName &lt;= SLNETSOCK_SEC_ATTRIB_DISABLE_CERT_STORE)</div><div class="line"><a name="l00299"></a><span class="lineno">  299</span>&#160;            {</div><div class="line"><a name="l00300"></a><span class="lineno">  300</span>&#160;                retVal = <a class="code" href="group___socket.html#ga6363ea2098e629c1a6e2bf80e731fb79">sl_SetSockOpt</a>(sd, SL_SOL_SOCKET, StartSecOptName[tempSecAttrib-&gt;attribName], tempSecAttrib-&gt;attribBuff, tempSecAttrib-&gt;attribBuffLen);</div><div class="line"><a name="l00301"></a><span class="lineno">  301</span>&#160;            }</div><div class="line"><a name="l00302"></a><span class="lineno">  302</span>&#160;            <span class="keywordflow">else</span></div><div class="line"><a name="l00303"></a><span class="lineno">  303</span>&#160;            {</div><div class="line"><a name="l00304"></a><span class="lineno">  304</span>&#160;                <span class="keywordflow">return</span> SLNETERR_RET_CODE_INVALID_INPUT;</div><div class="line"><a name="l00305"></a><span class="lineno">  305</span>&#160;            }</div><div class="line"><a name="l00306"></a><span class="lineno">  306</span>&#160;            tempSecAttrib = tempSecAttrib-&gt;next;</div><div class="line"><a name="l00307"></a><span class="lineno">  307</span>&#160;        }</div><div class="line"><a name="l00308"></a><span class="lineno">  308</span>&#160;    }</div><div class="line"><a name="l00309"></a><span class="lineno">  309</span>&#160;</div><div class="line"><a name="l00310"></a><span class="lineno">  310</span>&#160;    <span class="keywordflow">if</span> ( 0 != (flags &amp; SLNETSOCK_SEC_START_SECURITY_SESSION_ONLY)  )</div><div class="line"><a name="l00311"></a><span class="lineno">  311</span>&#160;    {</div><div class="line"><a name="l00312"></a><span class="lineno">  312</span>&#160;        <span class="comment">/* Start TLS session                                                     */</span></div><div class="line"><a name="l00313"></a><span class="lineno">  313</span>&#160;        retVal = <a class="code" href="group___socket.html#ga9275c1dadaba20e46381343800d0127b">sl_StartTLS</a>(sd);</div><div class="line"><a name="l00314"></a><span class="lineno">  314</span>&#160;    }</div><div class="line"><a name="l00315"></a><span class="lineno">  315</span>&#160;</div><div class="line"><a name="l00316"></a><span class="lineno">  316</span>&#160;    <span class="keywordflow">return</span> retVal;</div><div class="line"><a name="l00317"></a><span class="lineno">  317</span>&#160;}</div><div class="ttc" id="group___socket_html_ga6363ea2098e629c1a6e2bf80e731fb79"><div class="ttname"><a href="group___socket.html#ga6363ea2098e629c1a6e2bf80e731fb79">sl_SetSockOpt</a></div><div class="ttdeci">_i16 sl_SetSockOpt(_i16 sd, _i16 level, _i16 optname, const void *optval, SlSocklen_t optlen)</div><div class="ttdoc">Set socket options-. </div><div class="ttdef"><b>Definition:</b> <a href="sl__socket_8c_source.html#l00925">sl_socket.c:925</a></div></div>
<div class="ttc" id="group___socket_html_ga9275c1dadaba20e46381343800d0127b"><div class="ttname"><a href="group___socket.html#ga9275c1dadaba20e46381343800d0127b">sl_StartTLS</a></div><div class="ttdeci">_i16 sl_StartTLS(_i16 sd)</div><div class="ttdoc">Initiate TLS connection on a socket. </div><div class="ttdef"><b>Definition:</b> <a href="sl__socket_8c_source.html#l01906">sl_socket.c:1906</a></div></div>
</div><!-- fragment -->
</div>
</div>
<hr/><h2 class="groupheader">Data Structure Documentation</h2>
<a name="struct_sl_in_addr__t" id="struct_sl_in_addr__t"></a>
<h2 class="memtitle"><span class="permalink"><a href="#struct_sl_in_addr__t">&sect;&nbsp;</a></span>SlInAddr_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct SlInAddr_t</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock">
<p>Definition at line <a class="el" href="sl__socket_8h_source.html#l00219">219</a> of file <a class="el" href="sl__socket_8h_source.html">sl_socket.h</a>.</p>
</div><table class="fieldtable">
<tr><th colspan="3">Data Fields</th></tr>
<tr><td class="fieldtype">
<a id="a1bb442d64dfd79d2219d69704947e21b"></a>_u32</td>
<td class="fieldname">
s_addr</td>
<td class="fielddoc">
</td></tr>
<tr><td class="fieldtype">
<a id="a86a6e3952e584eaafe86a6242a465fef"></a>union <a class="el" href="group___socket.html#union_sl_in_addr__t_1_1_s__un">S_un</a></td>
<td class="fieldname">
S_un</td>
<td class="fielddoc">
</td></tr>
</table>

</div>
</div>
<a name="struct_sl_in6_addr__t" id="struct_sl_in6_addr__t"></a>
<h2 class="memtitle"><span class="permalink"><a href="#struct_sl_in6_addr__t">&sect;&nbsp;</a></span>SlIn6Addr_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct SlIn6Addr_t</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock">
<p>Definition at line <a class="el" href="sl__socket_8h_source.html#l00233">233</a> of file <a class="el" href="sl__socket_8h_source.html">sl_socket.h</a>.</p>
</div><table class="fieldtable">
<tr><th colspan="3">Data Fields</th></tr>
<tr><td class="fieldtype">
<a id="a80788416377108601e7875a72b365ae8"></a>union <a class="el" href="group___socket.html#union_sl_in6_addr__t_8___s6__un">SlIn6Addr_t</a></td>
<td class="fieldname">
_S6_un</td>
<td class="fielddoc">
</td></tr>
</table>

</div>
</div>
<a name="union_sl_in6_addr__t_8___s6__un" id="union_sl_in6_addr__t_8___s6__un"></a>
<h2 class="memtitle"><span class="permalink"><a href="#union_sl_in6_addr__t_8___s6__un">&sect;&nbsp;</a></span>SlIn6Addr_t._S6_un</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">union SlIn6Addr_t._S6_un</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock">
<p>Definition at line <a class="el" href="sl__socket_8h_source.html#l00235">235</a> of file <a class="el" href="sl__socket_8h_source.html">sl_socket.h</a>.</p>
</div><table class="fieldtable">
<tr><th colspan="3">Data Fields</th></tr>
<tr><td class="fieldtype">
<a id="a3994e9c767a293dc6b58796584db14bb"></a>_u32</td>
<td class="fieldname">
_S6_u32[4]</td>
<td class="fielddoc">
</td></tr>
<tr><td class="fieldtype">
<a id="acba0f1cd88712d8d4e7493db2349c8be"></a>_u8</td>
<td class="fieldname">
_S6_u8[16]</td>
<td class="fielddoc">
</td></tr>
</table>

</div>
</div>
<a name="struct_sl_sock_keepalive__t" id="struct_sl_sock_keepalive__t"></a>
<h2 class="memtitle"><span class="permalink"><a href="#struct_sl_sock_keepalive__t">&sect;&nbsp;</a></span>SlSockKeepalive_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct SlSockKeepalive_t</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock">
<p>Definition at line <a class="el" href="sl__socket_8h_source.html#l00244">244</a> of file <a class="el" href="sl__socket_8h_source.html">sl_socket.h</a>.</p>
</div><table class="fieldtable">
<tr><th colspan="3">Data Fields</th></tr>
<tr><td class="fieldtype">
<a id="aac43eef83958917bdf29de10afae4a00"></a>_u32</td>
<td class="fieldname">
KeepaliveEnabled</td>
<td class="fielddoc">
</td></tr>
</table>

</div>
</div>
<a name="struct_sl_sock_reuseaddr__t" id="struct_sl_sock_reuseaddr__t"></a>
<h2 class="memtitle"><span class="permalink"><a href="#struct_sl_sock_reuseaddr__t">&sect;&nbsp;</a></span>SlSockReuseaddr_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct SlSockReuseaddr_t</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock">
<p>Definition at line <a class="el" href="sl__socket_8h_source.html#l00249">249</a> of file <a class="el" href="sl__socket_8h_source.html">sl_socket.h</a>.</p>
</div><table class="fieldtable">
<tr><th colspan="3">Data Fields</th></tr>
<tr><td class="fieldtype">
<a id="a1885583c07b6775cfa117a4a64ae6e3d"></a>_u32</td>
<td class="fieldname">
ReuseaddrEnabled</td>
<td class="fielddoc">
</td></tr>
</table>

</div>
</div>
<a name="struct_sl_sock_rx_no_ip_boundary__t" id="struct_sl_sock_rx_no_ip_boundary__t"></a>
<h2 class="memtitle"><span class="permalink"><a href="#struct_sl_sock_rx_no_ip_boundary__t">&sect;&nbsp;</a></span>SlSockRxNoIpBoundary_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct SlSockRxNoIpBoundary_t</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock">
<p>Definition at line <a class="el" href="sl__socket_8h_source.html#l00254">254</a> of file <a class="el" href="sl__socket_8h_source.html">sl_socket.h</a>.</p>
</div><table class="fieldtable">
<tr><th colspan="3">Data Fields</th></tr>
<tr><td class="fieldtype">
<a id="a877da9ce9e3d2067118276d2ced96baa"></a>_i32</td>
<td class="fieldname">
RxIpNoBoundaryEnabled</td>
<td class="fielddoc">
</td></tr>
</table>

</div>
</div>
<a name="struct_sl_sock_winsize__t" id="struct_sl_sock_winsize__t"></a>
<h2 class="memtitle"><span class="permalink"><a href="#struct_sl_sock_winsize__t">&sect;&nbsp;</a></span>SlSockWinsize_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct SlSockWinsize_t</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock">
<p>Definition at line <a class="el" href="sl__socket_8h_source.html#l00259">259</a> of file <a class="el" href="sl__socket_8h_source.html">sl_socket.h</a>.</p>
</div><table class="fieldtable">
<tr><th colspan="3">Data Fields</th></tr>
<tr><td class="fieldtype">
<a id="a466e4d3c82c079326db96bc2003ebf1e"></a>_u32</td>
<td class="fieldname">
WinSize</td>
<td class="fielddoc">
</td></tr>
</table>

</div>
</div>
<a name="struct_sl_sock_nonblocking__t" id="struct_sl_sock_nonblocking__t"></a>
<h2 class="memtitle"><span class="permalink"><a href="#struct_sl_sock_nonblocking__t">&sect;&nbsp;</a></span>SlSockNonblocking_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct SlSockNonblocking_t</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock">
<p>Definition at line <a class="el" href="sl__socket_8h_source.html#l00264">264</a> of file <a class="el" href="sl__socket_8h_source.html">sl_socket.h</a>.</p>
</div><table class="fieldtable">
<tr><th colspan="3">Data Fields</th></tr>
<tr><td class="fieldtype">
<a id="ac3fbd37fa77cbb5487e905f8d2c412c4"></a>_u32</td>
<td class="fieldname">
NonBlockingEnabled</td>
<td class="fielddoc">
</td></tr>
</table>

</div>
</div>
<a name="struct_sl_socket_async_event__t" id="struct_sl_socket_async_event__t"></a>
<h2 class="memtitle"><span class="permalink"><a href="#struct_sl_socket_async_event__t">&sect;&nbsp;</a></span>SlSocketAsyncEvent_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct SlSocketAsyncEvent_t</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock">
<p>Definition at line <a class="el" href="sl__socket_8h_source.html#l00269">269</a> of file <a class="el" href="sl__socket_8h_source.html">sl_socket.h</a>.</p>
</div><table class="fieldtable">
<tr><th colspan="3">Data Fields</th></tr>
<tr><td class="fieldtype">
<a id="a66091b9dd6fa942936466485c0ce87dc"></a>_i8</td>
<td class="fieldname">
pExtraInfo[128]</td>
<td class="fielddoc">
</td></tr>
<tr><td class="fieldtype">
<a id="a8dd9c2ad246d77013a31b7f99969b8f7"></a>_u8</td>
<td class="fieldname">
Sd</td>
<td class="fielddoc">
</td></tr>
<tr><td class="fieldtype">
<a id="a1d58ad89ed5b340d15c354b769f8ecc2"></a>_u8</td>
<td class="fieldname">
Type</td>
<td class="fielddoc">
</td></tr>
<tr><td class="fieldtype">
<a id="aac4aee2cd9f9c6f1f534a7789e9ecab3"></a>_i16</td>
<td class="fieldname">
Val</td>
<td class="fielddoc">
</td></tr>
</table>

</div>
</div>
<a name="struct_sl_sock_tx_fail_event_data__t" id="struct_sl_sock_tx_fail_event_data__t"></a>
<h2 class="memtitle"><span class="permalink"><a href="#struct_sl_sock_tx_fail_event_data__t">&sect;&nbsp;</a></span>SlSockTxFailEventData_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct SlSockTxFailEventData_t</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock">
<p>Definition at line <a class="el" href="sl__socket_8h_source.html#l00277">277</a> of file <a class="el" href="sl__socket_8h_source.html">sl_socket.h</a>.</p>
</div><table class="fieldtable">
<tr><th colspan="3">Data Fields</th></tr>
<tr><td class="fieldtype">
<a id="abfe28724ad150292705a0bf83b093b8e"></a>_u8</td>
<td class="fieldname">
Padding</td>
<td class="fielddoc">
</td></tr>
<tr><td class="fieldtype">
<a id="a8dd9c2ad246d77013a31b7f99969b8f7"></a>_u8</td>
<td class="fieldname">
Sd</td>
<td class="fielddoc">
</td></tr>
<tr><td class="fieldtype">
<a id="a9bdd03f0cb49950b80d520706b6146b5"></a>_i16</td>
<td class="fieldname">
Status</td>
<td class="fielddoc">
</td></tr>
</table>

</div>
</div>
<a name="union_sl_sock_event_data__u" id="union_sl_sock_event_data__u"></a>
<h2 class="memtitle"><span class="permalink"><a href="#union_sl_sock_event_data__u">&sect;&nbsp;</a></span>SlSockEventData_u</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">union SlSockEventData_u</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock">
<p>Definition at line <a class="el" href="sl__socket_8h_source.html#l00285">285</a> of file <a class="el" href="sl__socket_8h_source.html">sl_socket.h</a>.</p>
</div><table class="fieldtable">
<tr><th colspan="3">Data Fields</th></tr>
<tr><td class="fieldtype">
<a id="ae60ad12b7cac0600997d825fc8e71f6e"></a><a class="el" href="group___socket.html#struct_sl_socket_async_event__t">SlSocketAsyncEvent_t</a></td>
<td class="fieldname">
SockAsyncData</td>
<td class="fielddoc">
</td></tr>
<tr><td class="fieldtype">
<a id="a595b11dcc257e90eee3feb5fa262591e"></a><a class="el" href="group___socket.html#struct_sl_sock_tx_fail_event_data__t">SlSockTxFailEventData_t</a></td>
<td class="fieldname">
SockTxFailData</td>
<td class="fielddoc">
</td></tr>
</table>

</div>
</div>
<a name="struct_sl_sock_event__t" id="struct_sl_sock_event__t"></a>
<h2 class="memtitle"><span class="permalink"><a href="#struct_sl_sock_event__t">&sect;&nbsp;</a></span>SlSockEvent_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct SlSockEvent_t</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock">
<p>Definition at line <a class="el" href="sl__socket_8h_source.html#l00292">292</a> of file <a class="el" href="sl__socket_8h_source.html">sl_socket.h</a>.</p>
</div><table class="fieldtable">
<tr><th colspan="3">Data Fields</th></tr>
<tr><td class="fieldtype">
<a id="adeedbaaa252b969fc66e151eef37ea62"></a>_u32</td>
<td class="fieldname">
Event</td>
<td class="fielddoc">
</td></tr>
<tr><td class="fieldtype">
<a id="a6b362706671e95ac5ac3f69699cbd9fb"></a><a class="el" href="group___socket.html#union_sl_sock_event_data__u">SlSockEventData_u</a></td>
<td class="fieldname">
SocketAsyncEvent</td>
<td class="fielddoc">
</td></tr>
</table>

</div>
</div>
<a name="struct_sl_sock_trigger_event__t" id="struct_sl_sock_trigger_event__t"></a>
<h2 class="memtitle"><span class="permalink"><a href="#struct_sl_sock_trigger_event__t">&sect;&nbsp;</a></span>SlSockTriggerEvent_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct SlSockTriggerEvent_t</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock">
<p>Definition at line <a class="el" href="sl__socket_8h_source.html#l00298">298</a> of file <a class="el" href="sl__socket_8h_source.html">sl_socket.h</a>.</p>
</div><table class="fieldtable">
<tr><th colspan="3">Data Fields</th></tr>
<tr><td class="fieldtype">
<a id="adeedbaaa252b969fc66e151eef37ea62"></a>_u32</td>
<td class="fieldname">
Event</td>
<td class="fielddoc">
</td></tr>
<tr><td class="fieldtype">
<a id="a823ed90ea3761a63bc4215258cc584c4"></a>_u32</td>
<td class="fieldname">
EventData</td>
<td class="fielddoc">
</td></tr>
</table>

</div>
</div>
<a name="struct_sl_sock_secure_a_l_p_n__t" id="struct_sl_sock_secure_a_l_p_n__t"></a>
<h2 class="memtitle"><span class="permalink"><a href="#struct_sl_sock_secure_a_l_p_n__t">&sect;&nbsp;</a></span>SlSockSecureALPN_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct SlSockSecureALPN_t</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock">
<p>Definition at line <a class="el" href="sl__socket_8h_source.html#l00305">305</a> of file <a class="el" href="sl__socket_8h_source.html">sl_socket.h</a>.</p>
</div><table class="fieldtable">
<tr><th colspan="3">Data Fields</th></tr>
<tr><td class="fieldtype">
<a id="a0fb880f5e48eaf683597a4209f3ffd75"></a>_u32</td>
<td class="fieldname">
SecureALPN</td>
<td class="fielddoc">
</td></tr>
</table>

</div>
</div>
<a name="struct_sl_sock_secure_mask__t" id="struct_sl_sock_secure_mask__t"></a>
<h2 class="memtitle"><span class="permalink"><a href="#struct_sl_sock_secure_mask__t">&sect;&nbsp;</a></span>SlSockSecureMask_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct SlSockSecureMask_t</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock">
<p>Definition at line <a class="el" href="sl__socket_8h_source.html#l00310">310</a> of file <a class="el" href="sl__socket_8h_source.html">sl_socket.h</a>.</p>
</div><table class="fieldtable">
<tr><th colspan="3">Data Fields</th></tr>
<tr><td class="fieldtype">
<a id="a40ea98781ecb10043c65252710a330c3"></a>_u32</td>
<td class="fieldname">
SecureMask</td>
<td class="fielddoc">
</td></tr>
</table>

</div>
</div>
<a name="struct_sl_sock_secure_method__t" id="struct_sl_sock_secure_method__t"></a>
<h2 class="memtitle"><span class="permalink"><a href="#struct_sl_sock_secure_method__t">&sect;&nbsp;</a></span>SlSockSecureMethod_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct SlSockSecureMethod_t</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock">
<p>Definition at line <a class="el" href="sl__socket_8h_source.html#l00315">315</a> of file <a class="el" href="sl__socket_8h_source.html">sl_socket.h</a>.</p>
</div><table class="fieldtable">
<tr><th colspan="3">Data Fields</th></tr>
<tr><td class="fieldtype">
<a id="ad69a485722bfe4616483cb38404b29b9"></a>_u8</td>
<td class="fieldname">
SecureMethod</td>
<td class="fielddoc">
</td></tr>
</table>

</div>
</div>
<a name="struct_sl_sock_s_s_l_cert_info__t" id="struct_sl_sock_s_s_l_cert_info__t"></a>
<h2 class="memtitle"><span class="permalink"><a href="#struct_sl_sock_s_s_l_cert_info__t">&sect;&nbsp;</a></span>SlSockSSLCertInfo_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct SlSockSSLCertInfo_t</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock">
<p>Definition at line <a class="el" href="sl__socket_8h_source.html#l00320">320</a> of file <a class="el" href="sl__socket_8h_source.html">sl_socket.h</a>.</p>
</div><table class="fieldtable">
<tr><th colspan="3">Data Fields</th></tr>
<tr><td class="fieldtype">
<a id="a11d8b3b3ec8099904fdab07b99bce5fb"></a>_i8</td>
<td class="fieldname">
FromDate[8]</td>
<td class="fielddoc">
</td></tr>
<tr><td class="fieldtype">
<a id="a2098f2e76a83c036586cf4b95d68a2cf"></a>_i8</td>
<td class="fieldname">
IssuerName[SL_MAX_ISSUER_AND_SUBJECT_NAME_LEN]</td>
<td class="fielddoc">
</td></tr>
<tr><td class="fieldtype">
<a id="aee4bc7f733d86245b99d9ee88985922a"></a>_i8</td>
<td class="fieldname">
IssuerNameLen</td>
<td class="fielddoc">
</td></tr>
<tr><td class="fieldtype">
<a id="ac708d879291c0a26e8caf54b6f2c6a70"></a>_u16</td>
<td class="fieldname">
IssuerNameXoredSha1</td>
<td class="fielddoc">
</td></tr>
<tr><td class="fieldtype">
<a id="a2514edfc379b6febdd2d1745ba4f6a73"></a>_i8</td>
<td class="fieldname">
Padding[2]</td>
<td class="fielddoc">
</td></tr>
<tr><td class="fieldtype">
<a id="aab5c1ccfd047697025505eb65ebb8108"></a>_i8</td>
<td class="fieldname">
SubjectName[SL_MAX_ISSUER_AND_SUBJECT_NAME_LEN]</td>
<td class="fielddoc">
</td></tr>
<tr><td class="fieldtype">
<a id="a8e3e2f7c5eda260672d2cf9428591d06"></a>_i8</td>
<td class="fieldname">
SubjectNameLen</td>
<td class="fielddoc">
</td></tr>
<tr><td class="fieldtype">
<a id="a44b363b6372d4df7476e718a99d14c16"></a>_u16</td>
<td class="fieldname">
SubjectNameXoredSha1</td>
<td class="fielddoc">
</td></tr>
<tr><td class="fieldtype">
<a id="ae77e8eab09596ef21384715de66cbe79"></a>_i8</td>
<td class="fieldname">
ToDate[8]</td>
<td class="fielddoc">
</td></tr>
</table>

</div>
</div>
<a name="struct_sl_sock_s_s_l_connection_params__t" id="struct_sl_sock_s_s_l_connection_params__t"></a>
<h2 class="memtitle"><span class="permalink"><a href="#struct_sl_sock_s_s_l_connection_params__t">&sect;&nbsp;</a></span>SlSockSSLConnectionParams_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct SlSockSSLConnectionParams_t</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock">
<p>Definition at line <a class="el" href="sl__socket_8h_source.html#l00334">334</a> of file <a class="el" href="sl__socket_8h_source.html">sl_socket.h</a>.</p>
</div><table class="fieldtable">
<tr><th colspan="3">Data Fields</th></tr>
<tr><td class="fieldtype">
<a id="a3a63d8ae0a5d88efa54268a85acd3049"></a>_u32</td>
<td class="fieldname">
SecureALPNChosenProtocol</td>
<td class="fielddoc">
</td></tr>
<tr><td class="fieldtype">
<a id="a2622978a0db138ef74228b6b108d2e32"></a>_u32</td>
<td class="fieldname">
SecureCipherSuit</td>
<td class="fielddoc">
</td></tr>
<tr><td class="fieldtype">
<a id="a831cb33687c3d89f571c9a6dfe4a2a4f"></a>_u32</td>
<td class="fieldname">
SecureIsPeerValidated</td>
<td class="fielddoc">
</td></tr>
<tr><td class="fieldtype">
<a id="a170215f309b5946fe58dd6a0a1b5d761"></a><a class="el" href="group___socket.html#struct_sl_sock_s_s_l_cert_info__t">SlSockSSLCertInfo_t</a></td>
<td class="fieldname">
SecurePeerCertinfo</td>
<td class="fielddoc">
</td></tr>
<tr><td class="fieldtype">
<a id="a244fde6802c259540f663b2dc72babe2"></a>_u32</td>
<td class="fieldname">
SecureVersion</td>
<td class="fielddoc">
</td></tr>
</table>

</div>
</div>
<a name="struct_sl_sock_ip_mreq__t" id="struct_sl_sock_ip_mreq__t"></a>
<h2 class="memtitle"><span class="permalink"><a href="#struct_sl_sock_ip_mreq__t">&sect;&nbsp;</a></span>SlSockIpMreq_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct SlSockIpMreq_t</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock">
<p>Definition at line <a class="el" href="sl__socket_8h_source.html#l00357">357</a> of file <a class="el" href="sl__socket_8h_source.html">sl_socket.h</a>.</p>
</div><table class="fieldtable">
<tr><th colspan="3">Data Fields</th></tr>
<tr><td class="fieldtype">
<a id="a526726f1171c79d8003490ab86f3da7c"></a><a class="el" href="group___socket.html#struct_sl_in_addr__t">SlInAddr_t</a></td>
<td class="fieldname">
imr_interface</td>
<td class="fielddoc">
</td></tr>
<tr><td class="fieldtype">
<a id="a6a0c67f0fbae8c3d98c1913f2d37b200"></a><a class="el" href="group___socket.html#struct_sl_in_addr__t">SlInAddr_t</a></td>
<td class="fieldname">
imr_multiaddr</td>
<td class="fielddoc">
</td></tr>
</table>

</div>
</div>
<a name="struct_sl_sock_ip_v6_mreq__t" id="struct_sl_sock_ip_v6_mreq__t"></a>
<h2 class="memtitle"><span class="permalink"><a href="#struct_sl_sock_ip_v6_mreq__t">&sect;&nbsp;</a></span>SlSockIpV6Mreq_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct SlSockIpV6Mreq_t</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock">
<p>Definition at line <a class="el" href="sl__socket_8h_source.html#l00363">363</a> of file <a class="el" href="sl__socket_8h_source.html">sl_socket.h</a>.</p>
</div><table class="fieldtable">
<tr><th colspan="3">Data Fields</th></tr>
<tr><td class="fieldtype">
<a id="a883191baff1044b0223ae1b69bb5c751"></a>_u32</td>
<td class="fieldname">
ipv6mr_interface</td>
<td class="fielddoc">
</td></tr>
<tr><td class="fieldtype">
<a id="a534d5eb0114c88bd5c84b32363b8ab43"></a><a class="el" href="group___socket.html#struct_sl_in6_addr__t">SlIn6Addr_t</a></td>
<td class="fieldname">
ipv6mr_multiaddr</td>
<td class="fielddoc">
</td></tr>
</table>

</div>
</div>
<a name="struct_sl_socklinger__t" id="struct_sl_socklinger__t"></a>
<h2 class="memtitle"><span class="permalink"><a href="#struct_sl_socklinger__t">&sect;&nbsp;</a></span>SlSocklinger_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct SlSocklinger_t</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock">
<p>Definition at line <a class="el" href="sl__socket_8h_source.html#l00368">368</a> of file <a class="el" href="sl__socket_8h_source.html">sl_socket.h</a>.</p>
</div><table class="fieldtable">
<tr><th colspan="3">Data Fields</th></tr>
<tr><td class="fieldtype">
<a id="a855cfb16b8d2d0cb292ddf7da11cd592"></a>_u32</td>
<td class="fieldname">
l_linger</td>
<td class="fielddoc">
</td></tr>
<tr><td class="fieldtype">
<a id="adfbac7d2d602cee373c483d13db52624"></a>_u32</td>
<td class="fieldname">
l_onoff</td>
<td class="fielddoc">
</td></tr>
</table>

</div>
</div>
<a name="struct_sl_timeval__t" id="struct_sl_timeval__t"></a>
<h2 class="memtitle"><span class="permalink"><a href="#struct_sl_timeval__t">&sect;&nbsp;</a></span>SlTimeval_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct SlTimeval_t</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock">
<p>Definition at line <a class="el" href="sl__socket_8h_source.html#l00378">378</a> of file <a class="el" href="sl__socket_8h_source.html">sl_socket.h</a>.</p>
</div><table class="fieldtable">
<tr><th colspan="3">Data Fields</th></tr>
<tr><td class="fieldtype">
<a id="a8f5aa475627ac4ba971fce4b1a79b673"></a>SlTime_t</td>
<td class="fieldname">
tv_sec</td>
<td class="fielddoc">
</td></tr>
<tr><td class="fieldtype">
<a id="a1ad5c78770a3d6fd50eae96b9096830b"></a>SlSuseconds_t</td>
<td class="fieldname">
tv_usec</td>
<td class="fielddoc">
</td></tr>
</table>

</div>
</div>
<a name="struct_sl_sock_addr__t" id="struct_sl_sock_addr__t"></a>
<h2 class="memtitle"><span class="permalink"><a href="#struct_sl_sock_addr__t">&sect;&nbsp;</a></span>SlSockAddr_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct SlSockAddr_t</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock">
<p>Definition at line <a class="el" href="sl__socket_8h_source.html#l00387">387</a> of file <a class="el" href="sl__socket_8h_source.html">sl_socket.h</a>.</p>
</div><table class="fieldtable">
<tr><th colspan="3">Data Fields</th></tr>
<tr><td class="fieldtype">
<a id="ae2b1f612104f3b2e3986fec7cc8b434b"></a>_u8</td>
<td class="fieldname">
sa_data[14]</td>
<td class="fielddoc">
</td></tr>
<tr><td class="fieldtype">
<a id="a2ec201dde0ef6487c4d40b54bb193f8d"></a>_u16</td>
<td class="fieldname">
sa_family</td>
<td class="fielddoc">
</td></tr>
</table>

</div>
</div>
<a name="struct_sl_sock_addr_in6__t" id="struct_sl_sock_addr_in6__t"></a>
<h2 class="memtitle"><span class="permalink"><a href="#struct_sl_sock_addr_in6__t">&sect;&nbsp;</a></span>SlSockAddrIn6_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct SlSockAddrIn6_t</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock">
<p>Definition at line <a class="el" href="sl__socket_8h_source.html#l00393">393</a> of file <a class="el" href="sl__socket_8h_source.html">sl_socket.h</a>.</p>
</div><table class="fieldtable">
<tr><th colspan="3">Data Fields</th></tr>
<tr><td class="fieldtype">
<a id="ab80273cf64088fdcf85aca765997b845"></a><a class="el" href="group___socket.html#struct_sl_in6_addr__t">SlIn6Addr_t</a></td>
<td class="fieldname">
sin6_addr</td>
<td class="fielddoc">
</td></tr>
<tr><td class="fieldtype">
<a id="a1353901c9555ac56c1ca22dc1533c3b8"></a>_u16</td>
<td class="fieldname">
sin6_family</td>
<td class="fielddoc">
</td></tr>
<tr><td class="fieldtype">
<a id="afba686aa3c6f6242cac4d29bc7c7d558"></a>_u32</td>
<td class="fieldname">
sin6_flowinfo</td>
<td class="fielddoc">
</td></tr>
<tr><td class="fieldtype">
<a id="ad7c0b531025d2975102172b2398611f5"></a>_u16</td>
<td class="fieldname">
sin6_port</td>
<td class="fielddoc">
</td></tr>
<tr><td class="fieldtype">
<a id="a95780ab290350f365e6de5dba3af0032"></a>_u32</td>
<td class="fieldname">
sin6_scope_id</td>
<td class="fielddoc">
</td></tr>
</table>

</div>
</div>
<a name="struct_sl_sock_addr_in__t" id="struct_sl_sock_addr_in__t"></a>
<h2 class="memtitle"><span class="permalink"><a href="#struct_sl_sock_addr_in__t">&sect;&nbsp;</a></span>SlSockAddrIn_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct SlSockAddrIn_t</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock">
<p>Definition at line <a class="el" href="sl__socket_8h_source.html#l00404">404</a> of file <a class="el" href="sl__socket_8h_source.html">sl_socket.h</a>.</p>
</div><table class="fieldtable">
<tr><th colspan="3">Data Fields</th></tr>
<tr><td class="fieldtype">
<a id="ac202531c3497bcb9d64a83028f036d81"></a><a class="el" href="group___socket.html#struct_sl_in_addr__t">SlInAddr_t</a></td>
<td class="fieldname">
sin_addr</td>
<td class="fielddoc">
</td></tr>
<tr><td class="fieldtype">
<a id="a073756b1c41885b395510a04d5e8e108"></a>_u16</td>
<td class="fieldname">
sin_family</td>
<td class="fielddoc">
</td></tr>
<tr><td class="fieldtype">
<a id="a591c70234168b0d4509cadef8b6d3ea1"></a>_u16</td>
<td class="fieldname">
sin_port</td>
<td class="fielddoc">
</td></tr>
<tr><td class="fieldtype">
<a id="a46c3a43fbd9a84363466a5ea60c08440"></a>_i8</td>
<td class="fieldname">
sin_zero[8]</td>
<td class="fielddoc">
</td></tr>
</table>

</div>
</div>
<a name="struct_sl_sock_secure_files__t" id="struct_sl_sock_secure_files__t"></a>
<h2 class="memtitle"><span class="permalink"><a href="#struct_sl_sock_secure_files__t">&sect;&nbsp;</a></span>SlSockSecureFiles_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct SlSockSecureFiles_t</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock">
<p>Definition at line <a class="el" href="sl__socket_8h_source.html#l00412">412</a> of file <a class="el" href="sl__socket_8h_source.html">sl_socket.h</a>.</p>
</div><table class="fieldtable">
<tr><th colspan="3">Data Fields</th></tr>
<tr><td class="fieldtype">
<a id="aa3bc696df80b644e0d4b1096659a079b"></a>_u8</td>
<td class="fieldname">
SecureFiles[4]</td>
<td class="fielddoc">
</td></tr>
</table>

</div>
</div>
<a name="struct_sl_fd_set__t" id="struct_sl_fd_set__t"></a>
<h2 class="memtitle"><span class="permalink"><a href="#struct_sl_fd_set__t">&sect;&nbsp;</a></span>SlFdSet_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct SlFdSet_t</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock">
<p>Definition at line <a class="el" href="sl__socket_8h_source.html#l00417">417</a> of file <a class="el" href="sl__socket_8h_source.html">sl_socket.h</a>.</p>
</div><table class="fieldtable">
<tr><th colspan="3">Data Fields</th></tr>
<tr><td class="fieldtype">
<a id="af09c1981bcf4efa70eabbd563f9ab0f2"></a>_u32</td>
<td class="fieldname">
fd_array[(SL_FD_SETSIZE+(_u8) 31)/(_u8) 32]</td>
<td class="fielddoc">
</td></tr>
</table>

</div>
</div>
<a name="struct_sl_transceiver_rx_over_head__t" id="struct_sl_transceiver_rx_over_head__t"></a>
<h2 class="memtitle"><span class="permalink"><a href="#struct_sl_transceiver_rx_over_head__t">&sect;&nbsp;</a></span>SlTransceiverRxOverHead_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct SlTransceiverRxOverHead_t</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock">
<p>Definition at line <a class="el" href="sl__socket_8h_source.html#l00422">422</a> of file <a class="el" href="sl__socket_8h_source.html">sl_socket.h</a>.</p>
</div><table class="fieldtable">
<tr><th colspan="3">Data Fields</th></tr>
<tr><td class="fieldtype">
<a id="a00d3d7a0b13187ef418a2f9a42970b04"></a>_u8</td>
<td class="fieldname">
Channel</td>
<td class="fielddoc">
</td></tr>
<tr><td class="fieldtype">
<a id="abfe28724ad150292705a0bf83b093b8e"></a>_u8</td>
<td class="fieldname">
Padding</td>
<td class="fielddoc">
</td></tr>
<tr><td class="fieldtype">
<a id="aaa445758bc7cb987afe93980bbf210a3"></a>_u8</td>
<td class="fieldname">
Rate</td>
<td class="fielddoc">
</td></tr>
<tr><td class="fieldtype">
<a id="aa2d26ef88bbc22f3b048312eb61ac898"></a>_i8</td>
<td class="fieldname">
Rssi</td>
<td class="fielddoc">
</td></tr>
<tr><td class="fieldtype">
<a id="a7abc832f47c5e79c00e451f00308a119"></a>_u32</td>
<td class="fieldname">
Timestamp</td>
<td class="fielddoc">
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="ga76088f0c7d79c2131c41fa0777fc43ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga76088f0c7d79c2131c41fa0777fc43ed">&sect;&nbsp;</a></span>SlNetIfConfigWifi</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SlNetIf_Config_t SlNetIfConfigWifi</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>SlNetIfConfigWifi structure contains all the function callbacks that are expected to be filled by the relevant network stack interface Each interface has different capabilities, so not all the API's must be supported. Interface that is not supporting a non-mandatory API are set to NULL </p>

<p>Definition at line <a class="el" href="slnetifwifi_8c_source.html#l00064">64</a> of file <a class="el" href="slnetifwifi_8c_source.html">slnetifwifi.c</a>.</p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.8.9.1-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.12 </li>
  </ul>
</div>
</body>
</html>
