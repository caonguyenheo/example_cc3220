<!DOCTYPE html><html><head>
<meta charset="UTF-8">
<title>General RTOS Concepts</title>
<link rel="stylesheet" href="../../web_support/strapdown/v/0.2/fonts/ubuntu-regular-woff.css"><link rel="stylesheet" href="../../web_support/strapdown/v/0.2/fonts/glyphicons-halflings-regular.css"><link rel="stylesheet" href="../../web_support/strapdown/v/0.2/themes/united2.min.css"><link rel="stylesheet" href="../../web_support/strapdown/v/0.2/themes/bootstrap-responsive.min.css"><link rel="stylesheet" href="../../web_support/strapdown/v/0.2/strapdown.css"><link rel="shortcut icon" type="image/x-icon" href="../../.metadata/favicon.ico"></head>

<!-- START PRE -->






<!-- END PRE -->

<body style=""><div class="container"><nav class="navbar navbar-default navbar-static-top"><div class="container-fluid"> <div class="navbar-header">  <div id="headline" class="navbar-brand">General RTOS Concepts</div> </div> </div></nav><div class="container"><div class="row row-offcanvas row-offcanvas-left"><div class="col-xs-12 col-sm-9" id="content"><h1 id="introduction">Introduction</h1>
<p>“A real-time operating system (RTOS) is an operating system (OS) intended to serve real-time application process data as it comes in, typically without buffering delays. (wikipedia.org)”</p>
<p>Key factors in an RTOS are minimal interrupt latency and minimal thread switching latency. An RTOS is valued more for how quickly or how predictably it can respond than for the amount of work it can perform in a given period of time.</p>
<p>For embedded devices, the <em>general</em> rule is that an RTOS is used when the application needs to do more than a few simple actions. An RTOS allows an application to be structured in a manner that scales as more application/system features are added (e.g. communication stacks, power management, etc.).</p>
<p>A RTOS has the following goals</p>
<ul>
<li><strong>Small latency</strong>: It is real-time after all!</li>
<li><strong>Determinism</strong>: Again, it is real-time. You need to know how long things take to process to make sure deadlines are met.</li>
<li><strong>Structured Software</strong>: With an RTOS, you are able divide and conquer in a structure manner. It's straight-forward to add additional components into the application.</li>
<li><strong>Scalability</strong>: An RTOS must be able to scale from a simple application to a complex one with stacks, drivers, file systems, etc.</li>
<li><strong>Offload development</strong>: An RTOS manages many aspects of the system which allows a developer to focus on their application. For example an RTOS, along with scheduling, generally handles power management, interrupt table management, memory management, exception handling, etc.</li>
</ul>
<p>In this workshop we'll cover general RTOS topics. The SimpleLink™ software development kit (SDK) supports both TI-RTOS and FreeRTOS. It also supports POSIX APIs on top of either RTOS. We'll use POSIX APIs below as a concrete example of an RTOS but the concepts are applicable for both RTOS offerings.</p>
<p><strong>Here's what we'll learn:</strong></p>
<ul>
<li>Basic understanding of RTOS terms</li>
<li>Basic understanding of an RTOS scheduling</li>
</ul>
<h1 id="terminology">Terminology</h1>
<p>Let's first standardize on some key definitions. It's assumed that you have a basic understanding of embedded processing in regards to knowing what an interrupt is, what a stack is, etc.</p>
<h2 id="standard-types-of-threads">Standard types of threads</h2>
<p>For this workshop we are going to use the term <strong>thread</strong> as a generic term for any execution block. Here are the typical threads in every RTOS based application.</p>
<ul>
<li><strong>Interrupt Service Routine (ISR)</strong>: Thread initiated by a hardware interrupt. An ISR runs to completion. ISRs all share the same stack.</li>
<li><strong>Tasks</strong>: Thread that can block while waiting for an event to occur. Tasks are traditionally long living threads (as opposed to ISRs which run to completion). Each task has it's own stack which allows it to be long living.</li>
<li><strong>Idle</strong>: Lowest priority thread that only runs when no other thread is ready to execute. Generally Idle is just a special task with the lowest possible priority.</li>
</ul>
<h2 id="schedulers">Schedulers</h2>
<p>Every RTOS has at its core a scheduler. The scheduler is responsible to manage the execution of threads in the system. There are two main ways a scheduler manages this: </p>
<ul>
<li><p><strong>Preemptive Scheduling</strong>: This is the most common type of RTOS scheduler. With a preemptive scheduler, a running thread continues until it either</p>
<ul>
<li>finishes (e.g. an ISR completes)</li>
<li>a higher priority thread becomes ready (in this case the higher priority thread preempts the lower priority thread)</li>
<li>the thread gives up the processor while waiting for a resource (e.g. a task calls <code>sleep()</code>).</li>
</ul>
<p>Both TI-RTOS and FreeRTOS have preemptive schedulers. This workshop will focus on preemptive schedulers.</p>
</li>
<li><strong>Time-slice Scheduling</strong>: This type of scheduling guarantees that each thread is given a slot to execute. This type of scheduling is generally not conducive to real-time application. The TI-RTOS kernel supports time-slicing scheduling with Tasks if desired.</li>
</ul>
<h2 id="other-key-terms">Other key terms</h2>
<ul>
<li><strong>Thread-safe</strong>: A piece of code is thread-safe if it manipulates shared data structures in a manner that guarantees correct access (reading/writing) by multiple threads at the same time. Please note, thread-safety is not just an RTOS issue (e.g. interrupts modifying the same memory must be careful).</li>
<li><strong>Blocked</strong>: A task is blocked if it is waiting on a resource and not consuming any of the CPU. For example, if a task calls <code>Task_sleep()</code> or <code>Semaphore_pend()</code> (with a non-zero timeout and the semaphore is not available), the task is blocked and another thread is allowed to run. Note: spinning on a register in a tight loop is not blocking…that’s polling.</li>
<li><strong>Bare-metal</strong>: Common name for an application that does not use an RTOS.</li>
</ul>
<h1 id="bare-metal-vs-rtos">Bare-Metal vs. RTOS</h1>
<p>Let's look a little more closely at a typical bare-metal application. These applications can typically be broken down into three key pieces</p>
<ul>
<li><strong>Initialization</strong>: Initializing the hardware and software components in <code>main()</code>.</li>
<li><strong>Super-loop state machine</strong>: Code to manage the application. The actions are based on the results of the interrupts (e.g. a SPI packet was received or a timer expired) or by polling.</li>
<li><strong>ISRs</strong>: Code executed by interrupts for peripherals (e.g. UART), timers or other device specific items (e.g. exceptions or multi-core communication).</li>
</ul>
<p>Here's a pictoral view of these key pieces.</p>
<p></p><div class="modal-pop" style="cursor:zoom-in;"><img src="./resources/bare_metal.png" alt="" class="img-responsive"></div><p></p>
<p>Bare-metal applications have their place. They are generally small, fast and relatively easy to understand with a simple application. Once more complicated logic is required, an RTOS starts to shine.</p>
<p>Let's look at a comparison of a bare-metal application to a minimal RTOS application (and then to a more traditional RTOS application). As you can see, the three key pieces we talked about before (init, super-loop and ISRs) are basically the same between a bare-metal application and a minimal RTOS application. However, with the minimal RTOS application, you now have the stepping off point to a much more complex application that allows multiple developers to add their content without dealing with potentially a fragile super-loop.</p>
<p></p><div class="modal-pop" style="cursor:zoom-in;"><img src="./resources/bare_metal_vs_rtos.png" alt="" class="img-responsive"></div><p></p>
<h1 id="rtos-components">RTOS Components</h1>
<p>Here are some of the main components of an RTOS. The SimpleLink SDK offers all of these features for both TI-RTOS and FreeRTOS.</p>
<ul>
<li><strong>Scheduler</strong>: Preemptive scheduler that guarantees the highest priority thread it running.</li>
<li><strong>Communication Mechanism</strong>: Semaphores, Message Queues, Queues, etc.</li>
<li><strong>Critical Region Mechanisms</strong>: Mutexes, Gates, Locks, etc.</li>
<li><strong>Timing Services</strong>: Clocks, Timers, etc.</li>
<li><strong>Power Management</strong>: For low power devices, power management is generally part of the RTOS since it knows the state of the device.</li>
<li><strong>Memory Management</strong>: Variable-size heaps, fixed-size heaps, etc.</li>
<li><strong>Peripheral Drivers</strong>: UART, SPI, I2C, etc.</li>
<li><strong>Protocol stacks</strong>: BLE, WiFi, etc.</li>
<li><strong>File System</strong>: FatFS, etc.</li>
<li><strong>Device Management</strong>: Exception Handling, Boot, etc.</li>
</ul>
<h1 id="posix-support-in-simplelink-sdk">POSIX Support in SimpleLink SDK</h1>
<p>POSIX is an IEEE industry API standard for OS compatibility. The SimpleLink SDK has both TI-RTOS and FreeRTOS support, however it also offers POSIX support on top of either of these RTOS's. This allows applications to be independent of the underlying RTOS.</p>
<p>The POSIX APIs in the SimpleLink SDK are a small shim on top of the underlying RTOS. When a POSIX Pthread is created, an underlying TI-RTOS (or FreeRTOS) Task is created. Similarly, when a POSIX Pthread semaphore is created, an underlying TI-RTOS (or FreeRTOS) semaphore is created.</p>
<p></p><div class="modal-pop" style="cursor:zoom-in;"><img src="./resources/posix_diagram.png" alt="" class="img-responsive"></div><p></p>
<p>A nice feature of POSIX support is the ability to grab POSIX based code from the web and quickly get it to work.</p>
<p>For a more details description of the POSIX support in SimpleLink SDKs, please refer to the <a href="../posix_project_zero/posix_project_zero.html">POSIX Overview Workshop</a>.</p>
<div class="bs-callout bs-callout-info "><h4><span class="glyphicon glyphicon-info-sign gi-2x" style="vertical-align: middle; margin-right: 0.2em;"></span><span style="vertical-align: middle;">POSIX is not an RTOS.
</span></h4>
<p>It is a OS compatibility layer to allow an application to port easily between operating systems.</p>
</div>
<h1 id="rtos-threads-communication">RTOS Threads Communication</h1>
<p>All RTOS's offers standard communication mechanisms like semaphores, mutexes, message queues, linked list, etc. Let's look a little closer at a couple of these...</p>
<h2 id="semaphore">Semaphore</h2>
<p>A semaphore allows resource management. A task can block on a <code>sem_wait()</code> until a resource is available (via a <code>sem_post()</code>). A common use case is for a Hwi to receive data and post a semaphore so a task can process it. This is desirable because it minimizes the duration of the interrupt.</p>
<p></p><div class="modal-pop" style="cursor:zoom-in;"><img src="./resources/semaphore_hwi_task.png" alt="" class="img-responsive"></div><p></p>
<p>Most RTOS's supports both binary and counting semaphores.</p>
<h2 id="message-queue">Message Queue</h2>
<p>Message Queues are useful for sending data between threads. Message Queues can be configured to send/receive user defined messages of any size. Here a task is sending a message to another task.</p>
<p></p><div class="modal-pop" style="cursor:zoom-in;"><img src="./resources/mailboxes.png" alt="" class="img-responsive"></div><p></p>
<p>Message Queues are useful when you want to centralize a specific functionality into a single task. All other threads can send messages to the centralized task for processing. The message queue handles the messages in a thread-safe manner.</p>
<p>Please note message queues in the POSIX support layer are built on top of Mailboxes in TI-RTOS and Queues in FreeRTOS in the SimpleLink SDK.</p>
<h2 id="execution">Execution</h2>
<p>Let's see a preemptive scheduler in action. Let's assume the following threads were created in main().</p>
<ul>
<li>ISRX: An interrupt service routine</li>
<li>MidA: created first in main()with priority 4</li>
<li>MidB: created second in main() with priority 4</li>
<li>High: created last in main() with priority 8</li>
</ul>
<p>Let's look at the following execution graph and talk about what is happening.</p>
<p></p><div class="modal-pop" style="cursor:zoom-in;"><img src="./resources/execution_graph.png" alt="" class="img-responsive"></div><p></p>
<p>Once the kernel's scheduler starts (in this case <code>BIOS_start()</code> in <code>main()</code>), all the tasks are ready to run, however it's the highest task (High) that runs first since it has the highest priority and is ready to run. Here's a description of some of the key transition points noted in the above graph.</p>
<ol>
<li>ISRX asserts, so it preempts all tasks. High is now in a preempted state.</li>
<li>Once ISRX finished, High starts to run again until it blocks on a <code>Task_sleep()</code> (or some blocking API). Now MidA can run.</li>
<li>MidA runs until it hits a blocking call (say <code>Semaphore_pend()</code>). Now MidB can run.</li>
<li>MidB runs until High unblocks (say the <code>Task_sleep()</code> expired). MidB is now preempted.</li>
<li>High runs until ISRX is asserted and preempts High. Note: there are two tasks preempted now.</li>
<li>MidA becomes ready (say ISRX posted the semaphore it was blocked on). MidA does not run since there is a higher priority thread running.</li>
<li>ISRX finishes, so High runs again and then blocks again, so MidB runs again until it blocks. Now MidA can run since there are no higher priority tasks running. Note: that MidA had to wait until after MidB finished since MidB was running when MidA became ready.</li>
<li>MidA blocks and now there are no threads running or ready to run, so Idle finally runs until...</li>
<li>MidB unblocks and runs.</li>
</ol>
<p>All of the above context switching is managed by the scheduler in the RTOS.</p>
<h1 id="additional-resources">Additional Resources</h1>
<p>Additional training and reference material for RTOS is available in the following places:</p>
<h2 id="simplelink-academy">SimpleLink Academy</h2>
<ul>
<li><a href="../tirtos_basics/tirtos_basics.html">TI-RTOS Basics</a></li>
<li><a href="../freertos_basics/freertos_basics.html">FreeRTOS Basics</a></li>
<li><a href="../tidrivers_project_zero/tidrivers_project_zero.html">TI Drivers Project Zero</a></li>
</ul>
<h2 id="simplelink-sdk-product">SimpleLink SDK Product</h2>
<ul>
<li>Refer to <em>SimpleLink_SDK_Install_Dir</em>\docs\Documentation_Overview.html</li>
</ul>
<div align="center" style="margin-top: 4em; font-size: smaller;">
<a rel="license" href="http://creativecommons.org/licenses/by-nc-nd/4.0/"><img alt="Creative Commons License" style="border-width:0" src="../../web_support/cc_license_icon.png"></a><br>This work is licensed under a <a rel="license" href="http://creativecommons.org/licenses/by-nc-nd/4.0/">Creative Commons Attribution-NonCommercial-NoDerivatives 4.0 International License</a>.</div>

</div><div class="col-xs-4 col-sm-2 sidebar-offcanvas bs-docs-sidebar hidden-print" id="sidebar-overview"><ul class="nav nav-stacked fixed" id="sidebar"><li><a href="#introduction">Introduction</a></li><li><a href="#terminology">Terminology</a><ul class="nav nav-stacked"><li><a href="#standard-types-of-threads">Standard types of threads</a></li><li><a href="#schedulers">Schedulers</a></li><li><a href="#other-key-terms">Other key terms</a></li></ul></li><li><a href="#bare-metal-vs-rtos">Bare-Metal vs. RTOS</a></li><li><a href="#rtos-components">RTOS Components</a></li><li><a href="#posix-support-in-simplelink-sdk">POSIX Support in SimpleLink SDK</a></li><li><a href="#rtos-threads-communication">RTOS Threads Communication</a><ul class="nav nav-stacked"><li><a href="#semaphore">Semaphore</a></li><li><a href="#message-queue">Message Queue</a></li><li><a href="#execution">Execution</a></li></ul></li><li><a href="#additional-resources">Additional Resources</a><ul class="nav nav-stacked"><li><a href="#simplelink-academy">SimpleLink Academy</a></li><li><a href="#simplelink-sdk-product">SimpleLink SDK Product</a></li></ul></li></ul></div></div></div></div>




<link rel="stylesheet" href="../../web_support/highlight/styles/zenburn.css">
<script src="../../web_support/strapdown/vendor/jquery-1.11.2.min.js"></script>
<script src="../../web_support/strapdown/vendor/bootstrap.min.js"></script>
<script src="../../web_support/highlight/highlight.pack.js"></script>
<script type="text/javascript">document.isPreRendered = true;</script><script src="../../web_support/strapdown/v/0.2/strapdown.js"></script>      <div class="modal" id="imagemodal" tabindex="-1" role="dialog" aria-labelledby="myModalLabel" aria-hidden="true">        <div class="vertical-alignment-helper">          <div class="modal-dialog vertical-align-center">             <div class="modal-dialog">               <div class="modal-content" style="margin-left: auto;margin-right: auto;">                 <div class="modal-body">                   <button type="button" class="close" data-dismiss="modal"><span aria-hidden="true">×</span><span class="sr-only">Close</span></button>                   <img src="" class="imagepreview img-responsive">                 </div>              </div>            </div>          </div>        </div>      </div>


</body></html>