<!DOCTYPE html><html><head>
<meta charset="UTF-8">
<title>TI-RTOS Basics</title>
<link rel="stylesheet" href="../../web_support/strapdown/v/0.2/fonts/ubuntu-regular-woff.css"><link rel="stylesheet" href="../../web_support/strapdown/v/0.2/fonts/glyphicons-halflings-regular.css"><link rel="stylesheet" href="../../web_support/strapdown/v/0.2/themes/united2.min.css"><link rel="stylesheet" href="../../web_support/strapdown/v/0.2/themes/bootstrap-responsive.min.css"><link rel="stylesheet" href="../../web_support/strapdown/v/0.2/strapdown.css"><link rel="shortcut icon" type="image/x-icon" href="../../.metadata/favicon.ico"></head>

<!-- START PRE -->






<!-- END PRE -->

<body style=""><div class="container"><nav class="navbar navbar-default navbar-static-top"><div class="container-fluid"> <div class="navbar-header">  <div id="headline" class="navbar-brand">TI-RTOS Basics</div> </div> </div></nav><div class="container"><div class="row row-offcanvas row-offcanvas-left"><div class="col-xs-12 col-sm-9" id="content"><h1 id="introduction">Introduction</h1>
<p>The SimpleLink™ software development kits (SDKs) includes TI-RTOS support.</p>
<p>TI-RTOS accelerates development schedules by eliminating the need to create basic system software functions from scratch. TI-RTOS scales from a minimal footprint real-time multitasking kernel - TI-RTOS Kernel (formerly known as SYS/BIOS) - to a complete RTOS solution including protocol stacks, multi-core communications, device drivers and power management. By providing essential system software components pre-tested and pre-integrated, TI-RTOS enables developers to focus on differentiating their application.</p>
<p>TI-RTOS is included in all SimpleLink SDKs.</p>
<p><strong>Here's what we'll learn:</strong></p>
<ul>
<li>TI-RTOS support in SimpleLink SDK</li>
<li>Main components of TI-RTOS</li>
</ul>
<p>This module includes quite a bit of text before the lab. Some people find this helpful and others feel that it slows down the whole session. If you are in the latter camp, please feel free to jump directly to the lab. For more details about specific features, you can go back and read the following content as needed.</p>
<h1 id="recommended-background-reading">Recommended Background Reading</h1>
<p>It is strongly recommend you are familiar with the following item.</p>
<ul>
<li><a href="../rtos_concepts/rtos_concepts.html">RTOS Concepts</a></li>
</ul>
<h1 id="a-brief-history-of-ti-rtos">A Brief History of TI-RTOS</h1>
<p>First let's look at the history of the RTOSes that have been developed and supported by Texas Instruments</p>
<ul>
<li><strong>DSP/BIOS</strong>: 1999-current. RTOS that is available for C2xxx, MSP430, C54xx, C55xx, and C6xxx devices. Currently in maintenance-mode only. Available as a stand-alone product.</li>
<li><strong>TI-RTOS</strong>: 2008-current. Started as SYS/BIOS and was re-branded to TI-RTOS in 2014. TI-RTOS is available for C2xxx, MSP43x, C6xxx, CortexA and CortexM devices. Active development of new features is ongoing. Currently running on millions of devices (e.g. IoT, automotive, industrial, etc.).</li>
</ul>
<h1 id="ti-rtos-product">TI-RTOS Product</h1>
<p>For several years, TI-RTOS has been available three ways</p>
<ul>
<li><strong>Processors SDK</strong>: For Keystone and Sitara devices, the TI-RTOS kernel is included in the Processors SDK.</li>
<li><strong>SYS/BIOS product</strong>: The kernel product is available as a stand-alone product. This product is recommended for non-Concerto C2000 devices or for customers that want a version of TI-RTOS that is newer than the ones supplied in the Processors SDKs.</li>
<li><p><strong>TI-RTOS Product</strong>: These products contained both TI-RTOS and RTOS-aware drivers (e.g. UART, I2C, etc.) for MCU devices. The following TI-RTOS products are available:</p>
<p></p><div class="modal-pop" style="cursor:zoom-in;"><img src="./resources/tirtos_products.png" alt="" class="img-responsive"></div><p></p>
</li>
</ul>
<p>Going forward, for the MSP432, CC32xx, CC26xx, or CC13xx devices, all of TI-RTOS product content is now in the <strong>SimpleLink SDK</strong>. The existing TI-RTOS products for these devices will still be available, but for new customer development, we <strong>strongly</strong> recommend you use the corresponding SimpleLink SDK.</p>
<p>For customers that are currently using a TI-RTOS product (e.g. TI-RTOS for CC13xx/CC26xx v2.21.00.06) and want a new release, they should get the new corresponding SimpleLink SDK product. A migration guide in the SimpleLink SDK gives instruction on how to make the migration from a TI-RTOS product to a SimpleLink SDK.</p>
<div class="bs-callout bs-callout-warning "><h4><span class="glyphicon glyphicon-exclamation-sign gi-2x" style="vertical-align: middle; margin-right: 0.2em;"></span><span style="vertical-align: middle;">TI-RTOS and TI Drivers for MSP432, CC32xx, CC13xx, or CC26xx SimpleLink devices are now in SimpleLink SDK products
</span></h4>
<p>Going forward, no new TI-RTOS products will be available for these SimpleLink devices. TI-RTOS and SYS/BIOS delivery for non-SimpleLink devices (first two above bullets) will continue as is with new releases as warranted.</p>
</div>
<p>New TI-RTOS releases of the non-SimpleLink MCUs will continue.</p>
<h1 id="ti-rtos-kernel">TI-RTOS Kernel</h1>
<p>At the center of TI-RTOS is the kernel. We'll look at the main modules of the kernel is this section. For more specific details on any of these kernel modules,
please refer to the <code>Kernel Documentation</code> section of the
SimpleLink SDK Documentation Overview: <code>[SimpleLink SDK] &gt; Documents &gt; Documentation Overview.html</code></p>
<div class="bs-callout bs-callout-info "><h4><span class="glyphicon glyphicon-info-sign gi-2x" style="vertical-align: middle; margin-right: 0.2em;"></span><span style="vertical-align: middle;">The TI-RTOS kernel code is in the ROM for CC13xx and CC26xx devices.
</span></h4>
<p>This allows the application to utilize more of the flash. Please note, the kernel still requires a small amount of flash and/or RAM memory.</p>
</div>
<h2 id="scheduler">Scheduler</h2>
<p>The main function of the kernel is the scheduler. The scheduler is responsible for making sure the highest priority thread is running.</p>
<p>Let's look at the four different types of threads in TI-RTOS.</p>
<p></p><div class="modal-pop" style="cursor:zoom-in;"><img src="./resources/tirtos_threads.png" alt="" class="img-responsive"></div><p></p>
<p>  Let's go into a little more detail for each one.</p>
<ul>
<li><p><strong>Hardware Interrupts (Hwi)</strong>:
Hwi run to completion. They don't block on anything. They can get preempted by a higher priority Hwi. All Hwi share the same stack (system stack).</p>
<p>Hwi can be written in 'C'. They are managed by the TI-RTOS scheduler with an exception: zero-latency interrupts. Applications can designate that any interrupt be a "zero-latency" interrupt. This means the TI-RTOS scheduler does not interact with that interrupt. We call it a zero-latency interrupt because the TI-RTOS kernel adds zero latency to the execution of these interrupts. The downside to zero-latency interrupts is that they cannot call into the kernel scheduler APIs (e.g. <code>Semphore_post()</code>, etc.).</p>
</li>
<li><p><strong>Software Interrupts (Swi)</strong>:
The Swi thread is similar to a Hwi except it is software initiated instead of hardware. It also runs to completion. It shares the same system stack with the Hwi threads. Since Swi run at a lower priority than Hwi, they are useful for doing deferred Hwi work to minimize interrupt latency.</p>
</li>
<li><p><strong>Tasks</strong>:
Task are a common OS thread. Each task has its own stack (where it maintains its state). Since it has its own stack, a task can block. There is no maximum number of allowable tasks (except by how much memory is in the system).</p>
<p>Here are the states for a Task.</p>
<p></p><div class="modal-pop" style="cursor:zoom-in;"><img src="./resources/task_states.png" alt="" class="img-responsive"></div><p></p>
</li>
<li><p><strong>Idle</strong>:
Idle is a special task. It runs at the lowest priority (0 is the lowest priority, 1 is the next lowest, ..., (Task_numPriorities - 1)). The Idle task performs background tasks like system stack checking (if enabled), CPU Load determination (if enabled), etc. It also executes functions plugged in by the application.</p>
<p>For low power devices, Idle is the place where the device can be placed into lower power modes.</p>
</li>
</ul>
<p>For an preemption example, please refer to the <a href="../rtos_concepts/rtos_concepts.html">RTOS Concepts</a> workshop. There is an execution graph of a typical application.</p>
<h2 id="thread-communication">Thread Communication</h2>
<p>TI-RTOS contains several thread communication mechanisms. Here are the main ones that are used.</p>
<ul>
<li><strong>Semaphores</strong>: An object used to control access to a common resource. They can be used for task synchronization and mutual exclusion.</li>
<li><strong>Mailboxes</strong>: Message passing module</li>
<li><strong>Queues</strong>: Doubly linked list (no synchronization though)</li>
<li><strong>Gates</strong>: Used to protect concurrent access to critical data structures. A Gate is a reentrant mutex.</li>
<li><strong>Events</strong>: Module which allows synchronization via multiple events.</li>
</ul>
<p>Let's look at a couple of these in action.</p>
<ul>
<li><p><strong>Semaphore Example 1</strong>: Here is an example of a semaphore being used to manage a linked list (Queue). This semaphore is a counting semaphore since it is managing potentially multiple elements on the linked list. After an element is placed on the queue, the semaphore is posted to wake up the receiver. We want a counting semaphore here (with initial value of 0) since we may put multiple elements on the linked list before the receiver gets them.</p>
<p>The right side of the picture shows the IDE console output depending on the priority setting of the respective tasks. Remember that TI-RTOS is a preemptive scheduler, so once the highest priority thread is ready, it will run.</p>
<blockquote>
<p></p><div class="modal-pop" style="cursor:zoom-in;"><img src="./resources/semaphorequeue_code.png" alt="" class="img-responsive"></div><p></p>
</blockquote>
<p>Note: <code>Queue_put()</code> and <code>Queue_get()</code> add/remove elements from the linked list in an atomic manner. Thread-safety is guaranteed. Also note that the user's data structure provides the <code>prev</code> and <code>next</code> pointers via the <code>Queue_Elem</code> field in their <code>MyMsg</code> structure. This avoids memory allocation in the Queue module and also allows the linked list to be infinitely long (or however as much memory as you have).</p>
</li>
<li><p><strong>Semaphore Example 2</strong>: In this example, the semaphore is being treated as a mutex (MUTual EXclusion). If another task wanted to access the global structure <code>myGlobal</code>, it should use the same semaphore to wrap the changes. This protects the updating of the shared structure. The area being protected is often called a <em>critical region</em>.</p>
<blockquote>
<p></p><div class="modal-pop" style="cursor:zoom-in;"><img src="./resources/semaphore_code.png" alt="" class="img-responsive"></div><p></p>
</blockquote>
<p>Let's look at what happens if we did not do this. Say <code>writer1</code> (priority 1) and <code>writer2</code> (priority 2) tasks both modify this structure and <code>reader</code> reads and acts on this struct. Let's say <code>writer1</code> is running and <code>writer2</code> is blocked. Here is a situation where without the semaphore protection, corruption can occur.</p>
<blockquote>
<p></p><div class="modal-pop" style="cursor:zoom-in;"><img src="./resources/semaphore_bad_case.png" alt="" class="img-responsive"></div><p></p>
</blockquote>
<p>Now the request is to have bufferB read into bufferC...no one asked for that! If the semaphore was used, writer1 would have completed updating the entire global first. Please note this is a somewhat contrived example, but hopefully clearly shows why managing critical regions is important.</p>
<p>When this semaphore was created, it could have been binary (since the count will only be 0 or 1) and the initial count should have been 1 (to allow the first <code>Semaphore_pend()</code> to succeed).</p>
<div class="bs-callout bs-callout-info "><h4><span class="glyphicon glyphicon-info-sign gi-2x" style="vertical-align: middle; margin-right: 0.2em;"></span><span style="vertical-align: middle;">Other types of mutual exclusion...
</span></h4>
<p>The Gate module can be used for mutual exclusion also. Also for such a short critical region, you could have just disabled/restored interrupts (<code>Hwi_disable()</code> &amp; <code>Hwi_restore()</code>).</p>
</div>
</li>
<li><p><strong>Mailbox Example</strong>: Here is a modified version of the examples/rtos/<em>Board</em>/sysbios/mailbox example (error checking/output removed). The <code>writerTask</code> is sending messages to the <code>readerTask</code>. The contents of the message are application specific.</p>
<blockquote>
<p></p><div class="modal-pop" style="cursor:zoom-in;"><img src="./resources/mailbox_code.png" alt="" class="img-responsive"></div><p></p>
</blockquote>
<p>Please note, you specify different timeouts on both the sending and receiving. This allows a Mailbox to be used by a Hwi, Swi or Task.</p>
</li>
</ul>
<h2 id="timing-services">Timing Services</h2>
<ul>
<li><strong>Timer</strong>: Module that allows management of hardware timers.</li>
<li><strong>Clock</strong>: TI-RTOS, by default, uses a timer to drive timing services (e.g. <code>Task_sleep()</code>, etc.). Applications can plug functions into the Clock module that will be called at the rate they request. Your plugged in Clock functions can be periodic or one-shot.</li>
<li><strong>Seconds</strong>: Unified front-end to the device's RTC timer.</li>
</ul>
<h2 id="memory-managers">Memory Managers</h2>
<p>TI-RTOS offers many types of memory managers. Here is an overview of the main heap implementations</p>
<table class="table table-striped table-bordered">
<thead>
<tr>
<th>Heap</th>
<th>Description</th>
<th>Reason to use</th>
</tr>
</thead>
<tbody>
<tr>
<td>HeapMem</td>
<td>Variable size allocation</td>
<td>Very flexible</td>
</tr>
<tr>
<td>HeapBuf</td>
<td>Fixed size allocation</td>
<td>Fast and deterministic</td>
</tr>
<tr>
<td>HeapMultiBuf</td>
<td>Multiple fixed size allocation</td>
<td>Fast and deterministic</td>
</tr>
<tr>
<td>HeapMin</td>
<td>Variable size, growth only</td>
<td>Fast and deterministic (but cannot call free)</td>
</tr>
<tr>
<td>HeapTrack</td>
<td>Stacking diagnostic heap</td>
<td>Helps find memory leaks, corruption, etc.</td>
</tr>
</tbody>
</table>
<p>The heaps sit underneath the <code>Memory_alloc()</code> and <code>Memory_free()</code> APIs.</p>
<p>By default TI-RTOS creates a <em>system</em> (or <em>default</em>) heap. This heap is used when you pass in <code>NULL</code> for the <code>IHeapHandle</code> in <code>Memory_alloc()</code> and <code>Memory_free()</code>. The <em>system</em> heap is also used in <code>malloc()</code> and <code>free()</code> functions (the kernel replaces the RTS <code>malloc()</code> and <code>free()</code> functions). By default, the <em>system</em> heap is a HeapMem instance and the size is controlled by the settings in the linker command files. For example here is the sizing of the <em>system</em> heap in the MSP_EXP432P401R_TIRTOS.cmd linker file.</p>
<blockquote>
<p></p><div class="modal-pop" style="cursor:zoom-in;"><img src="./resources/systemheap_sizing.png" alt="" class="img-responsive"></div><p></p>
</blockquote>
<p>An application can have more than one heap in the application. A common usage is to have the <em>system</em> heap be HeapMem and then create a HeapBuf instance to manage fixed-blocks that can be allocated and freed quickly with no fragmentation (or to be more exact...no external fragmentation). We generally see that people leave the <em>system</em> heap as a HeapMem instance. This is because it may be hard to know where all the allocations (and the size of the allocations) in an application are occurring.</p>
<h2 id="posix-portable-operating-system-interface-support">POSIX (Portable Operating System Interface) Support</h2>
<p>POSIX is an IEEE industry API standard for OS compatibility. The SimpleLink SDK provides support for POSIX APIs on top of TI-RTOS (as it does for FreeRTOS). For details about POSIX, please refer to <a href="http://pubs.opengroup.org/onlinepubs/9699919799/">IEEE POSIX</a>. For a more details description of the POSIX support in SimpleLink SDKs, please refer to the <a href="../posix_project_zero/posix_project_zero.html">POSIX Overview Workshop</a>.</p>
<h1 id="simplelink-sdk-components-and-ti-rtos">SimpleLink SDK Components and TI-RTOS</h1>
<h2 id="ti-drivers">TI Drivers</h2>
<p>The TI Drivers (including Power Management) are written to be used with the Driver Porting Layer (DPL). The SimpleLink SDK includes a DPL implementation for both FreeRTOS and TI-RTOS.
</p><div class="modal-pop" style="cursor:zoom-in;"><img src="./resources/driver_levels_dpl.png" alt="" class="img-responsive"></div><p></p>
<div class="bs-callout bs-callout-warning "><h4><span class="glyphicon glyphicon-exclamation-sign gi-2x" style="vertical-align: middle; margin-right: 0.2em;"></span><span style="vertical-align: middle;">DPL is not a full feature Operating System Abstraction Layer (OSAL).
</span></h4>
<p>It was developed specifically to meet the needs of the TI Drivers. Therefore, it is not recommended that application code use the DPL interface. For application code that wants OS abstraction, please use POSIX APIs, not DPL.</p>
</div>
<h2 id="other">Other</h2>
<p>Here is a quick overview of some of the other SimpleLink SDK components works with TI-RTOS.</p>
<ul>
<li><strong>source\third_party\fatfs</strong>: Works with TI-RTOS</li>
<li><strong>source\ti\display</strong>: Works with TI-RTOS</li>
<li><strong>source\ti\grlib</strong>: Works with TI-RTOS but should only be used by one task at a time.</li>
</ul>
<h1 id="ti-rtos-configuration-and-examples">TI-RTOS Configuration and Examples</h1>
<p>The kernel is built based on the settings in the TI-RTOS kernel configuration file (also called the .cfg file). This file is basically a JavaScript file that can be edited as a text file or graphically (graphically is only available in CCS). As part of the application build, the .cfg file generates the kernel objects and libraries.</p>
<p>There are two different ways for an application to include the TI-RTOS kernel configuration file in the SimpleLink SDKs:</p>
<ul>
<li>Application projects  include the .cfg file</li>
<li>Application projects (e.g. TI Drivers examples) point to a TI-RTOS kernel configuration project</li>
</ul>
<p>The end result of the two approaches are essentially the same. The separate kernel configuration project approach works better when you want to have the same application use TI-RTOS or FreeRTOS.</p>
<h2 id="kernel-projects">Kernel Projects</h2>
<p>The TI-RTOS kernel is built via a provided project. The examples that are TI-RTOS based (e.g. TI Drivers examples) point to the kernel project. The SDK provides the kernel project in the kernel/tirtos/builds/BOARD/release and debug directories. For example, here is the directory that contains the <code>release.cfg</code> kernel configuration file.</p>
<p></p><div class="modal-pop" style="cursor:zoom-in;"><img src="./resources/kernel_directory.png" alt="" class="img-responsive"></div><p></p>
<p>The kernel project is automatically imported when a TI-RTOS example is imported. A copy of the kernel project is made in the workspace.</p>
<p>Alternatively, this project can be imported into CCS by selection <strong>Project → Import CCS Projects...</strong> and navigating to the kernel/tirtos/builds directory. Then select the desired board and compiler project.</p>
<p></p><div class="modal-pop" style="cursor:zoom-in;"><img src="./resources/import_kernel.png" alt="" class="img-responsive"></div><p></p>
<p>Here is what the imported kernel project looks like. You see the <code>debug.cfg</code> file. Note: the <em>release</em> configuration is used by default for all of the examples.</p>
<p></p><div class="modal-pop" style="cursor:zoom-in;"><img src="./resources/imported_project.png" alt="" class="img-responsive"></div><p></p>
<p>For more details on how to change or create new TI-RTOS kernel projects, please refer to the "SimpleLink SDK User Guide". We do recommend that you use the <em>debug</em> kernel configuration project while developing your application. It has many nice debug features enabled (e.g. stack overflow checking, assert checking, etc.).</p>
<h2 id="examples">Examples</h2>
<p>Many examples (e.g. TI Drivers examples) are available for both FreeRTOS and TI-RTOS. When an example is imported, the kernel project is automatically imported also. Here is a picture of the projects when empty was imported.</p>
<p></p><div class="modal-pop" style="cursor:zoom-in;"><img src="./resources/imported_example.png" alt="" class="img-responsive"></div><p></p>
<p>The empty project points to the kernel project via the <code>Project Properties</code> → <code>Build</code> → <code>Dependencies</code> setting. Please refer to the "SimpleLink SDK User Guide" for more details on the management of this setting.</p>
<p></p><div class="modal-pop" style="cursor:zoom-in;"><img src="./resources/dependent_project.png" alt="" class="img-responsive"></div><p></p>
<p>Many of the examples use the POSIX layer to allow them to be used with TI-RTOS or FreeRTOS. All the TI-RTOS specific code is in <code>main_tirtos.c</code> file (there is a <code>main_freertos.c</code> for FreeRTOS based examples). The majority of the file contains POSIX APIs, but at the end of <code>main()</code>, the call to start the TI-RTOS scheduler is made.</p>
<p></p><div class="modal-pop" style="cursor:zoom-in;"><img src="./resources/main_tirtos.png" alt="" class="img-responsive"></div><p></p>
<p>The linker command file is slightly different from the FreeRTOS one also. The two set up the dynamic heap slightly differently in the linker file.</p>
<div class="bs-callout bs-callout-info "><h4><span class="glyphicon glyphicon-info-sign gi-2x" style="vertical-align: middle; margin-right: 0.2em;"></span><span style="vertical-align: middle;">POSIX is not required for TI-RTOS
</span></h4>
<p>Even though the TI-RTOS examples use POSIX in the SimpleLink SDK, it is not required. You can use the native TI-RTOS APIs instead or along with the POSIX APIs if you prefer. Using POSIX is recommended if you</p>
<ul>
<li>want an application that is portable across different RTOSes</li>
<li>you have existing code that uses it</li>
<li>are comfortable with the slight over-head it introduces</li>
</ul>
<p>Please refer to the <code>demos\portable</code> and <code>demos\portableNative</code> examples to see a comparison of using POSIX vs the native RTOS APIs.</p>
</div>
<h1 id="debugging-features-and-tools">Debugging Features and Tools</h1>
<p>TI-RTOS supports many powerful debugging features. For a nice overview, please watch this <a href="https://training.ti.com/debugging-common-application-issues-ti-rtos">Debugging Common Application Issues with TI-RTOS</a> video.</p>
<h2 id="rtos-object-view-rov-">RTOS Object View (ROV)</h2>
<p>ROV a tool in CCS that lets you see see the state of the kernel. Let's run the portable project and look at a couple key things. ROV can be opened via <strong>Tools → RTOS Object View (ROV)</strong> or <strong>Tools → ROV Classic</strong> when in the debug perspective of CCS (ROV is also supported in IAR. Please refer to the "SimpleLink SDK Quick Start Guide" for more details).</p>
<p>Here is view of the tasks in the system. You can see the three tasks in the system, their priorities and stack usage. Red text (e.g. stackPeak for <code>consoleThread</code>) means the value has changed this the last time you halted the target</p>
<p></p><div class="modal-pop" style="cursor:zoom-in;"><img src="./resources/rov_tasks.png" alt="" class="img-responsive"></div><p></p>
<p>If you made the stack size too small, it can quickly be found in ROV via the red background.</p>
<p></p><div class="modal-pop" style="cursor:zoom-in;"><img src="./resources/rov_tasks_stack.png" alt="" class="img-responsive"></div><p></p>
<p>You can also get nice exception handling information from ROV.</p>
<p></p><div class="modal-pop" style="cursor:zoom-in;"><img src="./resources/rov_exception.png" alt="" class="img-responsive"></div><p></p>
<p>The "BIOS-&gt;Scan for errors..." is a fast and easy way to determine if the RTOS is in a bad state (e.g. blown stacks, corrupted data because of bad application pointers or buffer overflows, etc.).</p>
<p></p><div class="modal-pop" style="cursor:zoom-in;"><img src="./resources/rov_scan.png" alt="" class="img-responsive"></div><p></p>
<p>ROV has no overhead on the target. The tool is reading memory down on the target via emulation (note the target must be halted). There is nothing you have to turn on to get ROV support.</p>
<h2 id="runtime-object-view">Runtime Object View</h2>
<p>Starting with CCS 7.1, Runtime Object View (let's call it ROV2 for short) will be available also. ROV2 is basically ROV on steroids. You get all the information that was available in ROV but you can few multiple things at once. It includes support for graphs. You can open ROV2 via "Tools-&gt;Runtime Object View"</p>
<p></p><div class="modal-pop" style="cursor:zoom-in;"><img src="./resources/rov2_dashboard.png" alt="" class="img-responsive"></div><p></p>
<p>You can save your ROV2 session as a dashboard, so the next time you open ROV2, you can import that dashboard and get your customized view of the target. The TI-RTOS examples (both kernel and TI Drivers) ship a dashboard in the project called <code>overview.rov.json</code>. The <code>overview.rov.json</code> dashboard was to used in the above picture.</p>
<p></p><div class="modal-pop" style="cursor:zoom-in;"><img src="./resources/imported_example_rov2.png" alt="" class="img-responsive"></div><p></p>
<p>To load the dashboard, simply select the "Import a dashboard" button and import the overview.rov.json.</p>
<p></p><div class="modal-pop" style="cursor:zoom-in;"><img src="./resources/rov2_import.png" alt="" class="img-responsive"></div><p></p>
<p>More information about ROV2 can be found here at </p>
<ul>
<li><a href="http://processors.wiki.ti.com/index.php/Runtime_Object_View_%28ROV%29">Runtime Object View Wiki</a></li>
<li><a href="https://training.ti.com/runtime-object-view">Runtime Object View Video</a></li>
</ul>
<h2 id="system-analyzer">System Analyzer</h2>
<p>System Analyzer in CCS allows you to visually see key items like execution graph, CPU load, ave/max/min execution times for code segments, etc. This is accomplished by logging records on target. The typical use is to have the records maintained in buffers on the target which System Analyzer reads while the target is halted. However there are runtime reading capabilities also for getting the log records off the target (e.g. UART).</p>
<p>Here is an example of execution of the mutex example in the SDK. The logging of TI-RTOS kernel log records can be turned on (it's on in the debug kernel project). All the context switches are logged on the target and interpreted in CCS.</p>
<p></p><div class="modal-pop" style="cursor:zoom-in;"><img src="./resources/execution_graph.png" alt="" class="img-responsive"></div><p></p>
<p>Okay...this execution graph is a little boring, but you can see how easy it is to see what is happening. You can add in interrupt execution and pending/posting of semaphore to see even more granularity.</p>
<h1 id="lab-getting-started">Lab: Getting started</h1>
<h2 id="software">Software</h2>
<ul>
<li>CCS as specified by your SimpleLink SDK Release Notes (please use Desktop version, not CCS Cloud)</li>
<li>Any SimpleLink SDK</li>
</ul>
<h2 id="hardware">Hardware</h2>
<ul>
<li>Any supported SimpleLink LaunchPad™ Development Kit</li>
</ul>
<p>The below steps will use simplelink_cc2640r2_sdk_1_30_00_25 along with the CC2640R2-LAUNCHXL LaunchPad board. So some of the pictures/directory names/line numbers/sizes/etc. might be slightly different.</p>
<h2 id="making-sure-it-works">Making sure it works</h2>
<p>Open your Desktop Code Composer Studio and import the TI-RTOS <code>hello</code> project from your SimpleLink SDK inside of Resource Explorer. We'll be changing the TI-RTOS kernel configuration file and this is not currently supported in CCS Cloud. Make sure to select the "CCS Compiler" version.</p>
<p></p><div class="modal-pop" style="cursor:zoom-in;"><img src="./resources/import_project.png" alt="" class="img-responsive"></div><p></p>
<p>To test that the software and hardware pre-requisites are fulfilled we are going to build and run the project before going to the first task.</p>
<ul>
<li>Our first mission is to build the imported project. Select the project in Project Explorer and build the project.</li>
<li>When the project is built, we are going to make sure that the hardware and debugger work. To start debugging, press <code>Run</code> → <code>Debug</code>, or press F11.</li>
<li>When the download is finished, press F8 or the green play button to run.</li>
<li>You should see "hello world". The program terminates after printing the text. For example, this is what it should like like on a CC2640R2-LAUNCHXL LaunchPad.</li>
</ul>
<p></p><div class="modal-pop" style="cursor:zoom-in;"><img src="./resources/hello_world.png" alt="" class="img-responsive"></div><p></p>
<div class="bs-callout bs-callout-warning "><h4><span style="vertical-align: middle;">On Building
</span></h4>
<p>Note that the first time you build the project the whole TI-RTOS kernel will also be built. This may take a minute or two, but is only done the first time. Subsequent builds will re-use the compiled kernel unless a configuration change is done.</p>
</div>
<h1 id="task-1-replacing-the-contents-of-hello-c">Task 1 - Replacing the contents of hello.c</h1>
<p>Please select the below text and replace the entire contents of <code>hello.c</code> (you can leave the license banner if you want). Then rebuild/reload/run the project. You should get a flashing LED.</p>
<div style="display:inline-block"><div style="display:block"><button type="button" class="btn btn-xs btn-warning float-right select-text" style="margin: 0; position: relative;" onclick="SelectText('codeBlock_1')">Select text</button></div><div class="pre-container"><pre><code id="codeBlock_1" class="lang-c hljs cpp"><span class="hljs-comment">/* TI-RTOS Header files */</span>
<span class="hljs-preprocessor">#<span class="hljs-keyword">include</span> &lt;xdc/std.h&gt;</span>
<span class="hljs-preprocessor">#<span class="hljs-keyword">include</span> &lt;ti/sysbios/BIOS.h&gt;</span>
<span class="hljs-preprocessor">#<span class="hljs-keyword">include</span> &lt;ti/sysbios/knl/Task.h&gt;</span>

<span class="hljs-preprocessor">#<span class="hljs-keyword">include</span> &lt;ti/drivers/GPIO.h&gt;</span>

<span class="hljs-comment">/* Example/Board Header files */</span>
<span class="hljs-preprocessor">#<span class="hljs-keyword">include</span> "Board.h"</span>

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">myDelay</span><span class="hljs-params">(<span class="hljs-keyword">int</span> count)</span></span>;

<span class="hljs-comment">/* Could be anything, like computing primes */</span>
<span class="hljs-preprocessor">#<span class="hljs-keyword">define</span> FakeBlockingSlowWork()   myDelay(12000000)</span>
<span class="hljs-preprocessor">#<span class="hljs-keyword">define</span> FakeBlockingFastWork()   myDelay(2000000)</span>

Task_Struct workTask;
<span class="hljs-comment">/* Make sure we have nice 8-byte alignment on the stack to avoid wasting memory */</span>
<span class="hljs-preprocessor">#<span class="hljs-keyword">pragma</span> DATA_ALIGN(workTaskStack, 8)</span>
<span class="hljs-preprocessor">#<span class="hljs-keyword">define</span> STACKSIZE 1024</span>
<span class="hljs-keyword">static</span> <span class="hljs-keyword">uint8_t</span> workTaskStack[STACKSIZE];

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">doUrgentWork</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span>
</span>{
    GPIO_write(Board_GPIO_LED1, Board_GPIO_LED_OFF);
    FakeBlockingFastWork(); <span class="hljs-comment">/* Pretend to do something useful but time-consuming */</span>
    GPIO_write(Board_GPIO_LED1, Board_GPIO_LED_ON);
}

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">doWork</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span>
</span>{
    GPIO_write(Board_GPIO_LED0, Board_GPIO_LED_OFF);
    FakeBlockingSlowWork(); <span class="hljs-comment">/* Pretend to do something useful but time-consuming */</span>
    GPIO_write(Board_GPIO_LED0, Board_GPIO_LED_ON);
}

<span class="hljs-function">Void <span class="hljs-title">workTaskFunc</span><span class="hljs-params">(UArg arg0, UArg arg1)</span>
</span>{
    <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>) {

        <span class="hljs-comment">/* Do work */</span>
        doWork();

        <span class="hljs-comment">/* Wait a while, because doWork should be a periodic thing, not continuous.*/</span>
        myDelay(<span class="hljs-number">24000000</span>);
    }
}

<span class="hljs-comment">/*
 *  ======== main ========
 *
 */</span>
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span>
</span>{
    Board_initGeneral();
    GPIO_init();

    <span class="hljs-comment">/* Set up the led task */</span>
    Task_Params workTaskParams;
    Task_Params_init(&amp;workTaskParams);
    workTaskParams.stackSize = STACKSIZE;
    workTaskParams.priority = <span class="hljs-number">2</span>;
    workTaskParams.<span class="hljs-built_in">stack</span> = &amp;workTaskStack;

    Task_construct(&amp;workTask, workTaskFunc, &amp;workTaskParams, NULL);

    <span class="hljs-comment">/* Start kernel. */</span>
    BIOS_start();

    <span class="hljs-keyword">return</span> (<span class="hljs-number">0</span>);
}

<span class="hljs-comment">/*
 *  ======== myDelay ========
 *  Assembly function to delay. Decrements the count until it is zero
 *  The exact duration depends on the processor speed.
 */</span>
__asm(<span class="hljs-string">"    .sect \".text:myDelay\"\n"</span>
      <span class="hljs-string">"    .clink\n"</span>
      <span class="hljs-string">"    .thumbfunc myDelay\n"</span>
      <span class="hljs-string">"    .thumb\n"</span>
      <span class="hljs-string">"    .global myDelay\n"</span>
      <span class="hljs-string">"myDelay:\n"</span>
      <span class="hljs-string">"    subs r0, #1\n"</span>
      <span class="hljs-string">"    bne.n myDelay\n"</span>
      <span class="hljs-string">"    bx lr\n"</span>);
</code></pre><span class="code-title"><p>hello.c</p>
</span></div></div>
<h2 id="orienting-ourselves-in-the-code">Orienting ourselves in the code</h2>
<p>The Lab 1 example comes preconfigured with one TI-RTOS <code>Task</code> already constructed in <code>main()</code>. This task is set up to use the <code>workTaskFunc</code> function as the task function, which in turn uses the GPIO Driver to toggle a LED.</p>
<p>The task is created using the <code>Task_construct</code> in the main function. The <code>main</code> function also initializes the hardware.</p>
<p>In the <code>main()</code> function, after <code>BIOS_start()</code> is called it never returns, but instead give control to the TI-RTOS scheduler which will call the Task functions of the tasks that are constructed (e.g. <code>workTaskFunc</code>). Normally, task functions will enter an infinite loop and never return, letting TI-RTOS switch to higher priority tasks, Swi or Hwi.</p>
<h1 id="task-2-debugging-tools">Task 2 - Debugging Tools</h1>
<p>We are going to take a look at some of the built in features of CCS which can aid in the development of firmware running on TI-RTOS, and also give a better understanding of the multitasking.</p>
<h2 id="runtime-object-view">Runtime Object View</h2>
<p>As discussed above, Runtime Object View (we'll call it ROV2 here for short) can be used to get a snapshot of the whole RTOS. By default the information is only updated via JTAG when the target is halted. First we are going to halt the code as we are toggling the led.</p>
<ul>
<li><p>Put a breakpoint in the <code>workTaskFunc</code> on the <code>doWork</code> line. Do this by double clicking on the area on the left of the line number.</p>
<p></p><div class="modal-pop" style="cursor:zoom-in;"><img src="./resources/set_breakpoint.png" alt="" class="img-responsive"></div><p></p>
</li>
<li><p>Run so you hit that breakpoint.
Next open ROV2 by going to <code>Tools</code> → <code>Runtime Object View</code>. You'll be prompted to connect.</p>
<p></p><div class="modal-pop" style="cursor:zoom-in;"><img src="./resources/start_rov2.png" alt="" class="img-responsive"></div><p></p>
</li>
<li><p>In ROV2, select the "Import a dashboard" icon and select the <code>overview.rov.json</code> file that is in the project.</p>
<p></p><div class="modal-pop" style="cursor:zoom-in;"><img src="./resources/open_dashboard.png" alt="" class="img-responsive"></div><p></p>
<p>This dashboard shows which task is currently running on the system, what tasks are blocked as well as what tasks are ready to run.</p>
<p>We can see that the workTaskFunc is currently running and we can also see that the stack usage for the task has peaked at 112 of (1024) STACKSIZE bytes so far, so no risk of stack overflow
Note: we generally recommend you start with a larger stack size and then trim it down once everything is working properly.</p>
<p></p><div class="modal-pop" style="cursor:zoom-in;"><img src="resources/overview_dashboard.png" alt="ROV Viewer" class="img-responsive"></div><p></p>
<p>The 112 has a yellow background which means it has changed since the last time it was read.</p>
<p>The memory and stack usage graphs can be very useful also. If you run again to the breakpoint, the values will be updated.</p>
</li>
</ul>
<h2 id="execution-graph">Execution graph</h2>
<p>While ROV is handy to get a snapshot view over the current state of the system it is not as easy to get any information about the state of the system over time. For this we use the Execution graph.
For this, we'll need to edit the .cfg file.</p>
<div class="bs-callout bs-callout-info "><h4><span class="glyphicon glyphicon-info-sign gi-2x" style="vertical-align: middle; margin-right: 0.2em;"></span><span style="vertical-align: middle;">Edit the .cfg as text or graphically
</span></h4>
<p>  You can right-click the .cfg file and edit it as a text file (recommended for this lab) or graphically.</p>
</div>
<ul>
<li><p>First we need to enable the logging by changing the comments. Open the <code>hello.cfg</code> and enable the kernel's logging feature. Note: this is turned on in the debug TI-RTOS kernel configuration project used by the driver examples.</p>
<p></p><div class="modal-pop" style="cursor:zoom-in;"><img src="./resources/enable_bios_logs.png" alt="" class="img-responsive"></div><p></p>
<div class="bs-callout bs-callout-warning "><h4><span class="glyphicon glyphicon-exclamation-sign gi-2x" style="vertical-align: middle; margin-right: 0.2em;"></span><span style="vertical-align: middle;">For CC13xx/CC26xx devices, the kernel in the ROM has logs disabled.
</span></h4>
<p>To enable kernel to log events, you cannot use the kernel in the ROM. By removing (or commenting out) the following lines in the .cfg file, the kernel will be placed in the CC26xx's flash instead (and the kernel can log events).</p>
<div style="display:inline-block"><div style="display:block"><button type="button" class="btn btn-xs btn-warning float-right select-text" style="margin: 0; position: relative;" onclick="SelectText('codeBlock_2')">Select text</button></div><div class="pre-container"><pre><code id="codeBlock_2" class="lang-c hljs cpp">var ROM = xdc.useModule(<span class="hljs-string">'ti.sysbios.rom.ROM'</span>);
<span class="hljs-keyword">if</span> (Program.cpu.deviceName.match(/CC2640R2F/)) {
    ROM.romName = ROM.CC2640R2F;
}
<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (Program.cpu.deviceName.match(/CC26/)) {
    ROM.romName = ROM.CC2650;
}
<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (Program.cpu.deviceName.match(/CC13/)) {
    ROM.romName = ROM.CC1350;
}
</code></pre></div></div>
</div>
</li>
<li><p>Add the following lines to the bottom of the <code>hello.cfg</code> file. This will configure the kernel to maintain buffers on the target where the log records will reside. Note: this is also in the debug TI-RTOS kernel configuration project used by the driver examples.
We're only interested in the kernel's logging so we'll disable the CPU Load logging.</p>
<div style="display:inline-block"><div style="display:block"><button type="button" class="btn btn-xs btn-warning float-right select-text" style="margin: 0; position: relative;" onclick="SelectText('codeBlock_3')">Select text</button></div><div class="pre-container"><pre><code id="codeBlock_3" class="lang-c hljs cpp">var LoggingSetup = xdc.useModule(<span class="hljs-string">'ti.uia.sysbios.LoggingSetup'</span>);
LoggingSetup.sysbiosLoggerSize = <span class="hljs-number">1024</span>;
LoggingSetup.loadLogging = <span class="hljs-keyword">false</span>;
</code></pre></div></div>
</li>
<li><p>Rebuild, reload, and run the example for 10-15 seconds (to get a good amount of log data). Remember to remove any breakpoints. Press Suspend button to pause the execution of the program.</p>
</li>
<li><p>Next, open the Execution Analysis menu by going to <code>Tools</code> → <code>RTOS Analyzer</code> → <code>Execution Analysis</code>. Note: you may be asked to do a one-time setup.</p>
<p></p><div class="modal-pop" style="cursor:zoom-in;"><img src="resources/image002.png" alt="Execution Analysis" class="img-responsive"></div><p></p>
<p>Select only the <code>Execution Graph</code> in the next window, leave everything else as it was and press <strong>Start</strong>.</p>
<p>In the new Execution Graph tab, expand <code>Cortex_M3_0.*OS</code> to see that <code>Task.workTaskFunc</code> has been executing! In fact, it's the only task executing. The <code>Idle</code> task has not gotten any time at all during the execution of the program.</p>
<p></p><div class="modal-pop" style="cursor:zoom-in;"><img src="resources/execution_graph_starving.png" alt="" class="img-responsive"></div><p></p>
<div class="bs-callout bs-callout-warning "><h4><span class="glyphicon glyphicon-exclamation-sign gi-2x" style="vertical-align: middle; margin-right: 0.2em;"></span><span style="vertical-align: middle;">If there is nothing in the execution graph...
</span></h4>
<p>We have a small race condition in the tool. If there are no records, please select the Live Session tab and stop/start the collection.</p>
<p><a href="resources/failed_to_read.png">No records</a></p>
</div>
<p>There is only one task running the entire time. It's hogging all the processor.</p>
</li>
</ul>
<div class="bs-callout bs-callout-info "><h4><span style="vertical-align: middle;">How does the logging work?
</span></h4>
<p>The TI-RTOS module LoggingSetup, which is part of the Universal Instrumentation Architecture (UIA), sets the UIA module LoggerStopMode up as an interface for the XDC Runtime Log module, which has hooks into the Task, Hwi and Swi modules.</p>
<p>The TI-RTOS configuration script parsing acts as an extra precompile step which can add, remove and configure RTSC (Real-Time Software Components) modules by outputting .c and .h files used for later compilation and linking.</p>
</div>
<h1 id="task-3-sleeping-well">Task 3 - Sleeping well</h1>
<p>After looking at the Execution Graph, we can see that we have a problem with one of our tasks hogging all CPU resources. Let's take a look at our <code>workTaskFunc</code>.</p>
<div style="display:inline-block"><div style="display:block"><button type="button" class="btn btn-xs btn-warning float-right select-text" style="margin: 0; position: relative;" onclick="SelectText('codeBlock_4')">Select text</button></div><div class="pre-container"><pre><code id="codeBlock_4" class="lang-c hljs cpp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">doWork</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span>
</span>{
    GPIO_write(Board_GPIO_LED0, Board_GPIO_LED_OFF);
    FakeBlockingWork(); <span class="hljs-comment">/* Pretend to do something useful but time-consuming */</span>
    GPIO_write(Board_GPIO_LED0, Board_GPIO_LED_ON);
}

<span class="hljs-function">Void <span class="hljs-title">workTaskFunc</span><span class="hljs-params">(UArg arg0, UArg arg1)</span>
</span>{
    <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>) {

        <span class="hljs-comment">/* Do work */</span>
        doWork();

        <span class="hljs-comment">/* Sleep */</span>
        myDelay(<span class="hljs-number">24000000</span>);
    }
}
</code></pre><span class="code-title"><p>Work, "sleep", work.</p>
</span></div></div>
<p>The only thing the task does is execute the <code>doWork</code> function and then goes back to "sleep", except it never does go to sleep. The <code>myDelay</code> function is simply a function which burns CPU cycles in a loop. This is not the correct way to pass time in the RTOS.</p>
<p>One of the easiest ways to pass time in a task is to call <code>Task_sleep(numTicks)</code>. <code>Task_sleep</code> will simply make the current task sleep for as many system ticks as is specified in the argument. The current tick rate of the system is needed in order to know how long you will sleep. This is a constant value available via the <code>Clock_tickPeriod</code> variable. The value is the amount of microseconds per clock tick.</p>
<div class="bs-callout bs-callout-info "><h4><span style="vertical-align: middle;">Clock_tickPeriod
</span></h4>
<p>To use <code>Clock_tickPeriod</code>, remember to include the kernel <code>Clock module</code> header: <code>#include &lt;ti/sysbios/knl/Clock.h&gt;</code></p>
<p>The value of this variable [µs/tick] is determined when the TI-RTOS .cfg file is parsed. If <code>Clock.tickPeriod = nn;</code> is not present in the .cfg file, the default value is used. Since the tick period can vary between projects, it's useful to include the variable <code>Clock_tickPeriod</code> in calculations that depend on system clock ticks.</p>
</div>
<h2 id="task-3-1">Task 3.1</h2>
<ul>
<li>Replace the use of <code>myDelay</code> to sleep with <code>Task_sleep</code> and use it to sleep for 500ms.<ul>
<li>How do you convert an argument in microseconds to an argument in system ticks?<div class="panel-group">
  <div class="panel panel-success">
    <div class="panel-heading">
      <h4 class="panel-title">
        <a class="accordion-toggle collapsed" data-toggle="collapse" href="#expandable_-answer-if-you-re-stumped-"><p> Answer if you're stumped</p>
</a>
      </h4>
    </div>
    <div id="expandable_-answer-if-you-re-stumped-" class="panel-collapse collapse">
      <div class="panel-body"><div style="display:inline-block"><div style="display:block"><button type="button" class="btn btn-xs btn-warning float-right select-text" style="margin: 0; position: relative;" onclick="SelectText('codeBlock_5')">Select text</button></div><div class="pre-container"><pre><code id="codeBlock_5" class="lang-c hljs cpp"><span class="hljs-comment">//myDelay(24000000);</span>
Task_sleep(<span class="hljs-number">500</span> * (<span class="hljs-number">1000</span> / Clock_tickPeriod));
</code></pre></div></div>
</div>
    </div>
  </div>
</div></li>
</ul>
</li>
<li><p>Rebuild/reload/run. Let the code run for a while and have another look at the Execution Graph, does it look any different? Note: you may have to zoom out to see the transitions.</p>
<p></p><div class="modal-pop" style="cursor:zoom-in;"><img src="resources/execution_graph_better.png" alt="" class="img-responsive"></div><p></p>
<p>Now we see that idle was given a chance to run. For low power devices, going into idle will allow the device to transition to lower power modes.</p>
<p>Note: for the CC26xx, there are setting to minimize flash usage (e.g. <code>Text.isLoaded</code>). We can tell which task is which by looking in ROV2's Task Details</p>
<p></p><div class="modal-pop" style="cursor:zoom-in;"><img src="resources/task_names.png" alt="" class="img-responsive"></div><p></p>
</li>
</ul>
<div class="bs-callout bs-callout-info "><h4><span style="vertical-align: middle;">Number of Log Records
</span></h4>
<p>  You can control the number of kernel records via the <code>LoggingSetup.sysbiosLoggerSize</code> variable in the .cfg file. Each record is ~20-48 bytes since they are stored as binary codes (not ASCII). In this example we had 1024 bytes, so we get around 30-35 records. For a more complex execution application you'll probably need more Log records for a detailed execution graph.</p>
</div>
<h1 id="task-4-executing-urgent-work">Task 4 - Executing urgent work</h1>
<p>Next we are going to expand on the original code by adding a <code>doUrgentWork</code> function and task.
In our system, this will represent the most important work processing the system needs to do. This is more important than the work done by the <code>workTask</code> and should execute as quickly as possible.</p>
<h2 id="setting-up-the-new-task">Setting up the new task</h2>
<ul>
<li>First copy, paste and rename the <code>workTaskFunc</code> function to create a new task function called <code>urgentWorkTaskFunc</code>.</li>
<li>Let <code>urgentWorkTaskFunc</code> call <code>doUrgentWork</code>.</li>
<li>Copy, paste and rename the <code>Task_Struct</code> and the task stack storage as well for <code>urgentTask</code>.</li>
<li>Construct the new task (copy and rename the parameters and the construction) and set the priority of the new task to 1. We'll play with this later... <strong>Note:</strong> Higher priority number means higher priority.</li>
<li>Reduce the <code>Task_sleep()</code> time to 50ms in <code>urgentWorkTaskFunc</code>.</li>
</ul>
<div class="bs-callout bs-callout-warning "><h4><span class="glyphicon glyphicon-exclamation-sign gi-2x" style="vertical-align: middle; margin-right: 0.2em;"></span><span style="vertical-align: middle;">CC3220 LaunchPad LEDs
</span></h4>
<p>  There is a pin conflict with the LEDs and I2C/PWM. To get LED1 to work, please read the comments in the <em>Board</em> files and adjust accordingly. For example, with the CC3220SF-LAUNCHXL, change the following lines in the following files</p>
<ul>
<li><code>Board.h</code>: Change LED1's define <code>#define Board_GPIO_LED1              CC3220SF_LAUNCHXL_GPIO_LED_D6</code></li>
<li><code>CC3220SF_LAUNCHXL.h</code>: Uncomment <code>CC3220SF_LAUNCHXL_GPIO_LED_D6,</code></li>
<li><code>CC3220SF_LAUNCHXL.c</code>: Uncomment <code>GPIOCC32XX_GPIO_10 | GPIO_CFG_OUT_STD | GPIO_CFG_OUT_STR_HIGH | GPIO_CFG_OUT_LOW,</code></li>
</ul>
</div>
<div class="bs-callout bs-callout-info "><h4><span class="glyphicon glyphicon-info-sign gi-2x" style="vertical-align: middle; margin-right: 0.2em;"></span><span style="vertical-align: middle;">Tasks
</span></h4>
<p>A <code>Task</code> has some information associated with it. This is stored in the <code>Task_Struct</code>, which holds the variables the TI-RTOS kernel needs to act on the Task, for example to make it pend on a Semaphore, place it in a Ready queue, or just check the current priority.</p>
<p>A <code>Task</code> also needs a <code>Stack</code> to place function-local variables. The stack is just an array of bytes that we tell TI-RTOS to use. When a specific Task is running, the CPU's stack pointer will point into the memory area of this array. This is a part of how multi-threading is accomplished, because each Task thinks on a low level that it is operating independently.
For example <code>workTaskFunc</code> uses <code>workTaskStack</code> for its local variables and function calls.</p>
<p>For more information on tasks, refer to the TI-RTOS kernel documentation in the <code>&lt;SimpleLink_SDK_Install_dir&gt;/docs/documentation_overview.html</code> file.</p>
</div>
<p>Rebuild/load/run!</p>
<p>Which LED is flashing at the desired rate?</p>
<div class="quiz-toolbar"><div>
<input type="radio" id="q1.0" class="answer-right" name="quiz-1"><label for="q1.0" class="quiz-label ">LED0</label>
<input type="radio" id="q1.1" class="answer-wrong" name="quiz-1"><label for="q1.1" class="quiz-label ">LED1</label>
</div></div>
<p>Why is LED1 not running at the desired rate?</p>
<div class="quiz-toolbar"><div>
<input type="radio" id="q2.2" class="answer-right" name="quiz-2"><label for="q2.2" class="quiz-label " data-toggle="tooltip" data-html="true" data-container="body" data-placement="auto top" data-trigger="click" title="" data-original-title="&lt;p&gt; It is only running when the workTaskFunc task is sleeping.&lt;/p&gt;
">The urgentWorkTaskFunc task has a lower priority </label>
<input type="radio" id="q2.3" class="answer-wrong" name="quiz-2"><label for="q2.3" class="quiz-label ">I messed up</label>
</div></div>
<p>Let's look at the execution graph again.</p>
<p></p><div class="modal-pop" style="cursor:zoom-in;"><img src="resources/execution_graph_wrong_priority.png" alt="" class="img-responsive"></div><p></p>
<div class="panel-group">
  <div class="panel panel-success">
    <div class="panel-heading">
      <h4 class="panel-title">
        <a class="accordion-toggle collapsed" data-toggle="collapse" href="#expandable_-solution-if-your-not-sure-"><p> Solution if your not sure</p>
</a>
      </h4>
    </div>
    <div id="expandable_-solution-if-your-not-sure-" class="panel-collapse collapse">
      <div class="panel-body"><div style="display:inline-block"><div style="display:block"><button type="button" class="btn btn-xs btn-warning float-right select-text" style="margin: 0; position: relative;" onclick="SelectText('codeBlock_6')">Select text</button></div><div class="pre-container"><pre><code id="codeBlock_6" class="lang-c hljs cpp">   <span class="hljs-comment">/* TI-RTOS Header files */</span>
  <span class="hljs-preprocessor">#<span class="hljs-keyword">include</span> &lt;xdc/std.h&gt;</span>
  <span class="hljs-preprocessor">#<span class="hljs-keyword">include</span> &lt;ti/sysbios/BIOS.h&gt;</span>
  <span class="hljs-preprocessor">#<span class="hljs-keyword">include</span> &lt;ti/sysbios/knl/Task.h&gt;</span>
  <span class="hljs-preprocessor">#<span class="hljs-keyword">include</span> &lt;ti/sysbios/knl/Clock.h&gt;</span>

  <span class="hljs-preprocessor">#<span class="hljs-keyword">include</span> &lt;ti/drivers/GPIO.h&gt;</span>

  <span class="hljs-comment">/* Example/Board Header files */</span>
  <span class="hljs-preprocessor">#<span class="hljs-keyword">include</span> "Board.h"</span>

  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">myDelay</span><span class="hljs-params">(<span class="hljs-keyword">int</span> count)</span></span>;

  <span class="hljs-comment">/* Could be anything, like computing primes */</span>
  <span class="hljs-preprocessor">#<span class="hljs-keyword">define</span> FakeBlockingSlowWork()   myDelay(12000000)</span>
  <span class="hljs-preprocessor">#<span class="hljs-keyword">define</span> FakeBlockingFastWork()   myDelay(2000000)</span>

  Task_Struct workTask;
  Task_Struct urgentWorkTask;
  <span class="hljs-comment">/* Make sure we have nice 8-byte alignment on the stack to avoid wasting memory */</span>
  <span class="hljs-preprocessor">#<span class="hljs-keyword">pragma</span> DATA_ALIGN(workTaskStack, 8)</span>
  <span class="hljs-preprocessor">#<span class="hljs-keyword">define</span> STACKSIZE 1024</span>
  <span class="hljs-keyword">static</span> <span class="hljs-keyword">uint8_t</span> workTaskStack[STACKSIZE];
  <span class="hljs-keyword">static</span> <span class="hljs-keyword">uint8_t</span> urgentWorkTaskStack[STACKSIZE];

  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">doUrgentWork</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span>
  </span>{
      GPIO_write(Board_GPIO_LED1, Board_GPIO_LED_OFF);
      FakeBlockingFastWork(); <span class="hljs-comment">/* Pretend to do something useful but time-consuming */</span>
      GPIO_write(Board_GPIO_LED1, Board_GPIO_LED_ON);
  }

  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">doWork</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span>
  </span>{
      GPIO_write(Board_GPIO_LED0, Board_GPIO_LED_OFF);
      FakeBlockingSlowWork(); <span class="hljs-comment">/* Pretend to do something useful but time-consuming */</span>
      GPIO_write(Board_GPIO_LED0, Board_GPIO_LED_ON);
  }

  <span class="hljs-function">Void <span class="hljs-title">workTaskFunc</span><span class="hljs-params">(UArg arg0, UArg arg1)</span>
  </span>{
      <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>) {

          <span class="hljs-comment">/* Do work */</span>
          doWork();

          <span class="hljs-comment">/* Wait a while, because doWork should be a periodic thing, not continuous.*/</span>
          <span class="hljs-comment">//myDelay(24000000);</span>
          Task_sleep(<span class="hljs-number">500</span> * (<span class="hljs-number">1000</span> / Clock_tickPeriod));
      }
  }

  <span class="hljs-function">Void <span class="hljs-title">urgentWorkTaskFunc</span><span class="hljs-params">(UArg arg0, UArg arg1)</span>
  </span>{
      <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>) {

          <span class="hljs-comment">/* Do work */</span>
          doUrgentWork();

          <span class="hljs-comment">/* Wait a while, because doWork should be a periodic thing, not continuous.*/</span>
          <span class="hljs-comment">//myDelay(24000000);</span>
          Task_sleep(<span class="hljs-number">50</span> * (<span class="hljs-number">1000</span> / Clock_tickPeriod));
      }
  }

  <span class="hljs-comment">/*
   *  ======== main ========
   *
   */</span>
  <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span>
  </span>{
      Board_initGeneral();
      GPIO_init();

      <span class="hljs-comment">/* Set up the led task */</span>
      Task_Params workTaskParams;
      Task_Params_init(&amp;workTaskParams);
      workTaskParams.stackSize = STACKSIZE;
      workTaskParams.priority = <span class="hljs-number">2</span>;
      workTaskParams.<span class="hljs-built_in">stack</span> = &amp;workTaskStack;

      Task_construct(&amp;workTask, workTaskFunc, &amp;workTaskParams, NULL);

      workTaskParams.priority = <span class="hljs-number">1</span>;
      workTaskParams.<span class="hljs-built_in">stack</span> = &amp;urgentWorkTaskStack;

      Task_construct(&amp;urgentWorkTask, urgentWorkTaskFunc, &amp;workTaskParams, NULL);

      <span class="hljs-comment">/* Start kernel. */</span>
      BIOS_start();

      <span class="hljs-keyword">return</span> (<span class="hljs-number">0</span>);
  }

  <span class="hljs-comment">/*
   *  ======== myDelay ========
   *  Assembly function to delay. Decrements the count until it is zero
   *  The exact duration depends on the processor speed.
   */</span>
  __asm(<span class="hljs-string">"    .sect \".text:myDelay\"\n"</span>
        <span class="hljs-string">"    .clink\n"</span>
        <span class="hljs-string">"    .thumbfunc myDelay\n"</span>
        <span class="hljs-string">"    .thumb\n"</span>
        <span class="hljs-string">"    .global myDelay\n"</span>
        <span class="hljs-string">"myDelay:\n"</span>
        <span class="hljs-string">"    subs r0, #1\n"</span>
        <span class="hljs-string">"    bne.n myDelay\n"</span>
        <span class="hljs-string">"    bx lr\n"</span>);
</code></pre></div></div>
</div>
    </div>
  </div>
</div><h2 id="changing-priority">Changing priority</h2>
<p>Let's just change the <code>workTaskParams.priority</code> from 1 to 3 and rebuild/reload/run again.</p>
<div style="display:inline-block"><div style="display:block"><button type="button" class="btn btn-xs btn-warning float-right select-text" style="margin: 0; position: relative;" onclick="SelectText('codeBlock_7')">Select text</button></div><div class="pre-container"><pre><code id="codeBlock_7" class="lang-c hljs cpp">    workTaskParams.priority = <span class="hljs-number">3</span>;
    workTaskParams.<span class="hljs-built_in">stack</span> = &amp;urgentWorkTaskStack;

    Task_construct(&amp;urgentWorkTask, urgentWorkTaskFunc, &amp;workTaskParams, NULL);
</code></pre></div></div>
<p>The "urgent" LED1 is now flashing at the desired rate (because it's an higher priority task now).</p>
<h1 id="additional-resources">Additional Resources</h1>
<p>Additional training and reference material for TI-RTOS is available in the following places:</p>
<h2 id="simplelink-academy">SimpleLink Academy</h2>
<ul>
<li><a href="../posix_project_zero/posix_project_zero.html">POSIX Project Zero Workshop</a></li>
</ul>
<h2 id="online">Online</h2>
<ul>
<li><a href="http://www.ti.com/tool/TI-RTOS">TI-RTOS Product Page</a></li>
<li><a href="http://processors.wiki.ti.com/index.php/TI-RTOS">TI-RTOS "Engineer" Page</a></li>
<li><a href="https://training.ti.com/ti-rtos-workshop-series">TI-RTOS 2 day workshop</a></li>
</ul>
<div align="center" style="margin-top: 4em; font-size: smaller;">
<a rel="license" href="http://creativecommons.org/licenses/by-nc-nd/4.0/"><img alt="Creative Commons License" style="border-width:0" src="../../web_support/cc_license_icon.png"></a><br>This work is licensed under a <a rel="license" href="http://creativecommons.org/licenses/by-nc-nd/4.0/">Creative Commons Attribution-NonCommercial-NoDerivatives 4.0 International License</a>.</div>

</div><div class="col-xs-4 col-sm-2 sidebar-offcanvas bs-docs-sidebar hidden-print" id="sidebar-overview"><ul class="nav nav-stacked fixed" id="sidebar"><li><a href="#introduction">Introduction</a></li><li><a href="#recommended-background-reading">Recommended Background Reading</a></li><li><a href="#a-brief-history-of-ti-rtos">A Brief History of TI-RTOS</a></li><li><a href="#ti-rtos-product">TI-RTOS Product</a></li><li><a href="#ti-rtos-kernel">TI-RTOS Kernel</a><ul class="nav nav-stacked"><li><a href="#scheduler">Scheduler</a></li><li><a href="#thread-communication">Thread Communication</a></li><li><a href="#timing-services">Timing Services</a></li><li><a href="#memory-managers">Memory Managers</a></li><li><a href="#posix-portable-operating-system-interface-support">POSIX (Portable Operating System Interface) Support</a></li></ul></li><li><a href="#simplelink-sdk-components-and-ti-rtos">SimpleLink SDK Components and TI-RTOS</a><ul class="nav nav-stacked"><li><a href="#ti-drivers">TI Drivers</a></li><li><a href="#other">Other</a></li></ul></li><li><a href="#ti-rtos-configuration-and-examples">TI-RTOS Configuration and Examples</a><ul class="nav nav-stacked"><li><a href="#kernel-projects">Kernel Projects</a></li><li><a href="#examples">Examples</a></li></ul></li><li><a href="#debugging-features-and-tools">Debugging Features and Tools</a><ul class="nav nav-stacked"><li><a href="#rtos-object-view-rov-">RTOS Object View (ROV)</a></li><li><a href="#runtime-object-view">Runtime Object View</a></li><li><a href="#system-analyzer">System Analyzer</a></li></ul></li><li><a href="#lab-getting-started">Lab: Getting started</a><ul class="nav nav-stacked"><li><a href="#software">Software</a></li><li><a href="#hardware">Hardware</a></li><li><a href="#making-sure-it-works">Making sure it works</a></li></ul></li><li><a href="#task-1-replacing-the-contents-of-hello-c">Task 1 - Replacing the contents of hello.c</a><ul class="nav nav-stacked"><li><a href="#orienting-ourselves-in-the-code">Orienting ourselves in the code</a></li></ul></li><li><a href="#task-2-debugging-tools">Task 2 - Debugging Tools</a><ul class="nav nav-stacked"><li><a href="#runtime-object-view">Runtime Object View</a></li><li><a href="#execution-graph">Execution graph</a></li></ul></li><li><a href="#task-3-sleeping-well">Task 3 - Sleeping well</a><ul class="nav nav-stacked"><li><a href="#task-3-1">Task 3.1</a></li></ul></li><li><a href="#task-4-executing-urgent-work">Task 4 - Executing urgent work</a><ul class="nav nav-stacked"><li><a href="#setting-up-the-new-task">Setting up the new task</a></li><li><a href="#changing-priority">Changing priority</a></li></ul></li><li><a href="#additional-resources">Additional Resources</a><ul class="nav nav-stacked"><li><a href="#simplelink-academy">SimpleLink Academy</a></li><li><a href="#online">Online</a></li></ul></li></ul></div></div></div></div>




<link rel="stylesheet" href="../../web_support/highlight/styles/zenburn.css">
<script src="../../web_support/strapdown/vendor/jquery-1.11.2.min.js"></script>
<script src="../../web_support/strapdown/vendor/bootstrap.min.js"></script>
<script src="../../web_support/highlight/highlight.pack.js"></script>
<script type="text/javascript">document.isPreRendered = true;</script><script src="../../web_support/strapdown/v/0.2/strapdown.js"></script>      <div class="modal" id="imagemodal" tabindex="-1" role="dialog" aria-labelledby="myModalLabel" aria-hidden="true">        <div class="vertical-alignment-helper">          <div class="modal-dialog vertical-align-center">             <div class="modal-dialog">               <div class="modal-content" style="margin-left: auto;margin-right: auto;">                 <div class="modal-body">                   <button type="button" class="close" data-dismiss="modal"><span aria-hidden="true">×</span><span class="sr-only">Close</span></button>                   <img src="" class="imagepreview img-responsive">                 </div>              </div>            </div>          </div>        </div>      </div>


</body></html>